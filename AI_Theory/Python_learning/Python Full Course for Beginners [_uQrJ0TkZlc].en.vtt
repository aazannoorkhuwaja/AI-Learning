WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:04.000
Hi, my name is Mosh, and I'm going to be your instructor in this Python course.

00:00:04.000 --> 00:00:08.000
In this course, you're going to learn everything you need to get started programming in Python.

00:00:08.000 --> 00:00:12.000
Python is one of the most popular programming languages, and every day people use it to do

00:00:12.000 --> 00:00:16.000
cool things like automation, they use it in AI, as well as

00:00:16.000 --> 00:00:20.000
building applications and websites like Instagram and Dropbox. So if you're looking

00:00:20.000 --> 00:00:24.000
for a job, Python is for you. In this course I'm going to teach you everything 

00:00:24.000 --> 00:00:28.000
you need to get started with Python. We're going to talk about all the core concepts

00:00:28.000 --> 00:00:32.000
in Python, and then we're going to build three Python projects together.

00:00:32.000 --> 00:00:36.000
Here's the first project we're going to build. We're going to learn how to create this beautiful website

00:00:36.000 --> 00:00:40.000
for an imaginary grocery store. Here on the homepage we can see all

00:00:40.000 --> 00:00:44.000
of the products in the shop, and we also have an admin area for managing the

00:00:44.000 --> 00:00:48.000
stock. We're going to build this using a popular Python framework called Django. 

00:00:48.000 --> 00:00:52.000
Now if you have never built a website before, don't worry, I will teach you everything from scratch. 

00:00:52.000 --> 00:00:56.000
You're also going to learn how to use Python in machine learning, or artificial intelligence. 

00:00:56.000 --> 00:01:00.000
So you will learn how to write a Python programming that will predict

00:01:00.000 --> 00:01:04.000
the music that people like based on their profile. Just like how YouTube

00:01:04.000 --> 00:01:08.000
recommends videos based on the videos you have watched before. I will also show you 

00:01:08.000 --> 00:01:12.000
python to automate boring repetitive tasks that waste your time. 

00:01:12.000 --> 00:01:16.000
You will write a Python program that will process thousands of spreadsheets

00:01:16.000 --> 00:01:20.000
in under a second. I've designed this Python course for anyone who wants to learn

00:01:20.000 --> 00:01:24.000
Python. If you're a beginner, don't worry, I will hold your hand through this entire course. 

00:01:24.000 --> 00:01:28.000
You're not too old or too young, and Python is super easy to learn. You can write your first

00:01:28.000 --> 00:01:32.000
Python program in literally seconds. Plus I'm going to give you plenty

00:01:32.000 --> 00:01:36.000
of exercises to help you build your confidence writing cool Python programs. 

00:01:36.000 --> 00:01:40.000
My name is Mosh, I'm a software engineer with two decades of experience 

00:01:40.000 --> 00:01:44.000
and I've taught over 3 million people how to code. I'm super excited to be teaching you

00:01:44.000 --> 00:01:48.000
Python in this course. So I hope you stick around and learn this beautiful 

00:01:48.000 --> 00:01:52.000
powerful programming language. 

00:01:52.000 --> 00:01:56.000
In this tutorial I'm going to show you how to download 

00:01:56.000 --> 00:02:00.000
and install Python on your computer. So the first thing I want you to do,

00:02:00.000 --> 00:02:04.000
is open up your browser and head over to Python

00:02:04.000 --> 00:02:08.000
.org. On this page click on downloads, 

00:02:08.000 --> 00:02:12.000
here you can see the latest version of Python currently, at the time of recording this video

00:02:12.000 --> 00:02:16.000
the latest version is python 3.7.2. 

00:02:16.000 --> 00:02:20.000
Chances are in the future, when you are watching this tutorial, there is a newer 

00:02:20.000 --> 00:02:24.000
version of Python available, don't worry, all the materials you're going to learn in this course 

00:02:24.000 --> 00:02:28.000
will apply to the latest version of Python as well. So let's go ahead

00:02:28.000 --> 00:02:32.000
and download Python 3, alright now, 

00:02:32.000 --> 00:02:36.000
look at your downloads folder, here, we should have Python 3 installer

00:02:36.000 --> 00:02:40.000
simply double click that, if you're on Windows 

00:02:40.000 --> 00:02:44.000
you're going to see this check box here, add Python to

00:02:44.000 --> 00:02:48.000
python, this is really important, make sure to tick this box, otherwise you're not going to be able to

00:02:48.000 --> 00:02:52.000
follow this tutorial. If you're on a Mac, 

00:02:52.000 --> 00:02:56.000
you're going to see an installer like this, with this setup wizard we're going to install Python 3

00:02:56.000 --> 00:03:00.000
on our computer. So simply click continue, and again, 

00:03:00.000 --> 00:03:04.000
and again, and agree with the license agreement, and 

00:03:04.000 --> 00:03:08.000
install it, this is going to take a few seconds so I'm going

00:03:08.000 --> 00:03:12.000
to pause the recording. 

00:03:12.000 --> 00:03:16.000
Alright, we have successfully installed Python 3 on our computer. 

00:03:16.000 --> 00:03:20.000
Let's close this. Alright, next we need to install

00:03:20.000 --> 00:03:24.000
a code editor, we se a code editor to write our code, just like

00:03:24.000 --> 00:03:28.000
how we use Microsoft Word to write documents, we use a code editor to write

00:03:28.000 --> 00:03:32.000
code. Now there are so many code editors out there, the one that I'm going to show you in this

00:03:32.000 --> 00:03:36.000
tutorial is PyCharm. That is one of the most popular code editors 

00:03:36.000 --> 00:03:40.000
for writing Python code. You can get it from jetbrains.com

00:03:40.000 --> 00:03:44.000
/pycharm. Now more accurately pycharm 

00:03:44.000 --> 00:03:48.000
is considered an IDE, which is short for integrated development

00:03:48.000 --> 00:03:52.000
environment. And that's basically a code editor on steroids, 

00:03:52.000 --> 00:03:56.000
it has some additional features that makes it really easy to write code. So

00:03:56.000 --> 00:04:00.000
let's go ahead and download PyCharm. Now here on the

00:04:00.000 --> 00:04:04.000
download page, you can see two versions of PyCharm, one is the professional addition 

00:04:04.000 --> 00:04:08.000
which has additional features and you have to pay for them. The other is the

00:04:08.000 --> 00:04:12.000
community edition, that is absolutely free, and that's what we're going to use in this tutorial. 

00:04:12.000 --> 00:04:16.000
So, go ahead and download this as well.

00:04:16.000 --> 00:04:20.000
Now, once again look at your downloads folder, once again you should have pycharm 

00:04:20.000 --> 00:04:24.000
so double click this, now if you're

00:04:24.000 --> 00:04:28.000
in Windows you're going to see an installation wizard, simply click next, next, next

00:04:28.000 --> 00:04:32.000
until you install pycharm. If you're on Mac you need to drag and drop this icon 

00:04:32.000 --> 00:04:36.000
onto the applications folder, so drag and drop, 

00:04:36.000 --> 00:04:40.000
alright, now let's double click this to run it, 

00:04:40.000 --> 00:04:44.000
the first time we run pycharm we're going to get this warning, because this is an application

00:04:44.000 --> 00:04:48.000
that we download from the internet. So let's go ahead and open it, 

00:04:48.000 --> 00:04:52.000
next you're going to see this dialogue box for importing some settings, leave this to

00:04:52.000 --> 00:04:56.000
do not import settings, it doesn't really matter. Okay,

00:04:56.000 --> 00:05:00.000
On this page, select I've never used PyCharm you can see some keyword

00:05:00.000 --> 00:05:04.000
shortcuts that might be useful in the future, just accept this, and down at the bottom, 

00:05:04.000 --> 00:05:08.000
click the next button. And then next again,

00:05:08.000 --> 00:05:12.000
one more time, and then finally start using pycharm. 

00:05:12.000 --> 00:05:16.000
So here's the main page of PyCharm every time you open

00:05:16.000 --> 00:05:20.000
it, click on create new project, 

00:05:20.000 --> 00:05:24.000
this is the location for our project, let's call our project Hello

00:05:24.000 --> 00:05:28.000
World. Now before click and create, expand 

00:05:28.000 --> 00:05:32.000
this item here, make sure that base interpreter is set to Python

00:05:32.000 --> 00:05:36.000
3. Python interpreter is basically a program 

00:05:36.000 --> 00:05:40.000
that knows how to execute Python code, it will know how to interpret 

00:05:40.000 --> 00:05:44.000
or translate Python instructions into instructions a computer can understand. 

00:05:44.000 --> 00:05:48.000
Now, Mac computers, by default come with an older

00:05:48.000 --> 00:05:52.000
installation of Python, that's Python 2, it's considered legacy

00:05:52.000 --> 00:05:56.000
which means it's no longer maintained or supported. So earlier we downloaded 

00:05:56.000 --> 00:06:00.000
Python 3, make sure that this is set to Python 3, if not

00:06:00.000 --> 00:06:04.000
from this list, select Python 3.7. 

00:06:04.000 --> 00:06:08.000
Alright, now let's go ahead and create this project,

00:06:12.000 --> 00:06:16.000
Now here right click on

00:06:16.000 --> 00:06:20.000
Hello World folder and go to new 

00:06:20.000 --> 00:06:24.000
Python file, call this file app.py. 

00:06:24.000 --> 00:06:28.000
So by convention, all Python files should have this

00:06:28.000 --> 00:06:32.000
py extension. Alright, let's go ahead,

00:06:32.000 --> 00:06:36.000
now let's collapse this project panel by clicking here and write our

00:06:36.000 --> 00:06:40.000
first python program. Simply type print, pr

00:06:40.000 --> 00:06:44.000
int, all in lowercase, open and close parenthesis, 

00:06:44.000 --> 00:06:48.000
and inside these parenthesis, add quotations we

00:06:48.000 --> 00:06:52.000
can either use single quotes or double quotes, now

00:06:52.000 --> 00:06:56.000
in between the codes write your name. I am Mosh Hamedani, so

00:06:56.000 --> 00:07:00.000
here, so this is your first Python programming. With these piece of code

00:07:00.000 --> 00:07:04.000
you can print your name on the screen. Now to run this, go

00:07:04.000 --> 00:07:08.000
on the top, under the run menu, click run, 

00:07:08.000 --> 00:07:12.000
also note that there is a shortcut associated with this command, when

00:07:12.000 --> 00:07:16.000
I program I always use shortcuts because that increases my productivity. 

00:07:16.000 --> 00:07:20.000
So here on a Mac computer, the shortcut is control, option, and

00:07:20.000 --> 00:07:24.000
R. On Windows it's different. So let's do that, now

00:07:24.000 --> 00:07:28.000
it's asking where you want to run this, click on app, 

00:07:28.000 --> 00:07:32.000
down below, you should see this little terminal window, this

00:07:32.000 --> 00:07:36.000
is a little window into our program, so here you can see our results for

00:07:36.000 --> 00:07:40.000
output for our program. In the future as you learn more Python, you'll be

00:07:40.000 --> 00:07:44.000
able to build applications that have a graphical user interface, or gooey. 

00:07:44.000 --> 00:07:48.000
That is a little bit complicated, so for now we're going to use this little

00:07:48.000 --> 00:07:52.000
terminal window to see the results of our program. So as you can see my name is

00:07:52.000 --> 00:07:56.000
printed here, now as you print code, this window might get in the way so

00:07:56.000 --> 00:08:00.000
always resize it or minimize itty putting this

00:08:00.000 --> 00:08:04.000
icon here, so this was our first python program. Now

00:08:04.000 --> 00:08:08.000
if you didn't see the result I showed you in this video, use the comment box below and

00:08:08.000 --> 00:08:12.000
tell me what error you encountered, I'll do my best to help you move forward. 

00:08:16.000 --> 00:08:20.000
In this Python tutorial, we're gong to take this program to the next level and make it more interesting. 

00:08:20.000 --> 00:08:24.000
So I'm going to show you how to draw a dog hair. Now as part of

00:08:24.000 --> 00:08:28.000
this tutorial you will learn how Python code gets executed and you will also learn

00:08:28.000 --> 00:08:32.000
about a few programming terms. So press enter, and 

00:08:32.000 --> 00:08:36.000
on line 2 write another print statement, so print, open and close

00:08:36.000 --> 00:08:40.000
parenthesis, add a quotation, now here you want to draw a dog. 

00:08:40.000 --> 00:08:44.000
So, add an o, that is the head of our dog, followed by

00:08:44.000 --> 00:08:48.000
4 hyphens. So this is the body. 

00:08:48.000 --> 00:08:52.000
alright, now one more time another print statement with

00:08:52.000 --> 00:08:56.000
quotations, now we need to draw the legs. So add a space. 

00:08:56.000 --> 00:09:00.000
Follow it by 4 vertical bars. So, like this, 

00:09:00.000 --> 00:09:04.000
so here's a little imaginary dot. Now let's 

00:09:04.000 --> 00:09:08.000
run this program and see what we get. So on the top right corner you should see this play button, 

00:09:08.000 --> 00:09:12.000
click that, there you go, so we have our name and 

00:09:12.000 --> 00:09:16.000
right below that we have our imaginary dog. Now what you need to understand 

00:09:16.000 --> 00:09:20.000
here, is that our python code gets executed line by line

00:09:20.000 --> 00:09:24.000
from the top. So earlier I told you about Python interpreter 

00:09:24.000 --> 00:09:28.000
that is the program that knows how to translate or interpret 

00:09:28.000 --> 00:09:32.000
our Python code into instructions that a computer can understand.

00:09:32.000 --> 00:09:36.000
So when we run this program by clicking this program here, 

00:09:36.000 --> 00:09:40.000
python interpreter starts executing or running our program 

00:09:40.000 --> 00:09:44.000
line by line from the top. So first it executes line 1, 

00:09:44.000 --> 00:09:48.000
then, moves onto line 2, and so on. So this is how python 

00:09:48.000 --> 00:09:52.000
programs get executed. Now let me show you something cool. Let's add 

00:09:52.000 --> 00:09:56.000
another print statement, with quotations now

00:09:56.000 --> 00:10:00.000
in between the quotations, add a star or an asterisk, like

00:10:00.000 --> 00:10:04.000
this. Now after the quotation and before the parenthesis, 

00:10:04.000 --> 00:10:08.000
add a space, once again, add an asterisk, 

00:10:08.000 --> 00:10:12.000
space, 10. What is going on here? Well, 

00:10:12.000 --> 00:10:16.000
anywhere we have quotations like here or here

00:10:16.000 --> 00:10:20.000
we're defining a string, a string is a programming term which means 

00:10:20.000 --> 00:10:24.000
a series of characters so here we have a string, we also have

00:10:24.000 --> 00:10:28.000
a string on line 3, as well as line 2 and line 1. 

00:10:28.000 --> 00:10:32.000
Now here, we're multiplying the string by 

00:10:32.000 --> 00:10:36.000
number 10. So this is the multiplication operator, just like the multiplication 

00:10:36.000 --> 00:10:40.000
operator we have in math. So with this piece of code we can

00:10:40.000 --> 00:10:44.000
draw 10 asterisks on the terminal, let me show you. So let's run this

00:10:44.000 --> 00:10:48.000
program one more time, there you go. So we have 10

00:10:48.000 --> 00:10:52.000
asterisks. Now what we have here, this piece of code here, 

00:10:52.000 --> 00:10:56.000
is called an expression. An expression is a piece of 

00:10:56.000 --> 00:11:00.000
code that produces a value. So when Python interpreter 

00:11:00.000 --> 00:11:04.000
tries to execute line 4, first it will evaluate 

00:11:04.000 --> 00:11:08.000
the code that we put in between parenthesis, so we could evaluate our expressions 

00:11:08.000 --> 00:11:12.000
Our expression will produce 10 asterisks and then

00:11:12.000 --> 00:11:16.000
those asterisks will be printed on the terminal. Now as an exercise 

00:11:16.000 --> 00:11:20.000
you can use these print statements to draw another shape, you can draw a heart, a 

00:11:20.000 --> 00:11:24.000
ball, whatever you like. I will see you in the next tutorial. 

00:11:24.000 --> 00:11:28.000
One of the questions I get a lot on my channel is

00:11:28.000 --> 00:11:32.000
how long does it take to learn Python and become job ready? Well there is no single 

00:11:32.000 --> 00:11:36.000
answer. It really depends on you and how much effort and commitment you want to put 

00:11:36.000 --> 00:11:40.000
into this. But I would say if you spend 2 hours every day

00:11:40.000 --> 00:11:44.000
consistently, after about 3 months you should be able to write 

00:11:44.000 --> 00:11:48.000
basic python programs, but quite honestly, that doesn't get you a job. 

00:11:48.000 --> 00:11:52.000
In order to get a job, you need to specialize in one area,

00:11:52.000 --> 00:11:56.000
what do you want to use python for? Do you want to build web applications or

00:11:56.000 --> 00:12:00.000
desktop applications? Or do you want to use it in machine learning and artificial intelligence?

00:12:00.000 --> 00:12:04.000
So whatever you want to do you need to take additional courses. 

00:12:04.000 --> 00:12:08.000
For example if you want to become a web developer in addition to learning

00:12:08.000 --> 00:12:12.000
Python, you should also learn about html, some css, some

00:12:12.000 --> 00:12:16.000
JavaScript and Django which is a popular Python framework 

00:12:16.000 --> 00:12:20.000
for building web applications. Learning all these things would take you another 

00:12:20.000 --> 00:12:24.000
6 months, so in total you need 9-12 months to become

00:12:24.000 --> 00:12:28.000
job ready. At that point you can get a junior developer job with a 

00:12:28.000 --> 00:12:32.000
salary of about 50-60 thousand dollars a year. Now as you work more

00:12:32.000 --> 00:12:36.000
as you do more Python projects, your resume starts to build and 

00:12:36.000 --> 00:12:40.000
you can ask for $100,000 a year, or 120,000 dollars

00:12:40.000 --> 00:12:44.000
a year, depending on where you are, what company, what geographical area, 

00:12:44.000 --> 00:12:48.000
it really depends, there is no single answer. So are you excited to

00:12:48.000 --> 00:12:52.000
learn Python and get started on this career path? If you are, I would encourage you

00:12:52.000 --> 00:12:56.000
to make a commitment and spend 2 hours every day practicing 

00:12:56.000 --> 00:13:00.000
python. And use the comment box below and let me know why you are learning 

00:13:00.000 --> 00:13:04.000
Python, what do you want to do with it? What's your dream job? I would love to hear your story.

00:13:08.000 --> 00:13:12.000
In this Python tutorial, you're going to learn about variables, which are one of the most fundamental 

00:13:12.000 --> 00:13:16.000
concepts in programming, they're not specific to Python, they exist 

00:13:16.000 --> 00:13:20.000
in pretty much every programming language out there. We use variables 

00:13:20.000 --> 00:13:24.000
to temporarily store data in a computer's memory. Here's an example, 

00:13:24.000 --> 00:13:28.000
let's type price = 10, when Python

00:13:28.000 --> 00:13:32.000
interpreter executes this code, it will allocate some memory, then it will store 

00:13:32.000 --> 00:13:36.000
the number 10 in that memory, and finally it will attach this

00:13:36.000 --> 00:13:40.000
price label in that memory location. As a metahor

00:13:40.000 --> 00:13:44.000
imagine we have a box. In that box, we have number 10

00:13:44.000 --> 00:13:48.000
and price is the label that we put on the box. Now we can use this label 

00:13:48.000 --> 00:13:52.000
anywhere in our program to access the value that we have in that box. 

00:13:52.000 --> 00:13:56.000
This is a very simplified explanation. So now, let's 

00:13:56.000 --> 00:14:00.000
print price on the terminal. Print, now this time we're not going to

00:14:00.000 --> 00:14:04.000
add quotations, because if we put quotations here, we will see the text 

00:14:04.000 --> 00:14:08.000
price on the terminal. Now the value of the price variable. 

00:14:08.000 --> 00:14:12.000
So, put it in quotations, and type price, 

00:14:12.000 --> 00:14:16.000
now, let's run this program one more time, there you go. So we see 10, 

00:14:16.000 --> 00:14:20.000
on the terminal. So this is how we define variables, we 

00:14:20.000 --> 00:14:24.000
start with an identifier which is the name of our variable, then, 

00:14:24.000 --> 00:14:28.000
an equal sign and finally a value. Now more accurately, when

00:14:28.000 --> 00:14:32.000
this number 10 is about to be stored in the memory, first it will

00:14:32.000 --> 00:14:36.000
get converted to this binary for presentation. So this number 10, 

00:14:36.000 --> 00:14:40.000
is in the decimal system which has all the digits from 0 to 9. 

00:14:40.000 --> 00:14:44.000
Computers don't understand all these digits, they only understand 

00:14:44.000 --> 00:14:48.000
0s and 1s. So when we store the number 10 in the computer's memory

00:14:48.000 --> 00:14:52.000
first it will get converted to it's binary representation which will be 

00:14:52.000 --> 00:14:56.000
a bunch of 0's and 1's, like 001, 001, whatever 

00:14:56.000 --> 00:15:00.000
I don't know. Then it will get stored in the computer's memory. So,

00:15:00.000 --> 00:15:04.000
let's take this program to the next level. On the second line we can 

00:15:04.000 --> 00:15:08.000
update the value of this price variable, so we can reset it

00:15:08.000 --> 00:15:12.000
to a new value like 20, now when we run our program, 

00:15:12.000 --> 00:15:16.000
we should see 20, because as I told you before Python interpreter executes our

00:15:16.000 --> 00:15:20.000
code line by line from the top. So first we set 

00:15:20.000 --> 00:15:24.000
the price to 10, then we reset it to 20, and finally we 

00:15:24.000 --> 00:15:28.000
print it on the terminal, let's run the terminal, there you go, so, 

00:15:28.000 --> 00:15:32.000
we see 20 here, okay? Now these

00:15:32.000 --> 00:15:36.000
numbers that we have here are whole numbers without a decimal point. 

00:15:36.000 --> 00:15:40.000
In programming, we refer to these numbers as integers. 

00:15:40.000 --> 00:15:44.000
But integer is a number without a decimal point. We can also use

00:15:44.000 --> 00:15:48.000
numbers with a decimal point for example on line 2, we can define

00:15:48.000 --> 00:15:52.000
another variable called rating and set it to number

00:15:52.000 --> 00:15:56.000
4.9. Now in programming, we refer to this kind of number as 

00:15:56.000 --> 00:16:00.000
a floating point number of float for short. So we have integers 

00:16:00.000 --> 00:16:04.000
and floats. We can also define a variable and set

00:16:04.000 --> 00:16:08.000
it to a string, for example, name equals 

00:16:08.000 --> 00:16:12.000
Mosh, we also have another kind of value which is called boolean, 

00:16:12.000 --> 00:16:16.000
which can be true or false. They are line yes and no in English. 

00:16:16.000 --> 00:16:20.000
Here is an example, I'm going to define a variable, is underline

00:16:20.000 --> 00:16:24.000
published so we use an underscore to separate

00:16:24.000 --> 00:16:28.000
multiple words in our variables name. We set this to

00:16:28.000 --> 00:16:32.000
true, or false. These are

00:16:32.000 --> 00:16:36.000
boolean values. now note that Python is a case 

00:16:36.000 --> 00:16:40.000
sensitive language, which means it's sensitive to lower case and upper case letters. 

00:16:40.000 --> 00:16:44.000
So when defining variables we should always use 

00:16:44.000 --> 00:16:48.000
lowercase letters, but here false and true are special keywords in the 

00:16:48.000 --> 00:16:52.000
language, so if we spell it with a lowercase f, Python doesn't

00:16:52.000 --> 00:16:56.000
understand it. You can see we have a red underline here, which indicates an error. 

00:16:56.000 --> 00:17:00.000
Make sure to spell this with a capital F, or if you want to set this to true, 

00:17:00.000 --> 00:17:04.000
make sure the T is capital, so in this

00:17:04.000 --> 00:17:08.000
program, you're storing simple values in our computer's memory. Simple

00:17:08.000 --> 00:17:12.000
values can be numbers, which can be integers or floats

00:17:12.000 --> 00:17:16.000
or they can be strings or booleans. But in Python 

00:17:16.000 --> 00:17:20.000
we can also store complex values like lists and values. And that's what I'm going to show you

00:17:20.000 --> 00:17:24.000
in the future. So before going any further, I want you 

00:17:24.000 --> 00:17:28.000
to do a little exercise. Imagine we're going to write a program for a hospital. 

00:17:28.000 --> 00:17:32.000
So we check on a patient named John Smith. He's 

00:17:32.000 --> 00:17:36.000
20 years old and is a new patient. I want you to define 3 variables here, 

00:17:36.000 --> 00:17:40.000
for his name, his age, and another variable 

00:17:40.000 --> 00:17:44.000
for if this is a new or an existing patient. So pause the video and spend one

00:17:44.000 --> 00:17:48.000
minute on this exercise. When you're done, come back, continue and see my solution. 

00:17:48.000 --> 00:17:52.000
Alright, so here we need

00:17:52.000 --> 00:17:56.000
three variables, the first one is the patient's name, 

00:17:56.000 --> 00:18:00.000
we set that to John Smith. We can also

00:18:00.000 --> 00:18:04.000
call this full name, these are both valid names for our variables. 

00:18:04.000 --> 00:18:08.000
The second variable is for the age of our patient. So age 

00:18:08.000 --> 00:18:12.000
is 20, and finally we need a variable to tell if this is a new 

00:18:12.000 --> 00:18:16.000
or existing patient. That's where we can use a boolean value. 

00:18:16.000 --> 00:18:20.000
So, we define a variable, is new and 

00:18:20.000 --> 00:18:24.000
we set it to true. 

00:18:24.000 --> 00:18:28.000
So, you have learned how to print

00:18:28.000 --> 00:18:32.000
messages on the terminal window. In this tutorial, I'm going to show you how to 

00:18:32.000 --> 00:18:36.000
receive input from the user. So we're going to write a small program that asks 

00:18:36.000 --> 00:18:40.000
the user's name and then we'll print a greeting message customized

00:18:40.000 --> 00:18:44.000
for that user. So instead of print we're going to use

00:18:44.000 --> 00:18:48.000
input. Now both these input and print 

00:18:48.000 --> 00:18:52.000
are functions that are built into Python. As a metaphor think 

00:18:52.000 --> 00:18:56.000
of the remote control of the TV. On this remote control we have a bunch of 

00:18:56.000 --> 00:19:00.000
buttons, these are the functions built into your tv, you can turn it on,

00:19:00.000 --> 00:19:04.000
turn it off, change the volume and so on. In Python we also have 

00:19:04.000 --> 00:19:08.000
functions for common tasks such as printing messages, receiving input, 

00:19:08.000 --> 00:19:12.000
and so on. So we're going to use the input function, now whenever we

00:19:12.000 --> 00:19:16.000
have these parenthesis, we're going to say we're calling or executing 

00:19:16.000 --> 00:19:20.000
that function, it's like pressing a button on a remote control. So we're

00:19:20.000 --> 00:19:24.000
going to call the input function and in between parenthesis

00:19:24.000 --> 00:19:28.000
we want to add a string to print something on the terminal, 

00:19:28.000 --> 00:19:32.000
what is your name? With a question mark followed by

00:19:32.000 --> 00:19:36.000
a space. You will see why in a second. So this input function

00:19:36.000 --> 00:19:40.000
will print this message on the terminal, and then it will wait for the user to

00:19:40.000 --> 00:19:44.000
enter a value. Whatever the user enters this input function will

00:19:44.000 --> 00:19:48.000
return. So now we can get that value and store it in the memory using a variable. 

00:19:48.000 --> 00:19:52.000
So we get the result and put it in a variable called 

00:19:52.000 --> 00:19:56.000
name. Okay? Now on the second line

00:19:56.000 --> 00:20:00.000
we want to print a message like Hi John or Hi Mosh or whatever, so, 

00:20:00.000 --> 00:20:04.000
print, quotations Hi with a space,

00:20:04.000 --> 00:20:08.000
now after the quotation we want to dynamically print

00:20:08.000 --> 00:20:12.000
what we have in the name variable. So we had

00:20:12.000 --> 00:20:16.000
a plus sign and then name. So here we have

00:20:16.000 --> 00:20:20.000
Hi which is a string, we're concatenating or

00:20:20.000 --> 00:20:24.000
combining the string with another string, that is what we have

00:20:24.000 --> 00:20:28.000
in the name variable. So here's another example of

00:20:28.000 --> 00:20:32.000
an expression. Remember what is an expression? It's a piece of code that

00:20:32.000 --> 00:20:36.000
uses a value. So this expression concatenates or combines 

00:20:36.000 --> 00:20:40.000
2 strings. Let's run this program and see what happens. So run

00:20:40.000 --> 00:20:44.000
okay, here is a question, what is your name? Mosh, 

00:20:44.000 --> 00:20:48.000
now note that earlier we added a space after the question mark, we

00:20:48.000 --> 00:20:52.000
did this, so here in the terminal window the cursor is

00:20:52.000 --> 00:20:56.000
separated from the question mark, otherwise it would be so close. So let's type

00:20:56.000 --> 00:21:00.000
whatever here, plus enter, now we get this message, Hi, Mosh. 

00:21:00.000 --> 00:21:04.000
Now here's a little exercise for you. I want you to extend this program

00:21:04.000 --> 00:21:08.000
and ask two questions. First all the person's name and then

00:21:08.000 --> 00:21:12.000
their favorite color. And then print a message like Mosh likes

00:21:12.000 --> 00:21:16.000
blue. So pause the video, do this exercise and then come back and continue watching. 

00:21:20.000 --> 00:21:24.000
Alright, so here's the first question right after that, 

00:21:24.000 --> 00:21:28.000
all the input functions one more time, this time we're going to ask a different question. 

00:21:28.000 --> 00:21:32.000
What is your favorite color? 

00:21:32.000 --> 00:21:36.000
Now, we get the new value and store it in the variable

00:21:36.000 --> 00:21:40.000
called color, or you could call it favorite underline. 

00:21:40.000 --> 00:21:44.000
color. Either works. And finally we're going to change

00:21:44.000 --> 00:21:48.000
what we pass to the print function, so first we print the name 

00:21:48.000 --> 00:21:52.000
then we concatenate this with a string, here we're going to

00:21:52.000 --> 00:21:56.000
type likes, we also put one space before and 

00:21:56.000 --> 00:22:00.000
after likes, and once again we concatenate this. 

00:22:00.000 --> 00:22:04.000
With the favorite color. So, favorite color, 

00:22:04.000 --> 00:22:08.000
now let's run this program, so what is your name

00:22:08.000 --> 00:22:12.000
Mosh enter, favorite color, blue, enter, 

00:22:12.000 --> 00:22:16.000
we get this message, Mosh likes blue. 

00:22:16.000 --> 00:22:20.000
Hey guys Mosh here, I just wanted to let you know that

00:22:20.000 --> 00:22:24.000
you really don't have to memorize anything in this course because I've put together a cheat sheet

00:22:24.000 --> 00:22:28.000
with summary notes. So you can quickly review the materials in this course. 

00:22:28.000 --> 00:22:32.000
The link is below this video. So I have done my best to create

00:22:32.000 --> 00:22:36.000
the best possible Python course on Youtube. And I really appreciate

00:22:36.000 --> 00:22:40.000
it if you support my hard work by liking this video and sharing it with

00:22:40.000 --> 00:22:44.000
others, so they can learn as well. And be sure to subscribe to my channel, for more 

00:22:44.000 --> 00:22:48.000
tutorials like this. Alright, now, let's move onto the next tutorial. 

00:22:52.000 --> 00:22:56.000
In this Python tutorial, we're going to write a program that will ask the year that we were born

00:22:56.000 --> 00:23:00.000
in, and then it will calculate our age and print it on the terminal. 

00:23:00.000 --> 00:23:04.000
So, let's start with our input function, input 

00:23:04.000 --> 00:23:08.000
let's print birth here, followed by a colon, 

00:23:08.000 --> 00:23:12.000
and a space. Now let's get the return value and store it in a variable, 

00:23:12.000 --> 00:23:16.000
called birth_year. 

00:23:16.000 --> 00:23:20.000
So as I told you before, we use an underscore to separate multiple words

00:23:20.000 --> 00:23:24.000
Next, we need to calculate the age, so we define another

00:23:24.000 --> 00:23:28.000
variable called age, and here we do some basic math, 

00:23:28.000 --> 00:23:32.000
currently we are in 2019, so let's write an expression

00:23:32.000 --> 00:23:36.000
like this. 2019 - birth

00:23:36.000 --> 00:23:40.000
year. Now finally let's print 

00:23:40.000 --> 00:23:44.000
age on the terminal. Let's run our program and see what happens. 

00:23:44.000 --> 00:23:48.000
So, my birth year is 1982, enter, 

00:23:48.000 --> 00:23:52.000
oops, we got an error, what is going on here? So 

00:23:52.000 --> 00:23:56.000
whenever you see this message, that means there is something wrong with your program. With the information

00:23:56.000 --> 00:24:00.000
here, we can find exactly where the error occurred. So, 

00:24:00.000 --> 00:24:04.000
next to the file you can see the file that generated this error, in this case

00:24:04.000 --> 00:24:08.000
that is app.py. So

00:24:08.000 --> 00:24:12.000
currently our program only has a single file, but real complex programs often

00:24:12.000 --> 00:24:16.000
have hundreds or even thousands of files. So in this file, 

00:24:16.000 --> 00:24:20.000
on line 2, this is where we got this error, and right

00:24:20.000 --> 00:24:24.000
below that we can see the piece of code that generated this error. 

00:24:24.000 --> 00:24:28.000
So that is where we're calculating the age, and right below

00:24:28.000 --> 00:24:32.000
that you can see the type of error. In this case, we have a type error, and here's the

00:24:32.000 --> 00:24:36.000
message. Unsupported operand types for

00:24:36.000 --> 00:24:40.000
subtraction. Int and str.

00:24:40.000 --> 00:24:44.000
So int is short for integer and that represents a whole number 

00:24:44.000 --> 00:24:48.000
and str is short for string, so here we're subtracting 

00:24:48.000 --> 00:24:52.000
a string from an integer, and Python doesn't know what to do with it. 

00:24:52.000 --> 00:24:56.000
Let me explain. So I'm going to close the terminal window. So after

00:24:56.000 --> 00:25:00.000
the first line we executed we have this birth year variable set 

00:25:00.000 --> 00:25:04.000
to a string, so whatever we type in the terminal is always

00:25:04.000 --> 00:25:08.000
treated as a string, even if you type the number, in other words, 

00:25:08.000 --> 00:25:12.000
when we run this program, this birth year variable will be set

00:25:12.000 --> 00:25:16.000
to a string, with four characters. 

00:25:16.000 --> 00:25:20.000
1982. This string is different from the actual number

00:25:20.000 --> 00:25:24.000
1982. One is an integer and the other is a string. 

00:25:24.000 --> 00:25:28.000
Right? So, back to line 2, where this

00:25:28.000 --> 00:25:32.000
error occurred. At run time, which means when we run our program

00:25:32.000 --> 00:25:36.000
this expression on the right side of the assignment operator

00:25:36.000 --> 00:25:40.000
is going to look like this. 2019 - 

00:25:40.000 --> 00:25:44.000
string 1982. Python doesn't know how to

00:25:44.000 --> 00:25:48.000
interpret or how to evaluate this expression. To fix this problem 

00:25:48.000 --> 00:25:52.000
we need to convert this 1982 into an integer

00:25:52.000 --> 00:25:56.000
and then we'll be able to subtract it from 2019 and that 

00:25:56.000 --> 00:26:00.000
is easy. So far you have learned about two built in functions 

00:26:00.000 --> 00:26:04.000
one is print the other is input. We have a few other functions

00:26:04.000 --> 00:26:08.000
for converting values into different types. So we have 

00:26:08.000 --> 00:26:12.000
int for converting a string into an integer, we also have

00:26:12.000 --> 00:26:16.000
float for converting a string into a float, or a number

00:26:16.000 --> 00:26:20.000
with a decimal point. And we also have bool for converting a string 

00:26:20.000 --> 00:26:24.000
into a  boolean value. So to fix this problem, 

00:26:24.000 --> 00:26:28.000
we need to go back on line 2, 

00:26:28.000 --> 00:26:32.000
and pass this birth year variable to the int function like this.

00:26:32.000 --> 00:26:36.000
int parenthesis, like this

00:26:36.000 --> 00:26:40.000
so we pass this string to the int function, int will convert it into an itneger

00:26:40.000 --> 00:26:44.000
and then Python interpreter will be able to evaluate this expression. 

00:26:44.000 --> 00:26:48.000
Now let's run this program one more time, so birth

00:26:48.000 --> 00:26:52.000
year is 1982 enter so I am

00:26:52.000 --> 00:26:56.000
37 years old. In Python we have a useful function

00:26:56.000 --> 00:27:00.000
for getting the type of variables, for example, let's print the type

00:27:00.000 --> 00:27:04.000
of birth year, so right after line 1, 

00:27:04.000 --> 00:27:08.000
let's print, now here we're going to call another built in function, 

00:27:08.000 --> 00:27:12.000
called type, and now let's pass birth 

00:27:12.000 --> 00:27:16.000
year, okay, now similarly after line 

00:27:16.000 --> 00:27:20.000
3, let's also print the type of age, so

00:27:20.000 --> 00:27:24.000
print type of age. 

00:27:24.000 --> 00:27:28.000
Okay? So let's run our program, so birth year one more

00:27:28.000 --> 00:27:32.000
time, 1982, okay, here's the result

00:27:32.000 --> 00:27:36.000
so the type of birth year as you can see is a class

00:27:36.000 --> 00:27:40.000
of str or strings, we look at classes in the future so

00:27:40.000 --> 00:27:44.000
for now don't worry about them, and also below them you cans ee the type of

00:27:44.000 --> 00:27:48.000
the age variable is int or integer. So

00:27:48.000 --> 00:27:52.000
here's what you need to take away. Whenever you use the input function, 

00:27:52.000 --> 00:27:56.000
you always get a string, so if you're expecting a numerical value

00:27:56.000 --> 00:28:00.000
you should always convert that string into an integer or

00:28:00.000 --> 00:28:04.000
a float. So here's a little exercise for you. I want you to write a program 

00:28:04.000 --> 00:28:08.000
ask the user their weight and then convert it to kilograms and print it

00:28:08.000 --> 00:28:12.000
on a terminal. So pause the video, do the exercise and when you're ready come back

00:28:12.000 --> 00:28:16.000
to watch it. 

00:28:16.000 --> 00:28:20.000
Alright so let's use our input function and ask

00:28:20.000 --> 00:28:24.000
for the weight in pounds

00:28:24.000 --> 00:28:28.000
here we get the weight in lbs or pounds

00:28:28.000 --> 00:28:32.000
now we need to convert this into kilograms, it's very easy so

00:28:32.000 --> 00:28:36.000
we defined another variable weight_kg 

00:28:36.000 --> 00:28:40.000
we set this to weight_lbs

00:28:40.000 --> 00:28:44.000
times 0.45. 

00:28:44.000 --> 00:28:48.000
And finally let's print weight underline

00:28:48.000 --> 00:28:52.000
kg. Let's run this Python program and see what happens. So

00:28:52.000 --> 00:28:56.000
my weight is 160, alright once again we got an error, 

00:28:56.000 --> 00:29:00.000
can't multiply sequence by non int of type

00:29:00.000 --> 00:29:04.000
float. So as I told you before, this input function returns

00:29:04.000 --> 00:29:08.000
a string, so we cannot multiply a string by a float. 

00:29:08.000 --> 00:29:12.000
Python doesn't know what to do with it. So in this case, we should convert this number

00:29:12.000 --> 00:29:16.000
by an integer or float and then multiply by 0.45. 

00:29:16.000 --> 00:29:20.000
So let's call the int function. 

00:29:20.000 --> 00:29:24.000
And pass weight underline lbs.

00:29:24.000 --> 00:29:28.000
And run our program one more time, 160

00:29:28.000 --> 00:29:32.000
okay, so I am 72 kg's. 

00:29:36.000 --> 00:29:40.000
In this tutorial, you're going to learn more about Python strings. 

00:29:40.000 --> 00:29:44.000
So I've defined this course variable and set it to Python for beginners

00:29:44.000 --> 00:29:48.000
now earlier I told you you could use both single and double quotes

00:29:48.000 --> 00:29:52.000
to define a string, but there are times you have to use a specific form,

00:29:52.000 --> 00:29:56.000
otherwise you're going to run into issues. Here's an example. Imagine you wanted to

00:29:56.000 --> 00:30:00.000
change this string into Pythons course for Beginners. 

00:30:00.000 --> 00:30:04.000
So we want to add an apostrophe, like this, 

00:30:04.000 --> 00:30:08.000
Course for Beginners. You can immediately say this is going

00:30:08.000 --> 00:30:12.000
crazy, because our string starts here and then terminates here, 

00:30:12.000 --> 00:30:16.000
all these characters that we have here after the second apostrophe

00:30:16.000 --> 00:30:20.000
Python interpreter doesn't know what they are. So to solve this problem

00:30:20.000 --> 00:30:24.000
we need to use double quotes to define our string so we can have 

00:30:24.000 --> 00:30:28.000
a single quote in the middle of the string. So let's change this

00:30:28.000 --> 00:30:32.000
to double quotes, now you can see it adds another double quote to close it, 

00:30:32.000 --> 00:30:36.000
you have to manually remove this, and also one more time

00:30:36.000 --> 00:30:40.000
at the beginning of the string, we need to add another double quote. Now

00:30:40.000 --> 00:30:44.000
you can see error is gone, so if you print course 

00:30:44.000 --> 00:30:48.000
we see Python course for beginners. 

00:30:48.000 --> 00:30:52.000
Beautiful. Now let's say we don't want this apostrophe here, so we have

00:30:52.000 --> 00:30:56.000
Python for Beginners, but we want to put Beginners in

00:30:56.000 --> 00:31:00.000
double quotes. Once again, if you add a double quote here Python interpreter gets

00:31:00.000 --> 00:31:04.000
confused because it assumes the second double quote indicates that

00:31:04.000 --> 00:31:08.000
end of the string, so it doesn't know what these characters are, so to solve this

00:31:08.000 --> 00:31:12.000
we need to change our double quotes to single quotes 

00:31:12.000 --> 00:31:16.000
like this. And then we can add double quotes in the middle

00:31:16.000 --> 00:31:20.000
of the string. Now let's run this program, there you go. 

00:31:20.000 --> 00:31:24.000
So we get Python for Beginners. So these are the cases

00:31:24.000 --> 00:31:28.000
for using single or double quotes. Now in all the examples

00:31:28.000 --> 00:31:32.000
I've shown you so far we only deal with short strings, but what if you wanted to define 

00:31:32.000 --> 00:31:36.000
a string that is multiple lengths? For example, what if you wanted to define a string 

00:31:36.000 --> 00:31:40.000
for the message that we send in an email. In that case we need to use 

00:31:40.000 --> 00:31:44.000
triple quotes. So. We delete this. 

00:31:44.000 --> 00:31:48.000
Now we add three quotes, so 1, 2, 3, there you go, 

00:31:48.000 --> 00:31:52.000
So, we have three quotes to start our string and three 

00:31:52.000 --> 00:31:56.000
to terminate it. Again these quotes can be single or double quotes. 

00:31:56.000 --> 00:32:00.000
Okay? Now, with this we can define a string that spans 

00:32:00.000 --> 00:32:04.000
multiple lines. For example, we can say Hi Jon 

00:32:04.000 --> 00:32:08.000
here is our first email to you. Thank you, 

00:32:08.000 --> 00:32:12.000
The Support Team. Like that.

00:32:12.000 --> 00:32:16.000
Now, let's run this program and here's the

00:32:16.000 --> 00:32:20.000
result. So, we get this beautiful multi line

00:32:20.000 --> 00:32:24.000
string. Now let's change this back to something simple 

00:32:24.000 --> 00:32:28.000
so, we can look at other characteristics of strings and Python. 

00:32:28.000 --> 00:32:32.000
So I'm going to use single quotes and set the course name to Python

00:32:32.000 --> 00:32:36.000
for Beginners. Now here we're going to use square 

00:32:36.000 --> 00:32:40.000
brackets to get a character and a given index in this string. 

00:32:40.000 --> 00:32:44.000
Let me show you. So to get the first character we use square brackets 

00:32:44.000 --> 00:32:48.000
and type 0. So the index of the first character 

00:32:48.000 --> 00:32:52.000
in the string is 0. In other words, this is how Python

00:32:52.000 --> 00:32:56.000
strings are indexed. 0, 1, 2, 3, 4, etc. 

00:32:56.000 --> 00:33:00.000
So the index of the first character is 0, the second character is

00:33:00.000 --> 00:33:04.000
1, and so on. So let me delete this and run this program

00:33:04.000 --> 00:33:08.000
we get p. We can also use a negative 

00:33:08.000 --> 00:33:12.000
index here. And this is one of the features that we don't have in other programming languages 

00:33:12.000 --> 00:33:16.000
as far as I know. So we have negative index we can get the characters

00:33:16.000 --> 00:33:20.000
started from the end. So if I pass negative 1 here, 

00:33:20.000 --> 00:33:24.000
Assuming that 0 is the index of the first character 

00:33:24.000 --> 00:33:28.000
negative 1 is the index of the last character. So when we run 

00:33:28.000 --> 00:33:32.000
this program we should see s. Let's run it, there you go,

00:33:32.000 --> 00:33:36.000
we get s, if we pass negative 2, this will return

00:33:36.000 --> 00:33:40.000
the second character from the end. Let's run it one more time, 

00:33:40.000 --> 00:33:44.000
now we get R because that is the second character from the end. 

00:33:44.000 --> 00:33:48.000
Okay? So place close attention to this square brackets syntax 

00:33:48.000 --> 00:33:52.000
because quite often it's the topic for online Python tests 

00:33:52.000 --> 00:33:56.000
or university exams, so if you're preparing for a python test, 

00:33:56.000 --> 00:34:00.000
make sure to watch this tutorial one more time and understand exactly how

00:34:00.000 --> 00:34:04.000
this square brackets syntax works, we can also use a similar 

00:34:04.000 --> 00:34:08.000
syntax to extract a few characters instead of 1 character. 

00:34:08.000 --> 00:34:12.000
For example, if we type 0, 

00:34:12.000 --> 00:34:16.000
colon 3, Python interpreter will return all the characters

00:34:16.000 --> 00:34:20.000
starting with this index all the way to this

00:34:20.000 --> 00:34:24.000
second index, but it does not return the character at this index. 

00:34:24.000 --> 00:34:28.000
In other words, back to these indexes 

00:34:28.000 --> 00:34:32.000
so you have 0, 1, 2, 3, and so on. When you run this program. 

00:34:32.000 --> 00:34:36.000
Python interpreter will return the characters starting from the

00:34:36.000 --> 00:34:40.000
index 0 all the way to index 3, 

00:34:40.000 --> 00:34:44.000
but excludes the character and index 3, 

00:34:44.000 --> 00:34:48.000
so when we run this Python program we're going to see pint (?). Let me show you, so we're going to

00:34:48.000 --> 00:34:52.000
delete this line, run this program, there you go. 

00:34:52.000 --> 00:34:56.000
We get pint. Now here we also have default values for

00:34:56.000 --> 00:35:00.000
the start and end index. So if we don't supply 

00:35:00.000 --> 00:35:04.000
the end index, Python will return all the characters to the end of the string. 

00:35:04.000 --> 00:35:08.000
Let's take a look. So run this program, there you go,

00:35:08.000 --> 00:35:12.000
Python for Beginners. But if you change the start index to 1, 

00:35:12.000 --> 00:35:16.000
this will exclude the first character so when we

00:35:16.000 --> 00:35:20.000
run this program, we see ython so p is removed. 

00:35:20.000 --> 00:35:24.000
Okay? Now similarly we have a default value for the

00:35:24.000 --> 00:35:28.000
start index, so if we don't supply the start index 

00:35:28.000 --> 00:35:32.000
but add an end index like 5. Python interpreter will assume 

00:35:32.000 --> 00:35:36.000
0 as the start index, so, let's run

00:35:36.000 --> 00:35:40.000
this program, there you go, we get pytho. 

00:35:40.000 --> 00:35:44.000
Now what if we leave both the start and end

00:35:44.000 --> 00:35:48.000
index? Well, I told you? Now in this case 0 will be assumed

00:35:48.000 --> 00:35:52.000
as the start index, and the length of the string will assume

00:35:52.000 --> 00:35:56.000
as the end index. So with this syntax, you can basically copy

00:35:56.000 --> 00:36:00.000
or clone a string. In other words, if I define

00:36:00.000 --> 00:36:04.000
another variable here, let's call it another and set it to course 

00:36:04.000 --> 00:36:08.000
square brackets with just a colon, now this expression will

00:36:08.000 --> 00:36:12.000
return all the characters in the course variable so

00:36:12.000 --> 00:36:16.000
variable will be copy of our first variable. Let's take a look, so, 

00:36:16.000 --> 00:36:20.000
let's print another, and load our

00:36:20.000 --> 00:36:24.000
program there you go, we get Python for beginners. So once again

00:36:24.000 --> 00:36:28.000
the square bracket syntax is pretty important if you're preparing for online

00:36:28.000 --> 00:36:32.000
python tests, or college exams, make sure to watch this tutorial again. 

00:36:32.000 --> 00:36:36.000
Now here's a little exercise for you. I'm going to delete all this code 

00:36:36.000 --> 00:36:40.000
define a variable, called name, and set it to Jennifer. 

00:36:40.000 --> 00:36:44.000
Now when we print name 

00:36:44.000 --> 00:36:48.000
of 1: negative 1

00:36:48.000 --> 00:36:52.000
what do you think we're going to see on the terminal? I want you to use your knowledge 

00:36:52.000 --> 00:36:56.000
to tell what we're going to see on the terminal, we're now running this program. So

00:36:56.000 --> 00:37:00.000
pause the video, think about it for a few seconds, then come back and continue watching. 

00:37:04.000 --> 00:37:08.000
So this expression will return the characters starting from 

00:37:08.000 --> 00:37:12.000
index 1 which is the second character

00:37:12.000 --> 00:37:16.000
all the way to the first character from the end, but excluding

00:37:16.000 --> 00:37:20.000
the character at this index. In this case, the first character from the

00:37:20.000 --> 00:37:24.000
in is r, so r will be excluded, in other words we're going to see

00:37:24.000 --> 00:37:28.000
all the characters starting from e all the way 

00:37:28.000 --> 00:37:32.000
to the second e. Let's take a look. So I'm going to run this program 

00:37:32.000 --> 00:37:36.000
there you go. This is what we get, 

00:37:36.000 --> 00:37:40.000
I hope you guessed it right. 

00:37:40.000 --> 00:37:44.000
In this tutorial, we're going to look at 

00:37:44.000 --> 00:37:48.000
formatted strings in Python programming language. Formatted strings are

00:37:48.000 --> 00:37:52.000
particularly useful in situations where you dynamically generate some

00:37:52.000 --> 00:37:56.000
text with your variables. Let me show you. Let's say we have two variables 

00:37:56.000 --> 00:38:00.000
first name and last name. So first we set this to

00:38:00.000 --> 00:38:04.000
John, and last we set this to Smith. Now it's better

00:38:04.000 --> 00:38:08.000
to call these variables first name and last name, because they're more

00:38:08.000 --> 00:38:12.000
descriptive. But here I'm using shorter names because I want you to see the entire code on display 

00:38:12.000 --> 00:38:16.000
screen. So let's say with these two variables, we want to generate

00:38:16.000 --> 00:38:20.000
some text like this. Jon, in square brackets 

00:38:20.000 --> 00:38:24.000
Smith is a coder. Let's say we want to print this on

00:38:24.000 --> 00:38:28.000
the terminal. How do we do this? Well, we define another variable 

00:38:28.000 --> 00:38:32.000
like message, now here we add the first name, 

00:38:32.000 --> 00:38:36.000
now we need to concatenate this, with a string that contains a space 

00:38:36.000 --> 00:38:40.000
and a square bracket next we need to add a last name, 

00:38:40.000 --> 00:38:44.000
then we need to add a string that contains

00:38:44.000 --> 00:38:48.000
the closing square brackets followed by is a coder

00:38:48.000 --> 00:38:52.000
okay? So, then, 

00:38:52.000 --> 00:38:56.000
if you print message and run this program 

00:38:56.000 --> 00:39:00.000
to see John Smith is a coder, right? Now, 

00:39:00.000 --> 00:39:04.000
while this approach perfectly works, it's not ideal 

00:39:04.000 --> 00:39:08.000
because as our text gets more complicated it becomes harder to

00:39:08.000 --> 00:39:12.000
visualize the output. So someone else reading this code, they have to 

00:39:12.000 --> 00:39:16.000
visualize all the string concatenations in their head. This is where we use

00:39:16.000 --> 00:39:20.000
formatted strings, they make it easier for us to visualize the output. So, 

00:39:20.000 --> 00:39:24.000
I'm going to define another variable, let's say

00:39:24.000 --> 00:39:28.000
msg short for message, and set this to a formatted string. A formatted

00:39:28.000 --> 00:39:32.000
string is one that is prefixed with an f. So f, 

00:39:32.000 --> 00:39:36.000
quotes. Now in between the quotes, first we want to add

00:39:36.000 --> 00:39:40.000
the value of the first name variable, so, 

00:39:40.000 --> 00:39:44.000
we add curly braces and here we type first.

00:39:44.000 --> 00:39:48.000
Next we add a space, we add our square brackets, in between the square 

00:39:48.000 --> 00:39:52.000
brackets, we want to display the last name so once again we add curly

00:39:52.000 --> 00:39:56.000
braces, and type last, and finally here we type 

00:39:56.000 --> 00:40:00.000
is a coder. So this is what we call the formatted

00:40:00.000 --> 00:40:04.000
string. With these curly braces, we're defining place holders

00:40:04.000 --> 00:40:08.000
or holes in our string, and when we run our program these holes 

00:40:08.000 --> 00:40:12.000
will be filled with the value of our variables. So here we have two place holders

00:40:12.000 --> 00:40:16.000
or two holes in our string. One is for the value of our first name 

00:40:16.000 --> 00:40:20.000
variable and the other is for the value of the last name variable. 

00:40:20.000 --> 00:40:24.000
But compare this formatted string with string 

00:40:24.000 --> 00:40:28.000
concatenation. With this formatted string we can easily visualize 

00:40:28.000 --> 00:40:32.000
what the output looks like, right? Now let's print this other

00:40:32.000 --> 00:40:36.000
terminal to make sure we get the same exact output. So, let's print message

00:40:36.000 --> 00:40:40.000
there you go. So Jon

00:40:40.000 --> 00:40:44.000
Smith is a coder. So to define formatted strings, 

00:40:44.000 --> 00:40:48.000
prefix your strings with an F and then use curly braces 

00:40:48.000 --> 00:40:52.000
to dynamically insert values into your strings. 

00:40:56.000 --> 00:41:00.000
In this Python tutorial, I'm going to show you some really cool things you can do with Python

00:41:00.000 --> 00:41:04.000
strings. So let's start by defining a variable, 

00:41:04.000 --> 00:41:08.000
course and we set that to Python for

00:41:08.000 --> 00:41:12.000
beginners. Now to calculate the number

00:41:12.000 --> 00:41:16.000
of characters in this string, you can use a built in function called len.

00:41:16.000 --> 00:41:20.000
So len we give it this course variable, and then, 

00:41:20.000 --> 00:41:24.000
we can print the result. Let's run this program, 

00:41:24.000 --> 00:41:28.000
so as you can see we have 20 characters in this string, this is 

00:41:28.000 --> 00:41:32.000
particularly useful when you receive input from the user. For example you have

00:41:32.000 --> 00:41:36.000
noticed that when you fill out a form online, each input field 

00:41:36.000 --> 00:41:40.000
often has a limit. For example, you might have 50 characters for your name, 

00:41:40.000 --> 00:41:44.000
so using this len function we can enforce a limit on the number of characters 

00:41:44.000 --> 00:41:48.000
in an input field. If the user types in more characters than we allow, 

00:41:48.000 --> 00:41:52.000
we can display an error, now, this, 

00:41:52.000 --> 00:41:56.000
len function is another function built into Python, it's 

00:41:56.000 --> 00:42:00.000
a general purpose function, so it's not limited to counting the number of characters in a 

00:42:00.000 --> 00:42:04.000
string, in the future when we look at lists, I want to show you that we can use this

00:42:04.000 --> 00:42:08.000
function to count the number of items in a list. So it's a general purpose

00:42:08.000 --> 00:42:12.000
function. Now we also have functions specifically for strings 

00:42:12.000 --> 00:42:16.000
for example we have functions for converting all these characters to upper case

00:42:16.000 --> 00:42:20.000
or lower case. To access these functions we use the dot operator. 

00:42:20.000 --> 00:42:24.000
let me show you. So first we type course, 

00:42:24.000 --> 00:42:28.000
then dot look these are all the functions 

00:42:28.000 --> 00:42:32.000
that are specific to strings. Now in more accurate terms, 

00:42:32.000 --> 00:42:36.000
you refer to these function as methods, this is a term 

00:42:36.000 --> 00:42:40.000
in object oriented programming that we want to look at in the future, but for now, what I want you to take away,

00:42:40.000 --> 00:42:44.000
is that when a function belongs to something else, or is specific 

00:42:44.000 --> 00:42:48.000
to some kind of object, we refer to that function as a method. 

00:42:48.000 --> 00:42:52.000
For example, here we have this function, upper, for converting the string 

00:42:52.000 --> 00:42:56.000
into upper case, now more accurately because this function

00:42:56.000 --> 00:43:00.000
is specific to a string, we refer to this as a method. In contrast

00:43:00.000 --> 00:43:04.000
len and print are general purpose functions, they don't belong 

00:43:04.000 --> 00:43:08.000
to strings or numbers or other kinds of objects. 

00:43:08.000 --> 00:43:12.000
So this is the difference between functions and methods. Now let's take  look at this

00:43:12.000 --> 00:43:16.000
upper method. So, let's print the results

00:43:16.000 --> 00:43:20.000
and we run our program, there you go, 

00:43:20.000 --> 00:43:24.000
you get all these characters displayed in uppercase. Now note this method 

00:43:24.000 --> 00:43:28.000
does not change or modify our original string, in fact 

00:43:28.000 --> 00:43:32.000
it creates a new string and returns it. So, 

00:43:32.000 --> 00:43:36.000
if we print our course variable right after we

00:43:36.000 --> 00:43:40.000
call the upper method, we can see that our course variable still 

00:43:40.000 --> 00:43:44.000
has it's original form, so let's run this program one more time, there you 

00:43:44.000 --> 00:43:48.000
go. Look, here is our original course variable, it's not modified. 

00:43:48.000 --> 00:43:52.000
Now similar to the upper method we have another method

00:43:52.000 --> 00:43:56.000
for converting a string into lower case. So let me show you. 

00:43:56.000 --> 00:44:00.000
Print, course.lower. 

00:44:00.000 --> 00:44:04.000
Now, let's run the program, so on the second line you can see, 

00:44:04.000 --> 00:44:08.000
all characters are in lower case. Now there are times

00:44:08.000 --> 00:44:12.000
that you want to find a character or a sequence of characters in a string. 

00:44:12.000 --> 00:44:16.000
In those situations you can use the find method. So let me delete

00:44:16.000 --> 00:44:20.000
these few lines. Call course.

00:44:20.000 --> 00:44:24.000
find here we pass a character, let's say 

00:44:24.000 --> 00:44:28.000
p, and this will return the index of the first occurrence 

00:44:28.000 --> 00:44:32.000
of that character, let me show you. So let's print the result

00:44:32.000 --> 00:44:36.000
we get 0, because the 

00:44:36.000 --> 00:44:40.000
index of the first capital p in the string is 0. 

00:44:40.000 --> 00:44:44.000
As another example, if we pass a lower case o here, 

00:44:44.000 --> 00:44:48.000
let's see what we get, we get 4 because 

00:44:48.000 --> 00:44:52.000
the index of this o here is 4. Now note that the

00:44:52.000 --> 00:44:56.000
find method is case sensitive, so it's sensitive to 

00:44:56.000 --> 00:45:00.000
lower case and and upper case characters. As an example if you pass an upper case 

00:45:00.000 --> 00:45:04.000
here and run this program, we get negative 1 because

00:45:04.000 --> 00:45:08.000
we don't have an upper case o anywhere in this string, okay?

00:45:08.000 --> 00:45:12.000
We can also pass a sequence of characters, for example, we can pass

00:45:12.000 --> 00:45:16.000
beginners with a capital B

00:45:16.000 --> 00:45:20.000
let's run this program, we get 11 because 

00:45:20.000 --> 00:45:24.000
beginners starts with index 11, now we

00:45:24.000 --> 00:45:28.000
also have method for replacing a character or a sequence of characters

00:45:28.000 --> 00:45:32.000
and that is called replace. So let's change find 

00:45:32.000 --> 00:45:36.000
to replace let's say we want to replace beginners with

00:45:36.000 --> 00:45:40.000
absolute beginners, so we add a comma to pass a second value

00:45:40.000 --> 00:45:44.000
to this function, or more accurately this method. We add a string, 

00:45:44.000 --> 00:45:48.000
here I'm going to pass absolute beginners. 

00:45:48.000 --> 00:45:52.000
Okay, now let's run this program,

00:45:52.000 --> 00:45:56.000
so, we get python for absolute beginners. 

00:45:56.000 --> 00:46:00.000
Again, this method like the find method is case sensitive so 

00:46:00.000 --> 00:46:04.000
if you pass beginners all in lowercase, this method is

00:46:04.000 --> 00:46:08.000
not going to find this exact word in our string, so it's not going to

00:46:08.000 --> 00:46:12.000
place it with absolute beginners. Let's take a look. So I'm going to run the program

00:46:12.000 --> 00:46:16.000
One more time, look, we still get python for beginners. 

00:46:16.000 --> 00:46:20.000
We can also replace a single character, for example we can replace

00:46:20.000 --> 00:46:24.000
capital p with let's say capital 

00:46:24.000 --> 00:46:28.000
j. Now when we run this program we get

00:46:28.000 --> 00:46:32.000
jython for beginners. So these are the find and replace methods

00:46:32.000 --> 00:46:36.000
and one last things I want to show you in this tutorial. There are

00:46:36.000 --> 00:46:40.000
times that you want to check the existence of a character or sequence of characters in your 

00:46:40.000 --> 00:46:44.000
string. In those situations you use the in operator, 

00:46:44.000 --> 00:46:48.000
so let's say you want to know if this string contains the word python. 

00:46:48.000 --> 00:46:52.000
We can write an expression like this. String

00:46:52.000 --> 00:46:56.000
python space in space course. 

00:46:56.000 --> 00:47:00.000
So we're checking to see if python is in

00:47:00.000 --> 00:47:04.000
course variable. And this is an expression that produces a boolean

00:47:04.000 --> 00:47:08.000
value, and I get true or false, so we refer to this expression

00:47:08.000 --> 00:47:12.000
as a boolean expression, now if we print this on the terminal, 

00:47:12.000 --> 00:47:16.000
we should get true, and by the way 

00:47:16.000 --> 00:47:20.000
I'm going to delete the second line, we don't need it anymore, so run the program 

00:47:20.000 --> 00:47:24.000
we get true, but if I change this capitol p to a lower case

00:47:24.000 --> 00:47:28.000
p and run the program we get false because we don't have

00:47:28.000 --> 00:47:32.000
is exact sequence of characters in our strings. 

00:47:32.000 --> 00:47:36.000
Now note that the difference between the in operator and the find method

00:47:36.000 --> 00:47:40.000
is that our find method returns the index of 

00:47:40.000 --> 00:47:44.000
character or sequence of characters but the in operator 

00:47:44.000 --> 00:47:48.000
produces a boolean value. Do we have this or not? 

00:47:48.000 --> 00:47:52.000
So that's the difference. Now let's recap all the cool things you learned

00:47:52.000 --> 00:47:56.000
to do with strings in this tutorial. We can use the len function

00:47:56.000 --> 00:48:00.000
to count the number of characters in a string, this is the general

00:48:00.000 --> 00:48:04.000
purpose function built into python, we also have specific functions 

00:48:04.000 --> 00:48:08.000
for strings which we refer to as methods, these include 

00:48:08.000 --> 00:48:12.000
upper for converting a string into uppercase

00:48:12.000 --> 00:48:16.000
you also have lower and title methods, 

00:48:16.000 --> 00:48:20.000
you learn about the find method which returns the index 

00:48:20.000 --> 00:48:24.000
of a character or sequence of characters, we have 

00:48:24.000 --> 00:48:28.000
the replace method for replacing characters and words in a string and finally 

00:48:28.000 --> 00:48:32.000
you learned about the in operator. So some characters 

00:48:32.000 --> 00:48:36.000
in a string. 

00:48:40.000 --> 00:48:44.000
So, you have learned that in Python programming language you have 2 

00:48:44.000 --> 00:48:48.000
types of numbers, integers which are whole numbers like 10, they don't have

00:48:48.000 --> 00:48:52.000
a decimal point, and floating point numbers or floats.

00:48:52.000 --> 00:48:56.000
Which are numbers with a decimal point. Now in this tutorial you're going to look

00:48:56.000 --> 00:49:00.000
at the arithmetic operations supported in python language these are the

00:49:00.000 --> 00:49:04.000
same arithmetic operations that we have in math, we can add numbers, 

00:49:04.000 --> 00:49:08.000
multiply them and so on. So let's look at a few examples, 

00:49:08.000 --> 00:49:12.000
we can print, 10 plus 3, so 

00:49:12.000 --> 00:49:16.000
this is the addition operator, we also have subtraction, we 

00:49:16.000 --> 00:49:20.000
have multiplication, we have two kinds of division, 

00:49:20.000 --> 00:49:24.000
here's one with a forward slash, let's run this program and see what we get.

00:49:24.000 --> 00:49:28.000
we get a floating point number. But we also have

00:49:28.000 --> 00:49:32.000
another division operator for getting an integer. So 

00:49:32.000 --> 00:49:36.000
if we add another slash here and run this program 

00:49:36.000 --> 00:49:40.000
we get an integer. We have 

00:49:40.000 --> 00:49:44.000
another operator called modulis (?) which is a percent sign.

00:49:44.000 --> 00:49:48.000
And this returns the remainder of the division. So when we run this program 

00:49:48.000 --> 00:49:52.000
we should get 1, there you go. And

00:49:52.000 --> 00:49:56.000
one last operator we have here is exponent which is the power. 

00:49:56.000 --> 00:50:00.000
So, that is indicated with 2 asterisks and this will return 

00:50:00.000 --> 00:50:04.000
10 to the power of 3. So let's run this program 

00:50:04.000 --> 00:50:08.000
we get 1000 so these are the arithmetic operators 

00:50:08.000 --> 00:50:12.000
in python programming language. Now for all these operators that you learned 

00:50:12.000 --> 00:50:16.000
we have an augmented assignment operator. That is

00:50:16.000 --> 00:50:20.000
very useful, let me show you. So let's say we have a variable 

00:50:20.000 --> 00:50:24.000
called x we set it to 10, now we want to increment this by

00:50:24.000 --> 00:50:28.000
3, we'll have to write code like this. X we set this to

00:50:28.000 --> 00:50:32.000
x plus 3. So Python interpreter will add 

00:50:32.000 --> 00:50:36.000
10 to 3, the result is 13, and then it gets stored 

00:50:36.000 --> 00:50:40.000
into x again. So when we print x we should see 

00:50:40.000 --> 00:50:44.000
13, there you go. So this is how you can increment 

00:50:44.000 --> 00:50:48.000
a number, right? Now augmented assignment operator is

00:50:48.000 --> 00:50:52.000
a way to write the same code but in a shorter form. This

00:50:52.000 --> 00:50:56.000
is how it works. We type x plus 

00:50:56.000 --> 00:51:00.000
equals 3. What we have on line 3 is exactly 

00:51:00.000 --> 00:51:04.000
like what we have on line 2. So this is what we call

00:51:04.000 --> 00:51:08.000
the augmented assignment operator we have augmented or

00:51:08.000 --> 00:51:12.000
enhanced the assignment operator. Now in this particular 

00:51:12.000 --> 00:51:16.000
case we are incremented a number using the augmented assignment operator,

00:51:16.000 --> 00:51:20.000
but we can also subtract or multiply a number by a given value

00:51:20.000 --> 00:51:24.000
for example, let's delete what we have on line 2, 

00:51:24.000 --> 00:51:28.000
we can type subtract equals 3. So here we 

00:51:28.000 --> 00:51:32.000
subtracted 3 from x. When we run this program we should see 7, 

00:51:32.000 --> 00:51:36.000
there you go. 

00:51:40.000 --> 00:51:44.000
Now let me ask you a question, I'm going to clear all this code here to

00:51:44.000 --> 00:51:48.000
define x and set it to 10 plus 3

00:51:48.000 --> 00:51:52.000
times 2. What do you think is the result of this expression? 

00:51:52.000 --> 00:51:56.000
this is a very basic math question that unfortunately a lot of people fail to answer. 

00:51:56.000 --> 00:52:00.000
The answer is 16. Because in math we have this

00:52:00.000 --> 00:52:04.000
concept called operator precedence which means the order of

00:52:04.000 --> 00:52:08.000
operations. So the multiplication operator has 

00:52:08.000 --> 00:52:12.000
a higher precendence which means it's applied first which means 3 x 

00:52:12.000 --> 00:52:16.000
2 is executed first, the result is 6 and then 

00:52:16.000 --> 00:52:20.000
its added to 10, that's why x showed up as 16 after

00:52:20.000 --> 00:52:24.000
we run this code, let's verify that. So, print x 

00:52:24.000 --> 00:52:28.000
run the program, x is 16. So this is what we call

00:52:28.000 --> 00:52:32.000
operator precedence, it's just a basic math concept. 

00:52:32.000 --> 00:52:36.000
It's not about python programming language. So all the other programming languages 

00:52:36.000 --> 00:52:40.000
behave the same way, so here's the order, first we have 

00:52:40.000 --> 00:52:44.000
the exponentiation which is the power, like 2 to the power of 3, 

00:52:44.000 --> 00:52:48.000
then we have multiplication or division 

00:52:48.000 --> 00:52:52.000
and finally we have addition or subtraction.

00:52:52.000 --> 00:52:56.000
This is the order of operations. Let me show you another example. 

00:52:56.000 --> 00:53:00.000
Here I'm going to add the exponentiation operator, so, 

00:53:00.000 --> 00:53:04.000
2 to the power of 2. Once again, what do you

00:53:04.000 --> 00:53:08.000
think is the result of this expression? Pause the video and think about it for a few seconds. 

00:53:08.000 --> 00:53:12.000
The answer is 22. 

00:53:12.000 --> 00:53:16.000
Because the exponentiation operator takes precedence, so first 

00:53:16.000 --> 00:53:20.000
2 to the power of 2 is executed, the result is 4, 

00:53:20.000 --> 00:53:24.000
then 4 is multiplied by 3, that is 12, 

00:53:24.000 --> 00:53:28.000
and finally 12 is added to 10. So x should be 22. 

00:53:28.000 --> 00:53:32.000
So let's run this program and verify this. So I'm going to

00:53:32.000 --> 00:53:36.000
delete these lines here. Run the program, there you go. X 

00:53:36.000 --> 00:53:40.000
is 22. Now let me bring back these rules here. 

00:53:40.000 --> 00:53:44.000
We can also use parenthesis to change the order of operations 

00:53:44.000 --> 00:53:48.000
so if we have parenthesis we always 

00:53:48.000 --> 00:53:52.000
takes priority. In this case we can add parenthesis 

00:53:52.000 --> 00:53:56.000
around 10 + 3, so this piece of 3 will be 

00:53:56.000 --> 00:54:00.000
executed first, the result is 13, then the exponentiation 

00:54:00.000 --> 00:54:04.000
operator will be executed, so 2 to the power of 2 is 4, 

00:54:04.000 --> 00:54:08.000
and finally 4 is multiplied by 13. 

00:54:08.000 --> 00:54:12.000
Now here is a little exercise for you. I'm going to set x to 

00:54:12.000 --> 00:54:16.000
parenthesis 2 + 3 x 10 minus

00:54:16.000 --> 00:54:20.000
3. What is the result of this? Pause the video and think about it for a few seconds. 

00:54:24.000 --> 00:54:28.000
So you learned that parenthesis always 

00:54:28.000 --> 00:54:32.000
overrides the order, so this piece of code is executed first. The result

00:54:32.000 --> 00:54:36.000
of these 5. Then, between the multiplication and 

00:54:36.000 --> 00:54:40.000
subtraction, you know that multiplication takes precedence. 

00:54:40.000 --> 00:54:44.000
So next, 5 will be multiplied by 10, the result is 

00:54:44.000 --> 00:54:48.000
50 and finally we have subtraction. So 50 minus 

00:54:48.000 --> 00:54:52.000
3 will be 47. Let's verify this, print 

00:54:52.000 --> 00:54:56.000
x, run the program there you go, I hope you guessed it right. 

00:54:56.000 --> 00:55:00.000
So this is all bout operator precedence, it's a very important topic 

00:55:00.000 --> 00:55:04.000
and I see it quite often in Python tests. So if you're preparing for a Python test

00:55:04.000 --> 00:55:08.000
make sure to watch his tutorial one more time. 

00:55:12.000 --> 00:55:16.000
In this tutorial, we're going to look at a few useful functions for working with numbers 

00:55:16.000 --> 00:55:20.000
let's start by defining a variable like x and set it to 2 

00:55:20.000 --> 00:55:24.000
.9. Now to round this number we can use the built in

00:55:24.000 --> 00:55:28.000
round function, so we call the round function, give it x, 

00:55:28.000 --> 00:55:32.000
and then print the result. Let's run this program 

00:55:32.000 --> 00:55:36.000
so, we get 3, we have another useful built in function called 

00:55:36.000 --> 00:55:40.000
abs which is short for absolute, and this is the absolute function 

00:55:40.000 --> 00:55:44.000
we have in math, we give it a value and it always returns 

00:55:44.000 --> 00:55:48.000
the positive representation of this value, even if the value is negative.

00:55:48.000 --> 00:55:52.000
Here's an example. Let's call the abs function 

00:55:52.000 --> 00:55:56.000
and give it negative 2.9 When we run this program 

00:55:56.000 --> 00:56:00.000
we're gong to see 2.9 on the terminal. So let's go ahead 

00:56:00.000 --> 00:56:04.000
there you go. So absolute always returns a positive number. 

00:56:04.000 --> 00:56:08.000
But technically in Python we have a handful of built in functions for performing 

00:56:08.000 --> 00:56:12.000
mathematical operations, if you want to write a program that involves complex 

00:56:12.000 --> 00:56:16.000
mathematical calculations, you need to import the math module.

00:56:16.000 --> 00:56:20.000
A module in Python is a separate file with some reusable 

00:56:20.000 --> 00:56:24.000
code. We use these modules to organize our code into different 

00:56:24.000 --> 00:56:28.000
files. As a metaphor think of a super market. When you go to a super market 

00:56:28.000 --> 00:56:32.000
you see different sections for fruits and vegetables, cleaning products, 

00:56:32.000 --> 00:56:36.000
junk food and so on. Each section in the super market is like a module 

00:56:36.000 --> 00:56:40.000
in Python. So in Python we have this math module which contains a bunch

00:56:40.000 --> 00:56:44.000
of rustable functions for performing mathematical calculations. 

00:56:44.000 --> 00:56:48.000
So, let me show you how to use this module. On the top 

00:56:48.000 --> 00:56:52.000
we type import, math, all in  lowercase 

00:56:52.000 --> 00:56:56.000
with this we can import the math module. now math is

00:56:56.000 --> 00:57:00.000
an object like a string, so we can access it's functions or more accurately 

00:57:00.000 --> 00:57:04.000
it's methods using the dot operator. So if you type 

00:57:04.000 --> 00:57:08.000
math. look these are all the mathematical 

00:57:08.000 --> 00:57:12.000
functions available in this module. For example you can call the

00:57:12.000 --> 00:57:16.000
seal method to get the sealing of a number. So if you pass 2.9 here

00:57:16.000 --> 00:57:20.000
and then print the result we should see 3. 

00:57:20.000 --> 00:57:24.000
Let me delete all this other code here. Alright, let's run this program 

00:57:24.000 --> 00:57:28.000
there you go. So we get 3. Another useful method is the

00:57:28.000 --> 00:57:32.000
floor method, so let's give that a try, floor of 2.

00:57:32.000 --> 00:57:36.000
9. What do you think we're going to get? We get 

00:57:36.000 --> 00:57:40.000
2. Now there are so many functions built in this module and we don't really have time

00:57:40.000 --> 00:57:44.000
to go through all of them. But let me show you how we can learn about them on your own. 

00:57:44.000 --> 00:57:48.000
Open up your browser and search for Python 3

00:57:48.000 --> 00:57:52.000
math module. Make sure to add the version python 3. 

00:57:52.000 --> 00:57:56.000
Because the math module in python 2 is slightly different from the math module in 

00:57:56.000 --> 00:58:00.000
python 3. So python 3 math module, 

00:58:00.000 --> 00:58:04.000
now here you can see the documentation of this kind of module 

00:58:04.000 --> 00:58:08.000
let's go let's have a look, if you scroll down, 

00:58:08.000 --> 00:58:12.000
we can see the list of all the functions and their explanation. 

00:58:12.000 --> 00:58:16.000
So as an exercise I encourage you to have a quick look at this

00:58:16.000 --> 00:58:20.000
documentation. See what functions are there for you in case you need them. 

00:58:24.000 --> 00:58:28.000
In this tutorial, I'm going to talk to you about if statements in Python 

00:58:28.000 --> 00:58:32.000
if statements are extremely important in programming and they

00:58:32.000 --> 00:58:36.000
allow us to build programs that can make decisions based on some condition. 

00:58:36.000 --> 00:58:40.000
So if some conditions are true we're going to do certain things, otherwise we're going to do other

00:58:40.000 --> 00:58:44.000
things. Here's an example. Over here I've got this text file with

00:58:44.000 --> 00:58:48.000
a bunch of rules for our program. If it's a hot day, perhaps we want to

00:58:48.000 --> 00:58:52.000
tell the user it's a hot day, so make sure to drink plenty of water. 

00:58:52.000 --> 00:58:56.000
Otherwise, if it's cold, so here's another condition

00:58:56.000 --> 00:59:00.000
if this condition is true we're going to tell the user it's a cold day 

00:59:00.000 --> 00:59:04.000
so where warm clothes. And otherwise if it's

00:59:04.000 --> 00:59:08.000
either hot or cold, we want to tell the user it's a lovely day. 

00:59:08.000 --> 00:59:12.000
So let me show you how to write a program that simulates these rules. So, 

00:59:12.000 --> 00:59:16.000
back to our program here, we start by defining a boolean variable 

00:59:16.000 --> 00:59:20.000
is underline hot. We set this to true. 

00:59:20.000 --> 00:59:24.000
Next, we add an if statement, so if, here

00:59:24.000 --> 00:59:28.000
we need to add a condition, in this case we're going to use our boolean variable. So, 

00:59:28.000 --> 00:59:32.000
is underline hot. So if this values to true. 

00:59:32.000 --> 00:59:36.000
Then we're going to do certain things. In this case, we want to tell the user

00:59:36.000 --> 00:59:40.000
hey it's a hot day, drink plenty of water. So, back to our program 

00:59:40.000 --> 00:59:44.000
after our condition we add a colon, now, 

00:59:44.000 --> 00:59:48.000
note that when I press enter pycharm automatically indents 

00:59:48.000 --> 00:59:52.000
our cursor. Now any code that we write here will be executed 

00:59:52.000 --> 00:59:56.000
if this condition is true, otherwise it will be ignored. Here

00:59:56.000 --> 01:00:00.000
is an example. Let's write a print statement, here I'm going to use

01:00:00.000 --> 01:00:04.000
double quotes because I want to use an apostrophe in our string. So, 

01:00:04.000 --> 01:00:08.000
it's a hot day. Now let's press enter

01:00:08.000 --> 01:00:12.000
you can see the cursor is still indented, that means we can write more code 

01:00:12.000 --> 01:00:16.000
that we executed if this condition is true, in this case let's say we don't want to

01:00:16.000 --> 01:00:20.000
write any extra code, so to terminate this block 

01:00:20.000 --> 01:00:24.000
we need to press shift and tab, now the cursor is at the beginning of the line

01:00:24.000 --> 01:00:28.000
so lets write a print statement with a message like

01:00:28.000 --> 01:00:32.000
enjoy your day. Now when we run this program, because

01:00:32.000 --> 01:00:36.000
this condition is true, you're doing to say this message followed by

01:00:36.000 --> 01:00:40.000
this second message, take a look, so run, there you go, it's a hot day

01:00:40.000 --> 01:00:44.000
enjoy your day. But if I go over here and 

01:00:44.000 --> 01:00:48.000
change this boolean value to false and run the program again, our

01:00:48.000 --> 01:00:52.000
first message disappears and we only see the second message, enjoy 

01:00:52.000 --> 01:00:56.000
your day. So this is how if statements work. Now back

01:00:56.000 --> 01:01:00.000
here we can add another print statement let's say

01:01:00.000 --> 01:01:04.000
drink plenty of water. 

01:01:04.000 --> 01:01:08.000
Now because this spirant statement is also indented it will be

01:01:08.000 --> 01:01:12.000
executed if this condition is true. So I'm going to revert is hot to true 

01:01:12.000 --> 01:01:16.000
and run the program one more time. There you go, so 

01:01:16.000 --> 01:01:20.000
it's a hot day, drink plenty of water, and enjoy your

01:01:20.000 --> 01:01:24.000
day. Alright now let's add a second rule here, if

01:01:24.000 --> 01:01:28.000
it's hot we're going to execute these two lines, otherwise if it's not hot

01:01:28.000 --> 01:01:32.000
we want to print a different message. So here 

01:01:32.000 --> 01:01:36.000
we are moving an indentation and typing els 

01:01:36.000 --> 01:01:40.000
colon. Now when we press enter once again our cursor 

01:01:40.000 --> 01:01:44.000
indented so the code that we write here will be executed if this

01:01:44.000 --> 01:01:48.000
condition is not true. So here we can print 

01:01:48.000 --> 01:01:52.000
it's a cold day, print, 

01:01:52.000 --> 01:01:56.000
where warm clothes. 

01:01:56.000 --> 01:02:00.000
Now let's run our program one more time. So we get the message 

01:02:00.000 --> 01:02:04.000
about a hot day followed by enjoy your day. You don't see any message

01:02:04.000 --> 01:02:08.000
about a cold day. Now if we go back here on the top. 

01:02:08.000 --> 01:02:12.000
And change this boolean value to false and run our program 

01:02:12.000 --> 01:02:16.000
we see different set of messages. It's a cold day

01:02:16.000 --> 01:02:20.000
wear warm clothes and enjoy your day. But there's a problem with 

01:02:20.000 --> 01:02:24.000
our program. If it's not hot it doesn't necessarily mean that it's cold, it means

01:02:24.000 --> 01:02:28.000
it's a lovely day. So the absence of heat doesn't mean its cold. 

01:02:28.000 --> 01:02:32.000
Back to our conditions, here on line 4 we have this rule that says 

01:02:32.000 --> 01:02:36.000
if it's a cold day, then print these messages

01:02:36.000 --> 01:02:40.000
otherwise if it's neither hot or cold say it's a lovely day. 

01:02:40.000 --> 01:02:44.000
So, to implement this rule we need to go back and put 

01:02:44.000 --> 01:02:48.000
py and define another variable. So let' say 

01:02:48.000 --> 01:02:52.000
is underline cold we set this to

01:02:52.000 --> 01:02:56.000
true. Now here we need to add a second condition. So after

01:02:56.000 --> 01:03:00.000
our first if statement, we can use an el if statement 

01:03:00.000 --> 01:03:04.000
to define a second condition. So here's how it works. So, 

01:03:04.000 --> 01:03:08.000
el if which is short for els if or

01:03:08.000 --> 01:03:12.000
otherwise if, now here we add another condition, so, 

01:03:12.000 --> 01:03:16.000
is cold So if t's cold you want to

01:03:16.000 --> 01:03:20.000
execute these few lines. So let's cut these

01:03:20.000 --> 01:03:24.000
from here, and move them under our second condition 

01:03:24.000 --> 01:03:28.000
and finally if none of these conditions are true, 

01:03:28.000 --> 01:03:32.000
you want to print a different message. It's a lovely 

01:03:32.000 --> 01:03:36.000
day. So, right now, 

01:03:36.000 --> 01:03:40.000
is hot is false, is cold is true, 

01:03:40.000 --> 01:03:44.000
so when we run this program, python interpreter is going to execute the first 

01:03:44.000 --> 01:03:48.000
if statement, in this case because our condition is false, these two

01:03:48.000 --> 01:03:52.000
lines will be ignored, then Python interpreter will look at 

01:03:52.000 --> 01:03:56.000
line 7, it will evaluate this condition, in this case is

01:03:56.000 --> 01:04:00.000
cold is true so we're going to see these two messages on the terminal. 

01:04:00.000 --> 01:04:04.000
Now, in this case, because one of these conditions was true, this els statement

01:04:04.000 --> 01:04:08.000
will be ignored, so we are not going to see this message, and finally 

01:04:08.000 --> 01:04:12.000
as before, we are always going too see this message. So let's run our

01:04:12.000 --> 01:04:16.000
program, there you go. it's a cold day, 

01:04:16.000 --> 01:04:20.000
where warm clothes and and enjoy your day. Now, 

01:04:20.000 --> 01:04:24.000
back to the top, if we change is cold 

01:04:24.000 --> 01:04:28.000
to false it's neither hot nor cold so it's going to be a lovely day.

01:04:28.000 --> 01:04:32.000
Let's run the program, and here you go, it's a lovely day

01:04:32.000 --> 01:04:36.000
enjoy your day. So these are the basics of using if 

01:04:36.000 --> 01:04:40.000
statements. As you can see they are very useful in programming and with these

01:04:40.000 --> 01:04:44.000
we can build all kinds of rules into our programs. Okay here's an

01:04:44.000 --> 01:04:48.000
exercise or you. Imagine the price of a house is 1 million dollars. 

01:04:48.000 --> 01:04:52.000
Now if the buyer has good credit, they will need to put down 10 percent 

01:04:52.000 --> 01:04:56.000
of the price of this property otherwise they need to put down 20 percent 

01:04:56.000 --> 01:05:00.000
write a program with these rules an display the down payment 

01:05:00.000 --> 01:05:04.000
card for a buyer with good credit. You will see my solution 

01:05:04.000 --> 01:05:08.000
next. 

01:05:08.000 --> 01:05:12.000
Alright let's define a variable for the price of this house so price 

01:05:12.000 --> 01:05:16.000
we set this to 1 million so 1 with 6 0s. 

01:05:16.000 --> 01:05:20.000
Next we need a variable to tell if this buyer has good credit 

01:05:20.000 --> 01:05:24.000
so has good credit, 

01:05:24.000 --> 01:05:28.000
and we set this to true, now we need an if statement 

01:05:28.000 --> 01:05:32.000
so if has good credit has true 

01:05:32.000 --> 01:05:36.000
colon, here we need to calculate a down payment so

01:05:36.000 --> 01:05:40.000
the down_payment should be equal to

01:05:40.000 --> 01:05:44.000
0.1 x the price. That is 10 percent of the price of this

01:05:44.000 --> 01:05:48.000
property. Otherwise colon

01:05:48.000 --> 01:05:52.000
the down payment should be 0.2 

01:05:52.000 --> 01:05:56.000
times price. Now finally we remove the

01:05:56.000 --> 01:06:00.000
indentation and print here we can use a form 

01:06:00.000 --> 01:06:04.000
of valid string, first we add a label, down payment 

01:06:04.000 --> 01:06:08.000
colon and right after that we add a placeholder 

01:06:08.000 --> 01:06:12.000
or a hole for our down payment variable. So curly braces 

01:06:12.000 --> 01:06:16.000
down payment. Let's run this

01:06:16.000 --> 01:06:20.000
program, so down payment for a buyer with good credit 

01:06:20.000 --> 01:06:24.000
is 100,000 dollars. Now let's improve this by adding a 

01:06:24.000 --> 01:06:28.000
dollar sign before this number. So back to our formatted string,

01:06:28.000 --> 01:06:32.000
just before the curly brace I'm going to add a dollar sign let's

01:06:32.000 --> 01:06:36.000
run this one more time, that is better. 

01:06:40.000 --> 01:06:44.000
In this tutorial I'm going to talk to you about the logical operators within Python.

01:06:44.000 --> 01:06:48.000
We use these operators in situations where we have multiple 

01:06:48.000 --> 01:06:52.000
conditions. Here is an example. Let' say we're building an application for 

01:06:52.000 --> 01:06:56.000
processing loans. If an applicant has high income 

01:06:56.000 --> 01:07:00.000
and good credit, then they're eligible 

01:07:00.000 --> 01:07:04.000
for a loan. So in this example we have two conditions, one is having 

01:07:04.000 --> 01:07:08.000
high income and the other is having good credit. So if both

01:07:08.000 --> 01:07:12.000
these conditions are true, then the applicant is eligible for a loan.

01:07:12.000 --> 01:07:16.000
So this is where we use the logical and operator. 

01:07:16.000 --> 01:07:20.000
We use this operator to combine two conditions, and by the way

01:07:20.000 --> 01:07:24.000
this is not specific to python programming language, pretty much any programming language 

01:07:24.000 --> 01:07:28.000
that supports if statements also supports the logical operators. 

01:07:28.000 --> 01:07:32.000
So, back to our program, let's define two variables, 

01:07:32.000 --> 01:07:36.000
has high income, we set this to true. 

01:07:36.000 --> 01:07:40.000
And another one has good 

01:07:40.000 --> 01:07:44.000
credit, we also set this to true, now our if statement 

01:07:44.000 --> 01:07:48.000
if has high income has true, 

01:07:48.000 --> 01:07:52.000
and has good credit is also true, 

01:07:52.000 --> 01:07:56.000
then we're going to print eligible 

01:07:56.000 --> 01:08:00.000
for null. So this is where 

01:08:00.000 --> 01:08:04.000
we're using the and operator. So if both these conditions are true 

01:08:04.000 --> 01:08:08.000
then this message will be printed. If one of them is false, we're not going to see 

01:08:08.000 --> 01:08:12.000
this message. Let's try this out. So I'm going to run this program 

01:08:12.000 --> 01:08:16.000
so we see it eligible for loan, but if we change 

01:08:16.000 --> 01:08:20.000
either of these conditions to false, and run the program again 

01:08:20.000 --> 01:08:24.000
look, the message disappears. 

01:08:24.000 --> 01:08:28.000
So this is the logical and operator. We also have the

01:08:28.000 --> 01:08:32.000
logical or, and we want to use that in situations where we want to do certain things

01:08:32.000 --> 01:08:36.000
at least one of the conditions is true, for example let's change 

01:08:36.000 --> 01:08:40.000
the rule for this program, such that if the applicant has high income, 

01:08:40.000 --> 01:08:44.000
or good credit, then they're eligible for a loan, 

01:08:44.000 --> 01:08:48.000
so if either or both these conditions are true then the candidate is

01:08:48.000 --> 01:08:52.000
eligible. Now back to our program we can 

01:08:52.000 --> 01:08:56.000
implement this rule by using the logical or operator. So we simply replace 

01:08:56.000 --> 01:09:00.000
and with or, now when we run this program we're going to

01:09:00.000 --> 01:09:04.000
see this message because at least one of our conditions is true, 

01:09:04.000 --> 01:09:08.000
let's take a look. So the applicant is eligible for a loan

01:09:08.000 --> 01:09:12.000
for a loan because they have good credit. If you change this to false 

01:09:12.000 --> 01:09:16.000
but set the other condition to true, we still

01:09:16.000 --> 01:09:20.000
see the same result, but if both these conditions are false 

01:09:20.000 --> 01:09:24.000
then we're not going to see this message anymore. So this is the difference 

01:09:24.000 --> 01:09:28.000
between these operators. With the logical and operator 

01:09:28.000 --> 01:09:32.000
both conditions should be true, with the logical 

01:09:32.000 --> 01:09:36.000
or operator at least one condition should be true

01:09:36.000 --> 01:09:40.000
we also have another logical operator called not

01:09:40.000 --> 01:09:44.000
and that basically inverses any boolean value we give it, if we give it, 

01:09:44.000 --> 01:09:48.000
we give it a true boolean value it converts it to false. For example 

01:09:48.000 --> 01:09:52.000
let's make up a new room, if applicant 

01:09:52.000 --> 01:09:56.000
has good credit and doesn't have 

01:09:56.000 --> 01:10:00.000
a criminal record then

01:10:00.000 --> 01:10:04.000
they're eligible for a loan. Let me show you how to implement this. So, 

01:10:04.000 --> 01:10:08.000
we go back to our program, in this example we don't need a 

01:10:08.000 --> 01:10:12.000
first variable for let's delete that. Let's set this variable to true

01:10:12.000 --> 01:10:16.000
we also define another variable like has criminal 

01:10:16.000 --> 01:10:20.000
record. We set this to false. 

01:10:20.000 --> 01:10:24.000
Now, we want to check to see if this applicant has good credit and not

01:10:24.000 --> 01:10:28.000
a criminal record. This is where we use the not operator. 

01:10:28.000 --> 01:10:32.000
So, if they have good credit, 

01:10:32.000 --> 01:10:36.000
and not criminal 

01:10:36.000 --> 01:10:40.000
record. So, in this example, has criminal

01:10:40.000 --> 01:10:44.000
record is set to false, when we use the not operator this

01:10:44.000 --> 01:10:48.000
basically gets changed to true, so we have two conditions that are true. 

01:10:48.000 --> 01:10:52.000
Here's ones and here's another one. So our applicant is

01:10:52.000 --> 01:10:56.000
eligible for a loan. And when we run this program we see

01:10:56.000 --> 01:11:00.000
this familiar message. However

01:11:00.000 --> 01:11:04.000
if an applicant has a criminal record, so let's change this to 

01:11:04.000 --> 01:11:08.000
true, now when we run this program we can see our applicant is

01:11:08.000 --> 01:11:12.000
not eligible because when we apply then operator on this

01:11:12.000 --> 01:11:16.000
variable, we'll get false. So true changes to false. 

01:11:16.000 --> 01:11:20.000
And we'll end up with two conditions, one that's true

01:11:20.000 --> 01:11:24.000
and the other is false. And that's why this message is

01:11:24.000 --> 01:11:28.000
not printed. So this is all about the logical operators in

01:11:28.000 --> 01:11:32.000
python. 

01:11:32.000 --> 01:11:36.000
In this tutorial I'm going to talk to you guys about

01:11:36.000 --> 01:11:40.000
comparison operators in Python. We use comparison operators

01:11:40.000 --> 01:11:44.000
in situations where we want to compare a variable with a value, 

01:11:44.000 --> 01:11:48.000
for example, if temperature is greater than 30, then

01:11:48.000 --> 01:11:52.000
we want to print it's a hot day. Otherwise, if it's less

01:11:52.000 --> 01:11:56.000
then 10, it's a cold day, otherwise it it's neither hot

01:11:56.000 --> 01:12:00.000
nor cold. And by the way I'm taking about celsius, not farenheit. 

01:12:00.000 --> 01:12:04.000
So, to build these rules into our program, we need to use comparison

01:12:04.000 --> 01:12:08.000
operators. Back to app.py, I define this

01:12:08.000 --> 01:12:12.000
temperature value, let's write an if statement, if temperature

01:12:12.000 --> 01:12:16.000
now we want to check to see if this is greater than 30, so we use 

01:12:16.000 --> 01:12:20.000
the greater than operator. If this is greater than 30, 

01:12:20.000 --> 01:12:24.000
we want to print it's a hot day

01:12:24.000 --> 01:12:28.000
otherwise, let's just print 

01:12:28.000 --> 01:12:32.000
it's not a hot day. Now, 

01:12:32.000 --> 01:12:36.000
when we run this program, we're going to see this second message because 30

01:12:36.000 --> 01:12:40.000
is not greater than 30. So our first condition a value

01:12:40.000 --> 01:12:44.000
is to false. let's verify that. So run, 

01:12:44.000 --> 01:12:48.000
it's not a hot day. Now if you change

01:12:48.000 --> 01:12:52.000
the temperature to 35 and run this again, 

01:12:52.000 --> 01:12:56.000
we're going to see a different message, it's a hot day, so this is where we use

01:12:56.000 --> 01:13:00.000
comparison operators. Now what we have here as you know is an expression

01:13:00.000 --> 01:13:04.000
because it's a piece of code that produces a value. So more accurately this is

01:13:04.000 --> 01:13:08.000
a boolean expression. So this is the greater than operator, 

01:13:08.000 --> 01:13:12.000
we also have greater than or equal to, we have

01:13:12.000 --> 01:13:16.000
less then, less then or equal to, 

01:13:16.000 --> 01:13:20.000
here's the equality operator, so if the temperature equals to 30, 

01:13:20.000 --> 01:13:24.000
then you can say it's a hot day. Note that this is different from the assignment operator 

01:13:24.000 --> 01:13:28.000
that has only one equals sign. You can see that if we use only one equal sign

01:13:28.000 --> 01:13:32.000
here we immediately get this red underline because this is simply 

01:13:32.000 --> 01:13:36.000
an assignment statement. We're changing the value of the temperature. 

01:13:36.000 --> 01:13:40.000
you are setting the value of

01:13:40.000 --> 01:13:44.000
something else. So we don't have a boolean expression, you are not producing a 

01:13:44.000 --> 01:13:48.000
boolean value. Okay? So, our equality operator 

01:13:48.000 --> 01:13:52.000
has two equal signs and finally we have not

01:13:52.000 --> 01:13:56.000
equal which is an exclamation followed by an equal sign. 

01:13:56.000 --> 01:14:00.000
Now here's an exercise for you. You have probably seen that when you fill out a 

01:14:00.000 --> 01:14:04.000
form online, sometimes the input fields have validation messages, 

01:14:04.000 --> 01:14:08.000
for example, let's say we have an input field for the user to enter their name. 

01:14:08.000 --> 01:14:12.000
Now if the name is less then 3 characters wrong we want to display a validation 

01:14:12.000 --> 01:14:16.000
error, like name must be at least three characters, 

01:14:16.000 --> 01:14:20.000
otherwise, if the name is more then 50 characters long then we want 

01:14:20.000 --> 01:14:24.000
to display a different validation error like name can be a maximum

01:14:24.000 --> 01:14:28.000
of 50 characters. Otherwise if the name is between 3 and 50 characters

01:14:28.000 --> 01:14:32.000
then we just want to tell the user that name looks good. 

01:14:32.000 --> 01:14:36.000
So go ahead, and write a plan to implement these rules. 

01:14:40.000 --> 01:14:44.000
Alright let's define a variable called name and set it to

01:14:44.000 --> 01:14:48.000
let's say j. So we're assuming this is what the user types into an input field.

01:14:48.000 --> 01:14:52.000
Now, we want to get the number of characters in this string. 

01:14:52.000 --> 01:14:56.000
So we use the len function, right? Len of name.

01:14:56.000 --> 01:15:00.000
When we print this we get 1, right

01:15:00.000 --> 01:15:04.000
you have seen this before. Now here we want to use an if statement so

01:15:04.000 --> 01:15:08.000
if len of name is less then 

01:15:08.000 --> 01:15:12.000
3, then we want to print 

01:15:12.000 --> 01:15:16.000
name must be at least 3 characters

01:15:16.000 --> 01:15:20.000
now here we need a second condition 

01:15:20.000 --> 01:15:24.000
to check the upper limit. So el if

01:15:24.000 --> 01:15:28.000
len of name is greater than 50, 

01:15:28.000 --> 01:15:32.000
then we want to print a different message, name, 

01:15:32.000 --> 01:15:36.000
must be a maximum 

01:15:36.000 --> 01:15:40.000
of 50 characters. 

01:15:40.000 --> 01:15:44.000
Okay? And otherwise if else

01:15:44.000 --> 01:15:48.000
none of these conditions are true that means the name looks good. So, 

01:15:48.000 --> 01:15:52.000
print, name looks good. Let's 

01:15:52.000 --> 01:15:56.000
run our program. So in this case we get this message

01:15:56.000 --> 01:16:00.000
because our name is too short. Now if you go back here and 

01:16:00.000 --> 01:16:04.000
type something really really long. And then

01:16:04.000 --> 01:16:08.000
we run our program we're going to see a different message name must be a 

01:16:08.000 --> 01:16:12.000
maximum of 50 characters and finally if

01:16:12.000 --> 01:16:16.000
we type a proper name here like John Smith

01:16:16.000 --> 01:16:20.000
and run our program we get name 

01:16:20.000 --> 01:16:24.000
looks good. 

01:16:24.000 --> 01:16:28.000
Here's another good exercise that combines 

01:16:28.000 --> 01:16:32.000
many of the materials you have learned so far, so earlier you built a program to 

01:16:32.000 --> 01:16:36.000
convert someone's weight from pounds to kilograms. Now we want to extend this program 

01:16:36.000 --> 01:16:40.000
and allow the user to enter their weight in either kilograms or

01:16:40.000 --> 01:16:44.000
pounds and then we will convert it to the other unit. Here's how our program

01:16:44.000 --> 01:16:48.000
is going to work. So I enter my weight in pounds so

01:16:48.000 --> 01:16:52.000
100 and 60 now it's telling me if it's in pounds or

01:16:52.000 --> 01:16:56.000
kilograms. So here I'm adding l to lbs or k for kilograms. 

01:16:56.000 --> 01:17:00.000
And by the way, this program is not case sensitive so

01:17:00.000 --> 01:17:04.000
when I enter a capital l or lowercase l it takes 

01:17:04.000 --> 01:17:08.000
it as pounds. Now it tells me ur set it to

01:17:08.000 --> 01:17:12.000
kilos. Let's run this program one more time, 

01:17:12.000 --> 01:17:16.000
this time I'm going to enter my weight in kilo's, so send it to

01:17:16.000 --> 01:17:20.000
is the weight and the unit is kilograms so k, 

01:17:20.000 --> 01:17:24.000
and it says you are 160 pounds. 

01:17:24.000 --> 01:17:28.000
So go ahead and spend a few minutes on this exercise, you will see my solution next.

01:17:32.000 --> 01:17:36.000
Alright first let's ask the user their weight. So we use the input

01:17:36.000 --> 01:17:40.000
function, weight colon we get the return value

01:17:40.000 --> 01:17:44.000
and store it in the variable called weight.

01:17:44.000 --> 01:17:48.000
Now the second question, so one more time we use the input function

01:17:48.000 --> 01:17:52.000
el for pounds. 

01:17:52.000 --> 01:17:56.000
Or k for kilograms. So, 

01:17:56.000 --> 01:18:00.000
let's get that too and store it in a variable called unit 

01:18:00.000 --> 01:18:04.000
now we need an if statement. So if unit 

01:18:04.000 --> 01:18:08.000
equals l then we need to convert this weight 

01:18:08.000 --> 01:18:12.000
into kilograms. However, with this implementation we are only allowing 

01:18:12.000 --> 01:18:16.000
the user to enter a capitol l, if they enter a lowercase l 

01:18:16.000 --> 01:18:20.000
this code is not going to work. So this is where we use the upper

01:18:20.000 --> 01:18:24.000
method of string objects so this unit is a string because as I told you

01:18:24.000 --> 01:18:28.000
before, the input function always returns a string. 

01:18:28.000 --> 01:18:32.000
So, we can use the dot operator to access all it's methods or

01:18:32.000 --> 01:18:36.000
functions, here we call the upper method, this

01:18:36.000 --> 01:18:40.000
will convert whatever the user enters to upper case and then we'll convert it 

01:18:40.000 --> 01:18:44.000
to a capital l. Now, if this condition is true, 

01:18:44.000 --> 01:18:48.000
then we need to get the weight and multiply it by 0, 

01:18:48.000 --> 01:18:52.000
.45 However, as you know this

01:18:52.000 --> 01:18:56.000
weight is a string object, and we cannot multiply a string 

01:18:56.000 --> 01:19:00.000
by a floating point number, we talked about this earlier in this course. 

01:19:00.000 --> 01:19:04.000
So first we need to convert this weight to a numerical value. So 

01:19:04.000 --> 01:19:08.000
right here, when we call the input function, we can get the return

01:19:08.000 --> 01:19:12.000
value and pass it to the int function. So, 

01:19:12.000 --> 01:19:16.000
we call the int function and give it

01:19:16.000 --> 01:19:20.000
the return value of the input function. Now, the

01:19:20.000 --> 01:19:24.000
in function will return an integer so we can store it in this weight 

01:19:24.000 --> 01:19:28.000
variable. So here's the converted weight, let's store it in

01:19:28.000 --> 01:19:32.000
a variable called converted, 

01:19:32.000 --> 01:19:36.000
then we print here we can use a formatted string, so

01:19:36.000 --> 01:19:40.000
we prefix this string with f ur

01:19:40.000 --> 01:19:44.000
we add curly braces to dynamically insert the value of

01:19:44.000 --> 01:19:48.000
converted variable. And finally we add kilo.

01:19:48.000 --> 01:19:52.000
Otherwise, if the unit is kilograms. 

01:19:52.000 --> 01:19:56.000
We need to divide the weight by 0.45. q

01:20:00.000 --> 01:20:04.000
So, weight divided by 0.45 and

01:20:04.000 --> 01:20:08.000
just to refresh your memory, this division operator returns a floating point number

01:20:08.000 --> 01:20:12.000
but if we use double slashes we'll get an integer. 

01:20:12.000 --> 01:20:16.000
In this case, we want to get a floating point number, 

01:20:16.000 --> 01:20:20.000
finally let's print a formatted string, ur

01:20:20.000 --> 01:20:24.000
 curly braces, converted 

01:20:24.000 --> 01:20:28.000
pounds. Okay? Now

01:20:28.000 --> 01:20:32.000
let's run this program and see what happens. So weight is

01:20:32.000 --> 01:20:36.000
160 and lbs in

01:20:36.000 --> 01:20:40.000
and that equals to 72 kilos, perfect, if we run it one more time, 

01:20:40.000 --> 01:20:44.000
and enter 72 kilos 

01:20:44.000 --> 01:20:48.000
we get 160 pounds.

01:20:52.000 --> 01:20:56.000
In this tutorial I'm going to show you how to use y loops in python. We  

01:20:56.000 --> 01:21:00.000
use y loops to execute a block of code multiple times and there are often

01:21:00.000 --> 01:21:04.000
useful in building interactive programs and games. In a future tutorial

01:21:04.000 --> 01:21:08.000
I'm going to show you how to build a simple game using a y loop.

01:21:08.000 --> 01:21:12.000
So, let's get started with the basics, we write a y statement 

01:21:12.000 --> 01:21:16.000
and right after that, we type a condition followed by a colon

01:21:16.000 --> 01:21:20.000
as long as this condition is true the quote that we write 

01:21:20.000 --> 01:21:24.000
in this block will be repeatedly executed. Here is an example.

01:21:24.000 --> 01:21:28.000
We can define a variable like i, as in short for

01:21:28.000 --> 01:21:32.000
index and set it to 1. Now we set our condition to

01:21:32.000 --> 01:21:36.000
i less than or equal to 5, so as long as I

01:21:36.000 --> 01:21:40.000
is less then or equal to 5, we can print i, 

01:21:40.000 --> 01:21:44.000
on the terminal. And then we need to increment i, 

01:21:44.000 --> 01:21:48.000
by 1. So we set i to i plus 1. The reason

01:21:48.000 --> 01:21:52.000
we do this is that if we don't do this I will be 1 forever

01:21:52.000 --> 01:21:56.000
so we'll end up with an infinite loop. Because this condition will

01:21:56.000 --> 01:22:00.000
always be true. One is always less then 5, so in every iteration of this

01:22:00.000 --> 01:22:04.000
loop, we increment i by 1, so at some point, i is gonna be

01:22:04.000 --> 01:22:08.000
six and then that is when this condition will be false and then

01:22:08.000 --> 01:22:12.000
we'll jump out of this loop, okay? Now to demonstrate how everything works

01:22:12.000 --> 01:22:16.000
after this loop I'm going to add a print statement

01:22:16.000 --> 01:22:20.000
say done. So note that these two lines

01:22:20.000 --> 01:22:24.000
are indented so they are part of the y block. 

01:22:24.000 --> 01:22:28.000
Okay, now let's go ahead and run this program and see what happens. So, 

01:22:28.000 --> 01:22:32.000
take a look, we get the numbers 1-5 followed by

01:22:32.000 --> 01:22:36.000
done. So heres how this program gets executed

01:22:36.000 --> 01:22:40.000
first we set i to 1 now python interpreter executes line

01:22:40.000 --> 01:22:44.000
2, this condition is true because i is less then 5, 

01:22:44.000 --> 01:22:48.000
so i is printed on the terminal and then incremented by

01:22:48.000 --> 01:22:52.000
1. Then the control moves back to the beginning of the y loop.

01:22:52.000 --> 01:22:56.000
So it doesn't go to the next statement. So, 

01:22:56.000 --> 01:23:00.000
we come back here and now we are in the second iteration. In the second iteration

01:23:00.000 --> 01:23:04.000
i is 2, and because 2 is less then 5, our condition is still

01:23:04.000 --> 01:23:08.000
true, so i will be printed on the terminal, and once again it will be

01:23:08.000 --> 01:23:12.000
incremented by 1, so at some point i is going to be 6, 

01:23:12.000 --> 01:23:16.000
and that's when this condition will be false so our look will

01:23:16.000 --> 01:23:20.000
be terminated and this done message will be printed on the terminal.

01:23:20.000 --> 01:23:24.000
So this is the basics of y loops. Now let's make this program a little

01:23:24.000 --> 01:23:28.000
bit more interesting. Here we can write an expression like this. We

01:23:28.000 --> 01:23:32.000
add a string, and in this string we add an asterisk

01:23:32.000 --> 01:23:36.000
and then we multiply this string by i. So

01:23:36.000 --> 01:23:40.000
with this expression, we can repeat a string, when we multiply a string

01:23:40.000 --> 01:23:44.000
by a number, that string will be repeated. For example, if

01:23:44.000 --> 01:23:48.000
i is two, this expression will produce a 

01:23:48.000 --> 01:23:52.000
string with two asterisks. Now let's run the program

01:23:52.000 --> 01:23:56.000
and see what we get. So we see this little triangle 

01:23:56.000 --> 01:24:00.000
shape here. Because in the first iteration i is 1, so, 

01:24:00.000 --> 01:24:04.000
1 times an asterisk produces 1 asterisk. 

01:24:04.000 --> 01:24:08.000
In the second iteration i is 2, so when we multiply 2

01:24:08.000 --> 01:24:12.000
by 1 asterisks, we'll get 2 asterisks. 

01:24:16.000 --> 01:24:20.000
In this tutorial I'm going to show you how to use a y loop to build 

01:24:20.000 --> 01:24:24.000
a guessing game like this. So we have this secret number which is currently set to

01:24:24.000 --> 01:24:28.000
9. Now the computer is asking me to make a guess. So, 

01:24:28.000 --> 01:24:32.000
let's say 1 is not right because the secret number is 9, okay, 

01:24:32.000 --> 01:24:36.000
try again, 2, no it's not right, let's try again, so I

01:24:36.000 --> 01:24:40.000
only have three chances to make a guess. If I can't guess the number the program 

01:24:40.000 --> 01:24:44.000
tells me that  I failed. let's run the program one more time, this time

01:24:44.000 --> 01:24:48.000
I'm going to guess the number, it's 9, there you go, it says you in.

01:24:48.000 --> 01:24:52.000
So let's go ahead and build this program using a y loop.

01:24:52.000 --> 01:24:56.000
Alright, let's start by defining a variable to store our secret number

01:24:56.000 --> 01:25:00.000
so, we call the secret underline number and set it to 9.

01:25:00.000 --> 01:25:04.000
Now we need a while loop to repeatedly ask a user to

01:25:04.000 --> 01:25:08.000
make a guess. So while condition colon

01:25:08.000 --> 01:25:12.000
What is our condition here? Well we want to give our user a

01:25:12.000 --> 01:25:16.000
maximum of three guesses. So similar to the last tutorial, we can define

01:25:16.000 --> 01:25:20.000
a variable like I, set it to 0, and assume this represents

01:25:20.000 --> 01:25:24.000
the number of guesses the user has made. And then we write our condition 

01:25:24.000 --> 01:25:28.000
as i less then 3. Note that here I'm not

01:25:28.000 --> 01:25:32.000
using less then or equal to operator, because with this condition

01:25:32.000 --> 01:25:36.000
our loop will be executed 4 times, while i is 0,

01:25:36.000 --> 01:25:40.000
one, two, and three, so here we should use 

01:25:40.000 --> 01:25:44.000
the less then operator. Now if we give this code to someone else it's unclear

01:25:44.000 --> 01:25:48.000
what does i represent here, it's only in our head that

01:25:48.000 --> 01:25:52.000
i represents the number of guesses the user has made. So as

01:25:52.000 --> 01:25:56.000
a best practice, always use meaningful and descriptive names for your variables. 

01:25:56.000 --> 01:26:00.000
So it's better to rename this variable to guess, count.

01:26:00.000 --> 01:26:04.000
Let me show you how to rename. So right click on i variable, 

01:26:04.000 --> 01:26:08.000
and then go to refactor and 

01:26:08.000 --> 01:26:12.000
rename it. Look at the shortcut. On a Mac computer it's shift and

01:26:12.000 --> 01:26:16.000
f 6. Now in this dialogue box we can easily

01:26:16.000 --> 01:26:20.000
rename your variable and pycharm will update all the references to that

01:26:20.000 --> 01:26:24.000
variable so we don't have to manually update each instance, okay? Let's

01:26:24.000 --> 01:26:28.000
change this to guess_count

01:26:28.000 --> 01:26:32.000
enter, there you go, now that is better, 

01:26:32.000 --> 01:26:36.000
also it's better to store 3 in a separate variable to make our code

01:26:36.000 --> 01:26:40.000
more readable, because it's not quite clear what does 3 represent here. 

01:26:40.000 --> 01:26:44.000
So, let's define a variable called guess limit

01:26:44.000 --> 01:26:48.000
say to 3, and then we can change 3 to guess

01:26:48.000 --> 01:26:52.000
underline limit, now our code is more readable

01:26:52.000 --> 01:26:56.000
while guess count is less then guess limit, see it reads like a story

01:26:56.000 --> 01:27:00.000
this is how you should write code. Okay, so

01:27:00.000 --> 01:27:04.000
while this condition is true, we want toast the user to make a guess. So here 

01:27:04.000 --> 01:27:08.000
we use our input function, guess

01:27:08.000 --> 01:27:12.000
Now whatever the user enters comes out as a string so we need to convert it to an integer.

01:27:12.000 --> 01:27:16.000
So right here, we pass the result to the end function

01:27:16.000 --> 01:27:20.000
and then get it and store it in a separate variable called guess.

01:27:20.000 --> 01:27:24.000
So at this point the user made a guess, now we need to

01:27:24.000 --> 01:27:28.000
increment guess count so guess count

01:27:28.000 --> 01:27:32.000
we set it to plus equal 1 or 

01:27:32.000 --> 01:27:36.000
okay, now we need to check to see if the user will make the right guess.

01:27:36.000 --> 01:27:40.000
So here we need an if statement. If what the user guessed

01:27:40.000 --> 01:27:44.000
equals our secret number, 

01:27:44.000 --> 01:27:48.000
again see our code is so readable. It's like a story you can read it like plain

01:27:48.000 --> 01:27:52.000
English. So if this condition is true we want to 

01:27:52.000 --> 01:27:56.000
tell the user they won. So print you won

01:27:56.000 --> 01:28:00.000
now lets go ahead and run our program up to this point.

01:28:00.000 --> 01:28:04.000
So okay it's asking me to make a guess, I'm going to make 

01:28:04.000 --> 01:28:08.000
the wrong guess so one it asked me again, 2 one more time, 

01:28:08.000 --> 01:28:12.000
3, okay, what is missing in this implementation is the

01:28:12.000 --> 01:28:16.000
message that tells me that I failed. We're going to take care of it momentarily, but

01:28:16.000 --> 01:28:20.000
let's run the program one more time and make the right guess. So, 9

01:28:20.000 --> 01:28:24.000
okay it says you won, but it's still asking me to make

01:28:24.000 --> 01:28:28.000
a guess, because our while loop is going to get executed 3 times. Look

01:28:28.000 --> 01:28:32.000
1 and 2. So we need to change our program

01:28:32.000 --> 01:28:36.000
such that if the user makes the right guess, we need to terminate our

01:28:36.000 --> 01:28:40.000
while loop, we need to jump out of it. How do we do that?

01:28:40.000 --> 01:28:44.000
So, over here if the user makes the right guess, after

01:28:44.000 --> 01:28:48.000
we print this message we can use the brick statement to terminate

01:28:48.000 --> 01:28:52.000
terminate a loop, when python interpreter sees this, it's going to

01:28:52.000 --> 01:28:56.000
immediately terminate our loop, it's not going to evaluate this condition again. 

01:28:56.000 --> 01:29:00.000
Now let's run our program and see what happens. So, I'm going to

01:29:00.000 --> 01:29:04.000
guess the right number, you won and look, you are

01:29:04.000 --> 01:29:08.000
now asked to make two more guesses, beautiful. Now the last thing we need

01:29:08.000 --> 01:29:12.000
to add here is the message that tells the user that they failed if they could not guess

01:29:12.000 --> 01:29:16.000
the right number. How do we do that? Well in Python

01:29:16.000 --> 01:29:20.000
our while loops can optionally have an else part. 

01:29:20.000 --> 01:29:24.000
similar to the if statements. So earlier you learned that our if statements 

01:29:24.000 --> 01:29:28.000
can optionally happen else part. Here, so

01:29:28.000 --> 01:29:32.000
if this condition is true, do this,

01:29:32.000 --> 01:29:36.000
otherwise do something else. In this case our if statement doesn't have

01:29:36.000 --> 01:29:40.000
an else part. Now, similar to the if statements

01:29:40.000 --> 01:29:44.000
Our while loops, our while statements can also have an else part. 

01:29:44.000 --> 01:29:48.000
So, right at this level we can add

01:29:48.000 --> 01:29:52.000
an else block, so else colon. 

01:29:52.000 --> 01:29:56.000
And the code that we write here will get executed if this while loop

01:29:56.000 --> 01:30:00.000
completes successfully without an immediate 

01:30:00.000 --> 01:30:04.000
break. In other words. If the user guesses the

01:30:04.000 --> 01:30:08.000
right number, you break this loop, you jump out of it so the code that

01:30:08.000 --> 01:30:12.000
we write in the else block will not get executed. 

01:30:12.000 --> 01:30:16.000
But if the user cannot guess this number, you're never going to break out of

01:30:16.000 --> 01:30:20.000
this loop, so this loop will be executed to completion untill

01:30:20.000 --> 01:30:24.000
this condition become false. In that case, the code that we write

01:30:24.000 --> 01:30:28.000
in the else block will get executed, and this is the perfect opportunity for us

01:30:28.000 --> 01:30:32.000
to tell the user hey, you made three guesses but none of them were right.

01:30:32.000 --> 01:30:36.000
So, print, sorry you

01:30:36.000 --> 01:30:40.000
failed. Now, let's test the program one more time.

01:30:40.000 --> 01:30:44.000
So, guess 1, 2, 3, 

01:30:44.000 --> 01:30:48.000
sorry you failed, let's run it one more time. This time I'm going to make

01:30:48.000 --> 01:30:52.000
a wrong guess, and then the right guess, 

01:30:52.000 --> 01:30:56.000
we won and our loop terminated immediately. 

01:31:00.000 --> 01:31:04.000
Alright, now it's time for you to practice what you have learned so far. 

01:31:04.000 --> 01:31:08.000
So once again we're going to build a game this game is a simulation 

01:31:08.000 --> 01:31:12.000
card game. Now our game doesn't have a graphical user interface or gooey 

01:31:12.000 --> 01:31:16.000
and it doesn't really matter for now, our focus is entirely on building the

01:31:16.000 --> 01:31:20.000
engine for this game. So let's see how this works. 

01:31:20.000 --> 01:31:24.000
When we run this, we get this little symbol here, and our program

01:31:24.000 --> 01:31:28.000
is waiting for us to enter a command. If you type help

01:31:28.000 --> 01:31:32.000
either a lower case or upper case we get the list of commands

01:31:32.000 --> 01:31:36.000
that our program or our game currently supports. So we can type the

01:31:36.000 --> 01:31:40.000
start command to start our car, we can type

01:31:40.000 --> 01:31:44.000
stop command to stop our car, and quit to terminate the game.

01:31:44.000 --> 01:31:48.000
Any other commands that we type our program is going to tell us hey I don't understand that.

01:31:48.000 --> 01:31:52.000
For example, if I type asd here, it's going to say I don't understand 

01:31:52.000 --> 01:31:56.000
that.If you type start, we get this message, 

01:31:56.000 --> 01:32:00.000
car started, ready to go, if you type stop it 

01:32:00.000 --> 01:32:04.000
says car stopped, and finally if we hit quit

01:32:04.000 --> 01:32:08.000
our program terminates, this is a fantastic exercise for you to practice

01:32:08.000 --> 01:32:12.000
wha you have learned, so pause the video and spend 5-10 minutes

01:32:12.000 --> 01:32:16.000
to build this program. 

01:32:16.000 --> 01:32:20.000
Alright, we're going to start with a while loop with a condition 

01:32:20.000 --> 01:32:24.000
What is our condition here? We want to run this loop 

01:32:24.000 --> 01:32:28.000
until the user types quit. So we can define a variable

01:32:28.000 --> 01:32:32.000
or a story to command what the user enters, and then we can run this

01:32:32.000 --> 01:32:36.000
loop as long as the command does not equal to quit. So right before

01:32:36.000 --> 01:32:40.000
the loop, we define a variable, command, and initially we set it

01:32:40.000 --> 01:32:44.000
to an empty string. An empty string is a string that has no characters

01:32:44.000 --> 01:32:48.000
in it. We only have the quotes. So then

01:32:48.000 --> 01:32:52.000
we type out our condition as while command 

01:32:52.000 --> 01:32:56.000
does not equal to quit then do something. 

01:32:56.000 --> 01:33:00.000
Now immediately we have a problem here because we're assuming that the user 

01:33:00.000 --> 01:33:04.000
types the command in lower case, so if they type this in upper case they

01:33:04.000 --> 01:33:08.000
our program is not going to behave properly, so to fix this problem, you need to

01:33:08.000 --> 01:33:12.000
call the lower method of the string object and then compare the results.

01:33:12.000 --> 01:33:16.000
With this quit. You could also call this upper

01:33:16.000 --> 01:33:20.000
and then type quit in upper case. It's about our personal preference 

01:33:20.000 --> 01:33:24.000
in this demo I'm going to use lower case characters. 

01:33:24.000 --> 01:33:28.000
So, okay, now in this loop we need to ask the user to enter

01:33:28.000 --> 01:33:32.000
a command. So once again we're going to use our input function, we're going to add

01:33:32.000 --> 01:33:36.000
a greater then symbol followed by a space,

01:33:36.000 --> 01:33:40.000
whatever the user enters, we get it and store it in our

01:33:40.000 --> 01:33:44.000
command variable. Now apart from

01:33:44.000 --> 01:33:48.000
quit command, there are three other commands that we need to support. Start, 

01:33:48.000 --> 01:33:52.000
stop, and help. So here we need an if statement to compare

01:33:52.000 --> 01:33:56.000
what the user enters with one of the supported commands. 

01:33:56.000 --> 01:34:00.000
So, if command.lower

01:34:00.000 --> 01:34:04.000
equals start then you want to print the message 

01:34:04.000 --> 01:34:08.000
like the car started. So print the car started. 

01:34:08.000 --> 01:34:12.000
Ready to go, it doesn't matter, 

01:34:12.000 --> 01:34:16.000
now the second condition. What if its not start, maybe it's stop? So, 

01:34:16.000 --> 01:34:20.000
el if command.lower

01:34:20.000 --> 01:34:24.000
equals stop, there you go, then we print a 

01:34:24.000 --> 01:34:28.000
different message car stopped. Now look at our code.

01:34:28.000 --> 01:34:32.000
We have repeated this lower lower lower multiple times. 

01:34:32.000 --> 01:34:36.000
This is bad, in programming we have a term called dry, which is short for 

01:34:36.000 --> 01:34:40.000
don't repeat yourself. So whenever you have duplicate

01:34:40.000 --> 01:34:44.000
your code that means you're doing something wrong. So how can we solve this problem. 

01:34:44.000 --> 01:34:48.000
Well, instead of calling the lower method in each condition, 

01:34:48.000 --> 01:34:52.000
we can call it right here when we get the input from the user, so

01:34:52.000 --> 01:34:56.000
this input function as you know returns a string, we can

01:34:56.000 --> 01:35:00.000
immediately call the lower method on this string, and with this command 

01:35:00.000 --> 01:35:04.000
will always be in lowercase, so we don't need to

01:35:04.000 --> 01:35:08.000
call this method in every condition. Look, 

01:35:08.000 --> 01:35:12.000
we remove the duplication and also our conditions 

01:35:12.000 --> 01:35:16.000
are shorter and easier to read. There is also one more place 

01:35:16.000 --> 01:35:20.000
we need to modify so, it's right here. That is better. 

01:35:20.000 --> 01:35:24.000
Now, the third command. We need one more el if.

01:35:24.000 --> 01:35:28.000
If the command equals help, then, 

01:35:28.000 --> 01:35:32.000
we want to show the commands that we support. So, 

01:35:32.000 --> 01:35:36.000
here we're going to print a multi line string. So we

01:35:36.000 --> 01:35:40.000
use triple quotes like this, and 

01:35:40.000 --> 01:35:44.000
give the user a guideline like this. So start

01:35:44.000 --> 01:35:48.000
to start the car stop 

01:35:48.000 --> 01:35:52.000
to stop the car, and 

01:35:52.000 --> 01:35:56.000
quit to quit. Now finally we need 

01:35:56.000 --> 01:36:00.000
an else part, so if what the user enters is none of these commands, 

01:36:00.000 --> 01:36:04.000
we're going to tell them, hey we don't understand these, 

01:36:04.000 --> 01:36:08.000
else, colon print 

01:36:08.000 --> 01:36:12.000
sorry I don't understand that. 

01:36:12.000 --> 01:36:16.000
And by the way note that here becomes I'm using double

01:36:16.000 --> 01:36:20.000
quotes, I can easily use a single quote as an apostrophe, okay?

01:36:20.000 --> 01:36:24.000
So let's run our program up to this point and see what happens.

01:36:24.000 --> 01:36:28.000
Alright, let's type start car is 

01:36:28.000 --> 01:36:32.000
started, beautiful, stop, car is stopped, help, 

01:36:32.000 --> 01:36:36.000
we get this guideline, but there's so much indentation

01:36:36.000 --> 01:36:40.000
before our commands, we'll fix that in a second. And finally 

01:36:40.000 --> 01:36:44.000
let's test the quit command, oops, our program 

01:36:44.000 --> 01:36:48.000
didn't work properly. Here is the reason. With these if statements, 

01:36:48.000 --> 01:36:52.000
we're comparing the command with start stop, and 

01:36:52.000 --> 01:36:56.000
help. Anything else will end up here, so that's why our

01:36:56.000 --> 01:37:00.000
program says it doesn't understand that. So that's why our program 

01:37:00.000 --> 01:37:04.000
says it doesn't understand that command. However, after this el statement 

01:37:04.000 --> 01:37:08.000
the control will be moved to the beginning of the loop.

01:37:08.000 --> 01:37:12.000
At this point our command is quit, so our loop will complete and the

01:37:12.000 --> 01:37:16.000
program terminates. In other words when we run this program

01:37:16.000 --> 01:37:20.000
and type quit, our program actually quits but 

01:37:20.000 --> 01:37:24.000
we still see this message which shouldn't appear here. How can we solve this problem?

01:37:24.000 --> 01:37:28.000
Well, we can come back here and just before 

01:37:28.000 --> 01:37:32.000
the else block, add another el if, something like

01:37:32.000 --> 01:37:36.000
this. el if command equals 

01:37:36.000 --> 01:37:40.000
quit then you can immediately break. 

01:37:40.000 --> 01:37:44.000
This will solve our problem, but note that we have kind of repeated

01:37:44.000 --> 01:37:48.000
this expression in two places. The reality is that

01:37:48.000 --> 01:37:52.000
we don't really need this condition on the top, because with these if statements 

01:37:52.000 --> 01:37:56.000
well more accurately with this el if we can jump out of this loop and terminate 

01:37:56.000 --> 01:38:00.000
our program. So, we can simplify our condition

01:38:00.000 --> 01:38:04.000
to something like this. True. So while true means 

01:38:04.000 --> 01:38:08.000
this block of code is going to get executed repeatedly, 

01:38:08.000 --> 01:38:12.000
until we explicitly break out of it,

01:38:12.000 --> 01:38:16.000
okay? Now let's test our program one more time. So, 

01:38:16.000 --> 01:38:20.000
quit now our program terminates and we don't see that message 

01:38:20.000 --> 01:38:24.000
beautiful. So let's fix the last problem. You saw that when we 

01:38:24.000 --> 01:38:28.000
typed help, these guidelines appeared with so much in

01:38:28.000 --> 01:38:32.000
indentation, and here's the reason, look, right here in our code, 

01:38:32.000 --> 01:38:36.000
they are already indented. So when we use triple quotes, what we type here

01:38:36.000 --> 01:38:40.000
will be printed exactly as is. So, because we 

01:38:40.000 --> 01:38:44.000
have an indentation here, this indentation will also be printed on the terminal. 

01:38:44.000 --> 01:38:48.000
So, let's delete these

01:38:48.000 --> 01:38:52.000
okay, run the program one more time, type help, 

01:38:52.000 --> 01:38:56.000
the indentation is gone. Beautiful. Now here's a challenge for you. I want you to

01:38:56.000 --> 01:39:00.000
take this program to the next level. So right now if we type

01:39:00.000 --> 01:39:04.000
start we get this message car started. And if we type start again 

01:39:04.000 --> 01:39:08.000
we get the same message. It would be better if

01:39:08.000 --> 01:39:12.000
we got a message like car is already started so it doesn't make sense to

01:39:12.000 --> 01:39:16.000
start a car twice. Similarly, if we type stop

01:39:16.000 --> 01:39:20.000
it says car stopped, if we type it again we get the exact same

01:39:20.000 --> 01:39:24.000
message, it doesn't make sense to stop the car twice. So here's what I need you to do

01:39:24.000 --> 01:39:28.000
if the car is stopped and the user tries to stop it again, 

01:39:28.000 --> 01:39:32.000
the program should say hey, the car is already stopped, what are you doing? And similarly 

01:39:32.000 --> 01:39:36.000
if the car is already started and the user tries to start it again, 

01:39:36.000 --> 01:39:40.000
the program should yell at the user. So go ahead and make the necessary changes to

01:39:40.000 --> 01:39:44.000
implement this scenario. 

01:39:44.000 --> 01:39:48.000
Alright to add this to our program, we need 

01:39:48.000 --> 01:39:52.000
to know if the car is started or not. So there is one more piece of information

01:39:52.000 --> 01:39:56.000
we need to store in the memory. What is the kind of data we need to store here? 

01:39:56.000 --> 01:40:00.000
A boolean. Is the car started or not, it's a matter of yes 

01:40:00.000 --> 01:40:04.000
or no. True or false. So on the top, here

01:40:04.000 --> 01:40:08.000
we can define another variable like started and initially we set it

01:40:08.000 --> 01:40:12.000
to false. So the car is not started, right? Now

01:40:12.000 --> 01:40:16.000
when the user types the start command, here we need to check

01:40:16.000 --> 01:40:20.000
to see if the car is already started. If not the we'll start it 

01:40:20.000 --> 01:40:24.000
or otherwise we'll yell at the user. So in this block we'll write

01:40:24.000 --> 01:40:28.000
another if statement, if it's already started

01:40:28.000 --> 01:40:32.000
and we print car is already 

01:40:32.000 --> 01:40:36.000
started. Otherwise, so if you add an 

01:40:36.000 --> 01:40:40.000
el statement here. And at this point, 

01:40:40.000 --> 01:40:44.000
you set started to true. So we start 

01:40:44.000 --> 01:40:48.000
the car and we print this message, okay? Now we need to make a similar 

01:40:48.000 --> 01:40:52.000
change for the stop command. So if the car is

01:40:52.000 --> 01:40:56.000
already stopped we need to print a different message. If

01:40:56.000 --> 01:41:00.000
not started, so here we're using the not operator to see

01:41:00.000 --> 01:41:04.000
if the car is stopped. So if it's not started that means

01:41:04.000 --> 01:41:08.000
it's stopped, okay? So if it stopped we print

01:41:08.000 --> 01:41:12.000
car is already stopped with

01:41:12.000 --> 01:41:16.000
double p's, otherwise so else 

01:41:16.000 --> 01:41:20.000
we need to stop the car, how do we do that? We 

01:41:20.000 --> 01:41:24.000
set started to false. And then we'll print this message. 

01:41:24.000 --> 01:41:28.000
As easy as that. Let's go ahead and run our program. 

01:41:28.000 --> 01:41:32.000
So, initially our car is stopped. So I'm going to type 

01:41:32.000 --> 01:41:36.000
stop, it says the car is already stopped, so lets 

01:41:36.000 --> 01:41:40.000
start it, okay, now our car is started, let's

01:41:40.000 --> 01:41:44.000
start it one more time. The program is yelling at us. So we can

01:41:44.000 --> 01:41:48.000
not start the car twice. Beautiful. Now let's stop it

01:41:48.000 --> 01:41:52.000
it says the car is stopped, let's stop it one more time, we get this message 

01:41:52.000 --> 01:41:56.000
again. 

01:41:56.000 --> 01:42:00.000
In this tutorial, I'm going to talk to you guys about 

01:42:00.000 --> 01:42:04.000
for loops in python. In the last tutorial, you learned about while loops 

01:42:04.000 --> 01:42:08.000
you learned that we use while loops to execute a block of code multiple times. 

01:42:08.000 --> 01:42:12.000
In python we have another kind of loop, that is a for loop, and we use that

01:42:12.000 --> 01:42:16.000
and we use that to iterate over items of a collection, such as a string. 

01:42:16.000 --> 01:42:20.000
Because a string is a sequence of characters, so it looks like a collection 

01:42:20.000 --> 01:42:24.000
so we can use a for loop to iterate over each character in a 

01:42:24.000 --> 01:42:28.000
string and then do something with it. Here's an example. We type out

01:42:28.000 --> 01:42:32.000
for then we define a variable, this is what we call a loop

01:42:32.000 --> 01:42:36.000
variable. In each iteration, this variable will hold

01:42:36.000 --> 01:42:40.000
one item. So, let's call it item, in 

01:42:40.000 --> 01:42:44.000
here we type out a string like Python, and then 

01:42:44.000 --> 01:42:48.000
colon. So with this for loop we can iterate over a string and in each

01:42:48.000 --> 01:42:52.000
iteration this item variable will hold one character at a time

01:42:52.000 --> 01:42:56.000
in the first iteration it will be set to p then 

01:42:56.000 --> 01:43:00.000
in the second iteration it will be set to y, and in the third iteration it will be set to

01:43:00.000 --> 01:43:04.000
t and so on. So here we are inside our for block,

01:43:04.000 --> 01:43:08.000
because of the indentation here, so whatever we type here will be executed in

01:43:08.000 --> 01:43:12.000
each iteration, for now we can simply print this item 

01:43:12.000 --> 01:43:16.000
now let's run this program and see what happens.

01:43:16.000 --> 01:43:20.000
So you can see each character in this string is printed on 

01:43:20.000 --> 01:43:24.000
a new line. Let's look at another example. In Python we can

01:43:24.000 --> 01:43:28.000
define lists using square brackets, so let me remove this string from

01:43:28.000 --> 01:43:32.000
here, and define a list using square brackets, 

01:43:32.000 --> 01:43:36.000
a list is simply a list of items, a list of numbers, a list of 

01:43:36.000 --> 01:43:40.000
customers, a list of emails, products, blog posts, whatever. 

01:43:40.000 --> 01:43:44.000
So here we can define a list of names like Mosh, 

01:43:44.000 --> 01:43:48.000
Jon, Sarah, and then go ahead 

01:43:48.000 --> 01:43:52.000
and run our program so we can see in each iteration we get one name 

01:43:52.000 --> 01:43:56.000
and print it on a new line. We can also

01:43:56.000 --> 01:44:00.000
loop over a list of numbers, for example, 

01:44:00.000 --> 01:44:04.000
1, 2, 3, 4, let's run it, again

01:44:04.000 --> 01:44:08.000
we see each number on a new line, but what if we want

01:44:08.000 --> 01:44:12.000
a list of numbers? We don't to explicitly type out a list

01:44:12.000 --> 01:44:16.000
with let's say 100 or 1000 numbers, we don't want to type, 5, 6

01:44:16.000 --> 01:44:20.000
7 all the way to 100. That is when we use the range function. 

01:44:20.000 --> 01:44:24.000
So, let me delete this, 

01:44:24.000 --> 01:44:28.000
In Python we have a built in function called range, for creating

01:44:28.000 --> 01:44:32.000
range of numbers. So, we give it a number, let's say 10, 

01:44:32.000 --> 01:44:36.000
let's run this program, now we can see

01:44:36.000 --> 01:44:40.000
here on the terminal we have 0 all the way

01:44:40.000 --> 01:44:44.000
to 9. So 10 is not included. 

01:44:44.000 --> 01:44:48.000
So basically when we call the range function, this range creates

01:44:48.000 --> 01:44:52.000
an object, it's not a list, it's a special kind of object we can 

01:44:52.000 --> 01:44:56.000
iterate over, in each iteration this object will spit out a new number.

01:44:56.000 --> 01:45:00.000
We can also work with a  range of numbers here, let's say you want to start 

01:45:00.000 --> 01:45:04.000
from 5, and go all the way to 10. 

01:45:04.000 --> 01:45:08.000
So, let's run our program, now we have the numbers 

01:45:08.000 --> 01:45:12.000
5, 6, 7, and 9. Also, this range

01:45:12.000 --> 01:45:16.000
function can optionally take a step, so we can pass

01:45:16.000 --> 01:45:20.000
two asa step to this function, 

01:45:20.000 --> 01:45:24.000
and when we run our program, we can see our first number

01:45:24.000 --> 01:45:28.000
is 5, now we go two steps forward to get 7, 

01:45:28.000 --> 01:45:32.000
once again we go to two steps forward we get 9 and that is

01:45:32.000 --> 01:45:36.000
the end of our range. So this is the basics of using for loops in python. 

01:45:36.000 --> 01:45:40.000
Now here's an exercise for you. I want you to write a program 

01:45:40.000 --> 01:45:44.000
to calculate the total cost of all the items in a shopping cart. 

01:45:44.000 --> 01:45:48.000
So let's say we have a list of prices like 10, 

01:45:48.000 --> 01:45:52.000
20, and 30, I want you to use a for loop, 

01:45:52.000 --> 01:45:56.000
to calculate the total cost of all the items in our imaginary shopping cart, 

01:45:56.000 --> 01:46:00.000
so calculate that, and then print it on the terminal. That's pretty

01:46:00.000 --> 01:46:04.000
easy. And you should do it in a couple minutes. 

01:46:04.000 --> 01:46:08.000
So as you learned we use for 

01:46:08.000 --> 01:46:12.000
loops to iterate over all the items in a  collection, 

01:46:12.000 --> 01:46:16.000
a collection can be a string, it can be a list, it can be a range object that is

01:46:16.000 --> 01:46:20.000
returned from the range function. Anything, any kind of object that has multiple

01:46:20.000 --> 01:46:24.000
items. So in this example we're going to use a for loop to iterate over

01:46:24.000 --> 01:46:28.000
the list of prices. So for item in 

01:46:28.000 --> 01:46:32.000
prices, colon, and by the way this loop variable

01:46:32.000 --> 01:46:36.000
we don't have to call this item, can call this anything. For example, in this case

01:46:36.000 --> 01:46:40.000
we can rename it to price. So for price, 

01:46:40.000 --> 01:46:44.000
in prices. Now in each iteration this

01:46:44.000 --> 01:46:48.000
price will hold one value. In the first iteration it's going to hold 10, then it's

01:46:48.000 --> 01:46:52.000
gooing to be 20, and then it's going to be 30. So we need to define 

01:46:52.000 --> 01:46:56.000
another variable to calculate the total so

01:46:56.000 --> 01:47:00.000
we define that outside of our for loop, let's call it total

01:47:00.000 --> 01:47:04.000
and initially we set it to 0. Now in each

01:47:04.000 --> 01:47:08.000
iteration we get the current price and add it to the total so

01:47:08.000 --> 01:47:12.000
we write total equals total plus price 

01:47:12.000 --> 01:47:16.000
or as you learned earlier we can use the augmented 

01:47:16.000 --> 01:47:20.000
assignment operator to simplify this code. 

01:47:20.000 --> 01:47:24.000
So, after our for loop. This total variable has 

01:47:24.000 --> 01:47:28.000
a total of all the prices we can simply print it here, 

01:47:28.000 --> 01:47:32.000
or we can use a formatted string, so a string 

01:47:32.000 --> 01:47:36.000
prefix with f, the other label, like total, 

01:47:36.000 --> 01:47:40.000
curly braces to dynamically include some value in our string, 

01:47:40.000 --> 01:47:44.000
in this case our total variable. So let's go ahead 

01:47:44.000 --> 01:47:48.000
and run this program, there you go, so the total cost of

01:47:48.000 --> 01:47:52.000
all the items in our imaginary shopping cart is 60. 

01:47:56.000 --> 01:48:00.000
In this tutorial I'm going to talk to you guys about nested loops

01:48:00.000 --> 01:48:04.000
in python. Using a nested loop basically means adding one loop

01:48:04.000 --> 01:48:08.000
inside of another loop, and with this technique we can do some amazing things

01:48:08.000 --> 01:48:12.000
for example we can easily generate a list of coordinates. So, a

01:48:12.000 --> 01:48:16.000
acquired (?) as you know is a combination of x and y 

01:48:16.000 --> 01:48:20.000
value. Let's say 0 and 0. Now let's say you wan to generate

01:48:20.000 --> 01:48:24.000
a list of coordinates like this. So we have 0 and 0, 

01:48:24.000 --> 01:48:28.000
then we'll have 0 and 1, then 0 and 2, next

01:48:28.000 --> 01:48:32.000
we're going to change x, so we're going to use 1 for x, 

01:48:32.000 --> 01:48:36.000
and once again we're going to use these 3 values for the y coordinates

01:48:36.000 --> 01:48:40.000
so 1 and 0 then 1 and 1 

01:48:40.000 --> 01:48:44.000
and 1 and 2, you got the point. We can

01:48:44.000 --> 01:48:48.000
easily generate these coordinates using nested loops. Let me show you. 

01:48:48.000 --> 01:48:52.000
So, we start with one loop, let's say for x in

01:48:52.000 --> 01:48:56.000
range 4. With this loop, we can generate value 

01:48:56.000 --> 01:49:00.000
for the x coordinate. Let's print this on the terminal,

01:49:00.000 --> 01:49:04.000
Okay, so, we get the values, 0 

01:49:04.000 --> 01:49:08.000
to 3. Now for each x, like 0, we 

01:49:08.000 --> 01:49:12.000
should generate a few y values. So that is where we use

01:49:12.000 --> 01:49:16.000
a nested loop. So inside of this loop we're going to add

01:49:16.000 --> 01:49:20.000
another loop, so instead of just printing x first we want to add 

01:49:20.000 --> 01:49:24.000
another loop, for y in range 

01:49:24.000 --> 01:49:28.000
let's say 3, now we can print x and y together 

01:49:28.000 --> 01:49:32.000
so, print, here, we use a formatted string. 

01:49:32.000 --> 01:49:36.000
to display coordinates like this. So we add parenthesis 

01:49:36.000 --> 01:49:40.000
inside of this parenthesis first we need to add x so curly braces

01:49:40.000 --> 01:49:44.000
x then a comma followed by 

01:49:44.000 --> 01:49:48.000
another set of curly braces, and y, 

01:49:48.000 --> 01:49:52.000
let's run this program and see what we get. 

01:49:52.000 --> 01:49:56.000
There you go. So, we have these coordinates 

01:49:56.000 --> 01:50:00.000
0 and 0, 0 and 1, 0 and 2, then you have

01:50:00.000 --> 01:50:04.000
1 and 0 1 and 1 1 and 2 and so on. So let me explain exactly 

01:50:04.000 --> 01:50:08.000
how this program gets executed. So in the first iteration, 

01:50:08.000 --> 01:50:12.000
of our outer loop, x is 0. Now we are

01:50:12.000 --> 01:50:16.000
on line 2, here we have a new loop which we call an

01:50:16.000 --> 01:50:20.000
inner loop. In this inner loop, in the first iteration y 

01:50:20.000 --> 01:50:24.000
is going to be 0, so we print 0 and 0 on the

01:50:24.000 --> 01:50:28.000
terminal. Now the control goes back to line 2 or our

01:50:28.000 --> 01:50:32.000
inner loop. In this second iteration y will be set to 1, but

01:50:32.000 --> 01:50:36.000
we are still in the first iteration of our outer loop. So 

01:50:36.000 --> 01:50:40.000
x is still 0, but now y is incremented to 1. 

01:50:40.000 --> 01:50:44.000
So that is why we see 0 and 1 on the terminal. 

01:50:44.000 --> 01:50:48.000
Once again, the control goes back to line 2, we are in the third 

01:50:48.000 --> 01:50:52.000
iteration of our inner loop, so this will continue until our inner loop

01:50:52.000 --> 01:50:56.000
completes. That is when y reaches 2 because 

01:50:56.000 --> 01:51:00.000
this range function generates number 0 to 3 but not including 

01:51:00.000 --> 01:51:04.000
3. So we'll have 0 1 and 2. After this inner loop completes, 

01:51:04.000 --> 01:51:08.000
then the control goes back to line 1, and at this point we're going to

01:51:08.000 --> 01:51:12.000
be in the second iteration of our outer loop. So x will be 

01:51:12.000 --> 01:51:16.000
1, then the control will be moved to line 2, or our inner 

01:51:16.000 --> 01:51:20.000
loop, at this point, this range function is going to generate the numbers 0

01:51:20.000 --> 01:51:24.000
to 3 one more time. So this inner loop will be executed 3 times.

01:51:24.000 --> 01:51:28.000
And then we'll go back to our outer loop. So this is how

01:51:28.000 --> 01:51:32.000
nested loops get executed. 

01:51:32.000 --> 01:51:36.000
Okay, here's an exercise for you, but this one is a little bit 

01:51:36.000 --> 01:51:40.000
more challenging then the exercises you have done so far. So I really don't 

01:51:40.000 --> 01:51:44.000
expect you to do it, but if you do it, wow, I will be so proud of you, 

01:51:44.000 --> 01:51:48.000
so see what I've done here? Using nested loops, 

01:51:48.000 --> 01:51:52.000
I've written some code to draw this f shape, can you see that? So I

01:51:52.000 --> 01:51:56.000
let me give you a hint, first of all we have this

01:51:56.000 --> 01:52:00.000
list, called numbers, in this list we have these values, 

01:52:00.000 --> 01:52:04.000
5, 2, 5, 2, 5, 2. These values determine

01:52:04.000 --> 01:52:08.000
the number of x's we have in each line. So, 

01:52:08.000 --> 01:52:12.000
for example, the first item in this list, this tells us that we should have 

01:52:12.000 --> 01:52:16.000
5 x's on the first line. There you go, so 1, 2, 3, 

01:52:16.000 --> 01:52:20.000
4, 5, on the second line we're going to have 2 x's, 

01:52:20.000 --> 01:52:24.000
on the third line we're going to have 5 x's like this. 

01:52:24.000 --> 01:52:28.000
So I've written code to convert a simple list of numbers

01:52:28.000 --> 01:52:32.000
into a shape like this. Now here's a tip for you. 

01:52:32.000 --> 01:52:36.000
Using your for loop you need to iterate over this list. In

01:52:36.000 --> 01:52:40.000
each iteration you get one number, this determines the number of x's

01:52:40.000 --> 01:52:44.000
to be displayed on that particular line. So if you want to cheat, 

01:52:44.000 --> 01:52:48.000
you can get this number and multiply by a string that contains x, 

01:52:48.000 --> 01:52:52.000
so if you multiply x by 5, we'll get 5 x's, that's not what 

01:52:52.000 --> 01:52:56.000
I want you to do. I want you to use an inner loop here to 

01:52:56.000 --> 01:53:00.000
generate a string that contains 5 x's. So imagine 

01:53:00.000 --> 01:53:04.000
in Python we cannot multiply a string by a number

01:53:04.000 --> 01:53:08.000
so to solve this problem we need a nested loop. So go ahead and spend 

01:53:08.000 --> 01:53:12.000
five minutes on this exercise. And by the way, do your best to solve this. It is

01:53:12.000 --> 01:53:16.000
a little bit challenging, but it's not extremely difficult. It just requires

01:53:16.000 --> 01:53:20.000
a little bit of focus. You'll see my solution next. 

01:53:20.000 --> 01:53:24.000
Alright so first we need to iterate over

01:53:24.000 --> 01:53:28.000
all the items in this list. So for item 

01:53:28.000 --> 01:53:32.000
in numbers, or, you could rename this variable 

01:53:32.000 --> 01:53:36.000
to x_count. That is the number of x's

01:53:36.000 --> 01:53:40.000
on each line. Okay? Now I told you that if you want to cheat you can write code 

01:53:40.000 --> 01:53:44.000
like this. Print x times 

01:53:44.000 --> 01:53:48.000
x underline count. If you run this program we get the same 

01:53:48.000 --> 01:53:52.000
output. So this is the beauty of Python, with Python

01:53:52.000 --> 01:53:56.000
we can write expressions like this, we can multiply a string by a number to

01:53:56.000 --> 01:54:00.000
repeat it. A lot of other programming languages don't support this feature. But

01:54:00.000 --> 01:54:04.000
for this exercise, I wanted you to imagine that we don't have this feature in Python 

01:54:04.000 --> 01:54:08.000
so you will have to use an inner loop to solve this problem. Here's how

01:54:08.000 --> 01:54:12.000
it works. In the first iteration, x count is going to be 5.

01:54:12.000 --> 01:54:16.000
So we need to generate 5 x's. How can we do that?

01:54:16.000 --> 01:54:20.000
Well, let's say we define a variable called output and initially set it to

01:54:20.000 --> 01:54:24.000
an empty string. Now we need to add 5 x's to this string. So, 

01:54:24.000 --> 01:54:28.000
we can use another loop for count in range, 

01:54:28.000 --> 01:54:32.000
of x underline count. So we're using the range function

01:54:32.000 --> 01:54:36.000
to generate a sequence of numbers from 0 up to

01:54:36.000 --> 01:54:40.000
x count. So in our first iteration x count is going to be 5, so

01:54:40.000 --> 01:54:44.000
range of 5 would generate the numbers 1, 2, 3, 4. 

01:54:44.000 --> 01:54:48.000
So this inner loop will be executed 5 times. 

01:54:48.000 --> 01:54:52.000
That is exactly what this count represents. 

01:54:52.000 --> 01:54:56.000
So now in each iteration we simply need to

01:54:56.000 --> 01:55:00.000
append an x to our output variable. So we set

01:55:00.000 --> 01:55:04.000
output, plus, equals x, 

01:55:04.000 --> 01:55:08.000
and then after this inner loop we simply print 

01:55:08.000 --> 01:55:12.000
the output. With his we'll print 5 x's on 

01:55:12.000 --> 01:55:16.000
the first row. Then we go to the second iteration of our outer loop. 

01:55:16.000 --> 01:55:20.000
At this point x count is going to be 2, now

01:55:20.000 --> 01:55:24.000
on line 3, we're going to reset our output variable to an

01:55:24.000 --> 01:55:28.000
empty string. So we start over. Then we go to our inner loop, 

01:55:28.000 --> 01:55:32.000
this loop will be executed 2 times, so we'll append to x's 

01:55:32.000 --> 01:55:36.000
to the output variable and then print it, as simple as that. 

01:55:36.000 --> 01:55:40.000
So see, it wasn't really that difficult, but it was slightly more difficult then the

01:55:40.000 --> 01:55:44.000
previous exercises. So let's run this program, there you go. 

01:55:44.000 --> 01:55:48.000
Now if you're adventurous, I want you to modify the values that we have

01:55:48.000 --> 01:55:52.000
in our numbers list,

01:55:52.000 --> 01:55:56.000
to print and l here. 

01:56:00.000 --> 01:56:04.000
Now in this tutorial we're going to take a closer look at lists. 

01:56:04.000 --> 01:56:08.000
So, I'm going to define a list of names, let's send them

01:56:08.000 --> 01:56:12.000
to John Bob Mosh 

01:56:12.000 --> 01:56:16.000
Sarah and Mary. So, 

01:56:16.000 --> 01:56:20.000
if you print this list here, what we see on

01:56:20.000 --> 01:56:24.000
the terminal look exactly like how we define our lists we have

01:56:24.000 --> 01:56:28.000
square brackets, and in between these square brackets we have our item

01:56:28.000 --> 01:56:32.000
our items, so we have 5 strings in this list. 

01:56:32.000 --> 01:56:36.000
So we can also access an individual element using an index just like

01:56:36.000 --> 01:56:40.000
how we can access an individual character in a string using an index. 

01:56:40.000 --> 01:56:44.000
So, here we type out square brackets, 

01:56:44.000 --> 01:56:48.000
and specify an index. The index of the first item in this list 

01:56:48.000 --> 01:56:52.000
is 0. So, let's run this program, there you go, 

01:56:52.000 --> 01:56:56.000
we get Jon now if you want to print out the third element in this list

01:56:56.000 --> 01:57:00.000
it's index is 2, so names of 2, 

01:57:00.000 --> 01:57:04.000
returns Mosh, now we can also pass

01:57:04.000 --> 01:57:08.000
a negative index here, so negative 1, refers to the last item 

01:57:08.000 --> 01:57:12.000
in this list, that is Mary, let's run the program, 

01:57:12.000 --> 01:57:16.000
there you go, we see Mary, if you pass negative 2, this

01:57:16.000 --> 01:57:20.000
returns the second item from the end of the list. So let's run the program,

01:57:20.000 --> 01:57:24.000
there you go, we get sarah, so this is exactly like accessing 

01:57:24.000 --> 01:57:28.000
individual characters in a string. We can also

01:57:28.000 --> 01:57:32.000
use a colon to select a range of items, for example if 

01:57:32.000 --> 01:57:36.000
you pass 2 colon. This will get all items

01:57:36.000 --> 01:57:40.000
starting from the index of 2, that is Mosh here all the

01:57:40.000 --> 01:57:44.000
way to the end of the string. So let's run this program

01:57:44.000 --> 01:57:48.000
there you go. We get this list with 3 

01:57:48.000 --> 01:57:52.000
items, Mosh, Sarah, and Mary. We can also specify 

01:57:52.000 --> 01:57:56.000
an end index, let's say 4, so this will return all

01:57:56.000 --> 01:58:00.000
the items up to this index, but it doesn't include the item at this index.

01:58:00.000 --> 01:58:04.000
So when we run this program we only see Mosh and 

01:58:04.000 --> 01:58:08.000
Sarah, the item I've indexed 4which is the 5th element or

01:58:08.000 --> 01:58:12.000
5th item in this list is not returned. So Mary

01:58:12.000 --> 01:58:16.000
is not returned. And also here we have default values, so if you

01:58:16.000 --> 01:58:20.000
leave out the end index this expression is going to return 

01:58:20.000 --> 01:58:24.000
all the items starting from the index of 2, to the end of the list

01:58:24.000 --> 01:58:28.000
or if you leave out the start index, this expression asumes

01:58:28.000 --> 01:58:32.000
0 as the default index, so it will return all the items from the

01:58:32.000 --> 01:58:36.000
beginning to the end of the list. And by the way, 

01:58:36.000 --> 01:58:40.000
just like strings, these square brackets here, don't modify our

01:58:40.000 --> 01:58:44.000
original list, they simply return a new list. For example, if we pass

01:58:44.000 --> 01:58:48.000
2 here, you can see this returns a new list with 3 items. 

01:58:48.000 --> 01:58:52.000
So if you go back here and print our original 

01:58:52.000 --> 01:58:56.000
list of names right after you can see it's not affected. 

01:58:56.000 --> 01:59:00.000
So here we want to use square brackets with a colon to select a 

01:59:00.000 --> 01:59:04.000
range of items, we get a new list, and by the way we can also 

01:59:04.000 --> 01:59:08.000
modify any of the elements in this list. For example let's say we made a mistake and

01:59:08.000 --> 01:59:12.000
the first item shouldn't be john with an h, 

01:59:12.000 --> 01:59:16.000
so we want to remove the h, that is very easy, so we access it, 

01:59:16.000 --> 01:59:20.000
using an index that is names of 0, and we set it to a new value

01:59:20.000 --> 01:59:24.000
like this. Now, let's print our list 

01:59:24.000 --> 01:59:28.000
so, you can see the first item in this list 

01:59:28.000 --> 01:59:32.000
is now data. So this is the basics of lists. And here's a 

01:59:32.000 --> 01:59:36.000
exercise for you. I want you to write a program to find the largest number 

01:59:36.000 --> 01:59:40.000
in your list. This is a fantastic exercise for beginners, so go ahead and 

01:59:40.000 --> 01:59:44.000
spend a few minutes on this, then come back and continue watching. 

01:59:44.000 --> 01:59:48.000
Alright, let's

01:59:48.000 --> 01:59:52.000
define a list of numbers, numbers, with a bunch of random numbers

01:59:52.000 --> 01:59:56.000
3, 6, 2, 8, 4 and 10. 

01:59:56.000 --> 02:00:00.000
Now to find the largest number in this list. We need to define another 

02:00:00.000 --> 02:00:04.000
variable let's call it max, this variable will hold

02:00:04.000 --> 02:00:08.000
the largest number, now initially you want to assume 

02:00:08.000 --> 02:00:12.000
the first item in this list is the largest number. So we set max to

02:00:12.000 --> 02:00:16.000
numbers of 0. We're only assuming that the first item 

02:00:16.000 --> 02:00:20.000
is the largest number. Chances are our assumption is wrong. So we need

02:00:20.000 --> 02:00:24.000
to iterate over this list, we need to loop through it, get

02:00:24.000 --> 02:00:28.000
each item and compare it with max. If it's greater than Max, then

02:00:28.000 --> 02:00:32.000
we need to reset max to that number. So in the first iteration we get

02:00:32.000 --> 02:00:36.000
3, and max is also 3. Is 3 greater than

02:00:36.000 --> 02:00:40.000
3. No, so we move on, we get the second number, is 

02:00:40.000 --> 02:00:44.000
6, greater than 3? It is, so we need to reset max 

02:00:44.000 --> 02:00:48.000
to 6. Once again, we continue, we get 2, these two greater

02:00:48.000 --> 02:00:52.000
than 6, no it's not, so we move on, then we get 8, 

02:00:52.000 --> 02:00:56.000
is 8 greater than 6? It is, so we should reset max to 8. 

02:00:56.000 --> 02:01:00.000
That is pretty easy. So here we need a for loop, for

02:01:00.000 --> 02:01:04.000
number in numbers colon 

02:01:04.000 --> 02:01:08.000
now we need too heck to see if this number is greater than max, 

02:01:08.000 --> 02:01:12.000
so, if number is greater than max, 

02:01:12.000 --> 02:01:16.000
max colon then we need to reset max, so max

02:01:16.000 --> 02:01:20.000
to this new number, that's all we had to do.

02:01:20.000 --> 02:01:24.000
So, let's print max, and run our

02:01:24.000 --> 02:01:28.000
program we can see the largest number in this list is 10. 

02:01:28.000 --> 02:01:32.000
It doesn't matter whether this number is at the end of the list or the beginning. 

02:01:32.000 --> 02:01:36.000
So if I move 10 and put it right at the beginning 

02:01:36.000 --> 02:01:40.000
we should still see the same result. Let's run our program,

02:01:40.000 --> 02:01:44.000
we still see 10, if I put this somewhere in the middle, our

02:01:44.000 --> 02:01:48.000
program should still work. Let's put it right after 2. 

02:01:48.000 --> 02:01:52.000
Run the program, we still get 10. 

02:01:56.000 --> 02:02:00.000
In this tutorial I'm going to talk to you guys about two dimensional 

02:02:00.000 --> 02:02:04.000
lists in python. Two dimensional lists are extremely powerfully and they have a lot

02:02:04.000 --> 02:02:08.000
if applications in data science and machine learning. Here's

02:02:08.000 --> 02:02:12.000
an example, In math we have a concept called matrix, which is like

02:02:12.000 --> 02:02:16.000
a rectangular array of numbers, let me show you. So

02:02:16.000 --> 02:02:20.000
we have 1, 2, 3, 4, 5, 6, 7, 8, 9.

02:02:20.000 --> 02:02:24.000
So we have a rectangular array of numbers. You have rows, 

02:02:24.000 --> 02:02:28.000
and columns. So this is a 3 x 3 matrix 

02:02:28.000 --> 02:02:32.000
in math. Now we can model this in python using 

02:02:32.000 --> 02:02:36.000
a 2 dimensional list. A 2 dimensional list is a list where

02:02:36.000 --> 02:02:40.000
each item in that list is another list. So,

02:02:40.000 --> 02:02:44.000
you want to define a matrix. We set it to a list, each

02:02:44.000 --> 02:02:48.000
item in this list, is going to be another list, and that list represents 

02:02:48.000 --> 02:02:52.000
the items in each row. So, the first

02:02:52.000 --> 02:02:56.000
item in our list is going to be another list, and in this other list we're going to have

02:02:56.000 --> 02:03:00.000
the values 1, 2, and 3. Now the second 

02:03:00.000 --> 02:03:04.000
item in our matrix list, once again, we have a list, 

02:03:04.000 --> 02:03:08.000
this list represents the items in the second row. So, 

02:03:08.000 --> 02:03:12.000
4, 5, and 6, and finally 7, 8 

02:03:12.000 --> 02:03:16.000
9. So as you can see we have a 2 dimensional list

02:03:16.000 --> 02:03:20.000
Each item in our outer list is another list.

02:03:20.000 --> 02:03:24.000
 Okay? So, this is how we can implement a matrix in

02:03:24.000 --> 02:03:28.000
python, now to access an individual item in our matrix, 

02:03:28.000 --> 02:03:32.000
once again we use square brackets, let me delete this stuff, 

02:03:32.000 --> 02:03:36.000
alright, so how do we access 1 here, 

02:03:36.000 --> 02:03:40.000
well, you start with our list then we add square 

02:03:40.000 --> 02:03:44.000
brackets first we need to go and get the first item in this list. 

02:03:44.000 --> 02:03:48.000
Right? So we pass 0, now this expression 

02:03:48.000 --> 02:03:52.000
returns another list. That is the inner list. In this list, 

02:03:52.000 --> 02:03:56.000
let's say you want to access the second item, so, 

02:03:56.000 --> 02:04:00.000
once again we add square brackets, and we pass 1, that

02:04:00.000 --> 02:04:04.000
 is the index of 2 in this list, alright. 

02:04:04.000 --> 02:04:08.000
So if we print this on the terminal 

02:04:08.000 --> 02:04:12.000
we get 2. Okay? So using 2 square brackets 

02:04:12.000 --> 02:04:16.000
we can access individual items in our matrix, and 

02:04:16.000 --> 02:04:20.000
also we can modify these values using this syntax, so, 

02:04:20.000 --> 02:04:24.000
before printing this, let's change this to 20, so matrix

02:04:24.000 --> 02:04:28.000
of 0, and 1, let's change it to 20, 

02:04:28.000 --> 02:04:32.000
and then print it, there you go, it's modified, now here you

02:04:32.000 --> 02:04:36.000
can also use nested loops to iterate over all the items 

02:04:36.000 --> 02:04:40.000
in this matrix. Let me show you. So, 

02:04:40.000 --> 02:04:44.000
we start with a rows for the rows in matrix, 

02:04:44.000 --> 02:04:48.000
so with this loop, we are iterating over our Matrix

02:04:48.000 --> 02:04:52.000
list, in each iteration row will contain 1 

02:04:52.000 --> 02:04:56.000
list, 1 item, okay? Now, here we need to

02:04:56.000 --> 02:05:00.000
use an inner loop. So we need to loop over this row

02:05:00.000 --> 02:05:04.000
which is a list of items. We can type out 4 

02:05:04.000 --> 02:05:08.000
item in row colon and print 

02:05:08.000 --> 02:05:12.000
item. Okay? So, let's run this program, 

02:05:12.000 --> 02:05:16.000
there you go, we get all the item

02:05:16.000 --> 02:05:20.000
in our list. Hey, I just

02:05:20.000 --> 02:05:24.000
wanted to make a quick announcement. In case you haven't seen my website yet, head over to codewithmosh.com

02:05:24.000 --> 02:05:28.000
this is my coding school, where you can find plenty of courses

02:05:28.000 --> 02:05:32.000
on web and mobile application development. In fact recently I published a 

02:05:32.000 --> 02:05:36.000
comprehensive python course that goes way beyond this beginners 

02:05:36.000 --> 02:05:40.000
youtube. And if you're serious about learning python and getting a job, I highly encourage 

02:05:40.000 --> 02:05:44.000
you to enroll in this course. Just like this tutorial you can watch it anytime, 

02:05:44.000 --> 02:05:48.000
anywhere as many times as you want, and you will also receive a certificate 

02:05:48.000 --> 02:05:52.000
of completion that you can add to your resume, and the course comes with a 30 day

02:05:52.000 --> 02:05:56.000
money back guarantee, so if you're not happy we'll give all your money back, 

02:05:56.000 --> 02:06:00.000
no questions ask. The price for this course is 149 dollars, but

02:06:00.000 --> 02:06:04.000
the first 200 students can get it for only 15 dollars. So if you're interested, 

02:06:04.000 --> 02:06:08.000
the link is below this video, click the link, and get started.

02:06:08.000 --> 02:06:12.000
In this tutorial, I'm

02:06:12.000 --> 02:06:16.000
going to talk to you guys about the list methods, or list functions. These are the

02:06:16.000 --> 02:06:20.000
operations that we can perform in a list. So let's define 

02:06:20.000 --> 02:06:24.000
a list of numbers, here we pass a bunch of random numbers, like

02:06:24.000 --> 02:06:28.000
5, 2, 1, 7, and 

02:06:28.000 --> 02:06:32.000
4. Now there are a number of things we can do with this list, we can

02:06:32.000 --> 02:06:36.000
add new items to it, we can remove existing items, we can check for the existence of an item 

02:06:36.000 --> 02:06:40.000
these are the operations that we can perform on a list. So, 

02:06:40.000 --> 02:06:44.000
the we type numbers, we can see all these functions or more accurately 

02:06:44.000 --> 02:06:48.000
the methods that are available in our list objects. 

02:06:48.000 --> 02:06:52.000
So we can call the append method to add a new item to this list. Let's say

02:06:52.000 --> 02:06:56.000
13. Actually, no it's not a good number. 

02:06:56.000 --> 02:07:00.000
I'm joking I'm not superstitious, so let's add 20, it

02:07:00.000 --> 02:07:04.000
doesn't really matter and then print our list 

02:07:04.000 --> 02:07:08.000
when we run the program we can see 20 is added at the end of this list 

02:07:08.000 --> 02:07:12.000
but what if you want to add a number somewhere in the middle, or at the beginning

02:07:12.000 --> 02:07:16.000
of our list? For that we use a different method, that is called

02:07:16.000 --> 02:07:20.000
insert. So, insert, now this method

02:07:20.000 --> 02:07:24.000
takes 2 values, let me show you. So when we open parenthesis 

02:07:24.000 --> 02:07:28.000
look at this little tool tip above the insert method. 

02:07:28.000 --> 02:07:32.000
You see the first value that we need to pass here is an index, so

02:07:32.000 --> 02:07:36.000
this is the index at which we want to insert this new item. Let's

02:07:36.000 --> 02:07:40.000
say we want to add an item at the beginning of our list, so we passed our index position 

02:07:40.000 --> 02:07:44.000
of 0, and then the second value is the actual 

02:07:44.000 --> 02:07:48.000
object we want to add to this list. Let's say we want to add the number 10, 

02:07:48.000 --> 02:07:52.000
now when we print this list you can see that the

02:07:52.000 --> 02:07:56.000
number 10 is placed at the beginning of the list and 

02:07:56.000 --> 02:08:00.000
all the other items are pushed to the right. We can also remove an item so

02:08:00.000 --> 02:08:04.000
we call remove and pass the item that

02:08:04.000 --> 02:08:08.000
we want to remove 5. Now we

02:08:08.000 --> 02:08:12.000
print our list so we see 5 is gone, and we have

02:08:12.000 --> 02:08:16.000
2, 1, 7, 4. If you want to remove all the items in the list, you can call

02:08:16.000 --> 02:08:20.000
the clear method, so, clear 

02:08:20.000 --> 02:08:24.000
this method doesn't take any values, so, we simply

02:08:24.000 --> 02:08:28.000
call it and it empties our list, all the items are removed. 

02:08:28.000 --> 02:08:32.000
We also have another useful method called hop, 

02:08:32.000 --> 02:08:36.000
and with this we can remove the last item in a list. 

02:08:36.000 --> 02:08:40.000
Let me show you. So, we run our program, you can see the number 4

02:08:40.000 --> 02:08:44.000
is removed from the end of our list. Now if you want to

02:08:44.000 --> 02:08:48.000
check for the existence of an item in our list, you can call the index method. 

02:08:48.000 --> 02:08:52.000
So, we call index and pass a value here, like 5

02:08:52.000 --> 02:08:56.000
and this returns the index of the first 

02:08:56.000 --> 02:09:00.000
occurrence of this item. So let's print this on the terminal. 

02:09:00.000 --> 02:09:04.000
We don't need this line anymore. So the

02:09:04.000 --> 02:09:08.000
index of 5 is 0. What if we pass a number that doesn't exist

02:09:08.000 --> 02:09:12.000
in this list? Let's say 50? Run the program,

02:09:12.000 --> 02:09:16.000
we get an error. We get a value error. 50 is not

02:09:16.000 --> 02:09:20.000
in the list. There is also another way to check for the existence of an item, 

02:09:20.000 --> 02:09:24.000
we can use the in operator. So, let me show you

02:09:24.000 --> 02:09:28.000
we type our 15 in numbers, 

02:09:28.000 --> 02:09:32.000
earlier we used the in operator with a string, we

02:09:32.000 --> 02:09:36.000
check for the existence of a character or a sequence of a character in a string,

02:09:36.000 --> 02:09:40.000
now here we're checking for the existence of 50 in the list of numbers, so

02:09:40.000 --> 02:09:44.000
let's print this, we get a boolean value, 

02:09:44.000 --> 02:09:48.000
false, so unlike the index method, this expression, 

02:09:48.000 --> 02:09:52.000
doesn't generate an error, so it's safer to use this. We also have another

02:09:52.000 --> 02:09:56.000
method for counting the occurances of an item, let's say we have 

02:09:56.000 --> 02:10:00.000
another 5 over here. 

02:10:00.000 --> 02:10:04.000
Now we can call numbers.count and pass 5

02:10:04.000 --> 02:10:08.000
and this should return 2 because we have 2 5s in this list.

02:10:08.000 --> 02:10:12.000
Take a look. There you go. That is pretty useful

02:10:12.000 --> 02:10:16.000
now if you want to sort your lists you can call sort method. So,

02:10:16.000 --> 02:10:20.000
we call the sort method here, this method doesn't take any values so, 

02:10:20.000 --> 02:10:24.000
look at he return value, that is none, none

02:10:24.000 --> 02:10:28.000
is an object in python that represents the absence of a value.

02:10:28.000 --> 02:10:32.000
So this sort method doesn't really return any values it simply sorts this

02:10:32.000 --> 02:10:36.000
list, in place, so instead of printing the return value

02:10:36.000 --> 02:10:40.000
oft his method, we simply call it to sort our list

02:10:40.000 --> 02:10:44.000
and then print our list. Take a look. 

02:10:44.000 --> 02:10:48.000
Now, all the items are assorted in ascending order. We can also

02:10:48.000 --> 02:10:52.000
sort the items in descending order, so after we sort the list 

02:10:52.000 --> 02:10:56.000
we can call the reverse method. We can simply reverse

02:10:56.000 --> 02:11:00.000
our list. Now let's go ahead and run our program, take a look.

02:11:00.000 --> 02:11:04.000
Our numbers are sorted in descending order. 

02:11:04.000 --> 02:11:08.000
And one last method I want to show you here that is pretty useful is the copy

02:11:08.000 --> 02:11:12.000
method. So copy, with this method you can get a copy 

02:11:12.000 --> 02:11:16.000
of our list. So let's define another variable called numbers 2, 

02:11:16.000 --> 02:11:20.000
now numbers 2, is a copy of our original list. So if

02:11:20.000 --> 02:11:24.000
you make any changes to our original list, if you add new items to it, if you remove 

02:11:24.000 --> 02:11:28.000
existing items, these operations are not going to impact our second list. 

02:11:28.000 --> 02:11:32.000
Let me show you. So after we show you a copy of our numbers list

02:11:32.000 --> 02:11:36.000
let's add a new item to this list, so numbers.apphend 

02:11:36.000 --> 02:11:40.000
ten. So the first list is updated, so now we have a 

02:11:40.000 --> 02:11:44.000
new item in our first list, then lets print the second list.

02:11:44.000 --> 02:11:48.000
Take a look, we don't have the number 10 here, because these are

02:11:48.000 --> 02:11:52.000
2 independent lists. So these are all the operations 

02:11:52.000 --> 02:11:56.000
that we can perform on lists. We can add new items to a list, we can

02:11:56.000 --> 02:12:00.000
remove exxisitn items, we can check for the existence of an item, we can sort 

02:12:00.000 --> 02:12:04.000
our list, and copy them. Now here's an exercise for this tutorial, 

02:12:04.000 --> 02:12:08.000
I want you to write a program, to remove the duplicates on our list. 

02:12:08.000 --> 02:12:12.000
Again, this is a fantastic exercise. So spend a few minutes on this and then

02:12:12.000 --> 02:12:16.000
come back and continue watching. 

02:12:16.000 --> 02:12:20.000
Alright let's say we have a list of numbers with

02:12:20.000 --> 02:12:24.000
a bunch of duplicates. So 2, 2, 4, 6, 

02:12:24.000 --> 02:12:28.000
6, 3, 4, 6, 1. We want to remove

02:12:28.000 --> 02:12:32.000
the duplicates. So we need to define another list

02:12:32.000 --> 02:12:36.000
let's call that new list. Initially we

02:12:36.000 --> 02:12:40.000
set it to an empty list. Then we need to iterate over

02:12:40.000 --> 02:12:44.000
our first list, get each item, and if we don't have that number

02:12:44.000 --> 02:12:48.000
in this unix list, then we'll add it to this second list. 

02:12:48.000 --> 02:12:52.000
As simple as that. So, for number 

02:12:52.000 --> 02:12:56.000
in numbers, now we need to check to see if we

02:12:56.000 --> 02:13:00.000
have this number in the second list. So we use the in

02:13:00.000 --> 02:13:04.000
operator. If number not 

02:13:04.000 --> 02:13:08.000
in units

02:13:08.000 --> 02:13:12.000
so if we don't have an operator in this units list,

02:13:12.000 --> 02:13:16.000
then we'll need to add it, so units.

02:13:16.000 --> 02:13:20.000
apphend number, that's all we have to do.

02:13:20.000 --> 02:13:24.000
So, let's go ahead and print the units list

02:13:24.000 --> 02:13:28.000
there you go. So you have 2, 4, 

02:13:28.000 --> 02:13:32.000
6, 3,and 1. The duplicates are removed. 

02:13:36.000 --> 02:13:40.000
In this tutorial I'm going to talk to you guys about another important structure. 

02:13:40.000 --> 02:13:44.000
in Python called tuple. Tuples are similar to lists

02:13:44.000 --> 02:13:48.000
so we can use them to store a list of items. But unlike lists we can

02:13:48.000 --> 02:13:52.000
not modify them, we cannot add new items, we cannot remove existing items, we

02:13:52.000 --> 02:13:56.000
tuples are immutable. We cannot mutate or change them. So

02:13:56.000 --> 02:14:00.000
let me show you. So I'm going to start by defining a list of numbers, 

02:14:00.000 --> 02:14:04.000
1, 2, 3, 4, so we use square brackets to define lists and 

02:14:04.000 --> 02:14:08.000
parenthesis to define tuples, so if we change this to

02:14:08.000 --> 02:14:12.000
parenthesis, 1, 2, 3. Now we have a 

02:14:12.000 --> 02:14:16.000
tuple. So if we type numbers.

02:14:16.000 --> 02:14:20.000
look here we don't have the append or insert methods, so we cannot add new items to this tuple.

02:14:20.000 --> 02:14:24.000
We also don't have remove clear and pop, we cannot

02:14:24.000 --> 02:14:28.000
remove any of these items here. We only have two methods, count, 

02:14:28.000 --> 02:14:32.000
and index. We use count to count the number of occurrences in an item, 

02:14:32.000 --> 02:14:36.000
and index, to find the index of the first occurrence, 

02:14:36.000 --> 02:14:40.000
of an item. So we can only get information about a tuple, we can't change it. 

02:14:40.000 --> 02:14:44.000
And by the way, these other methods that you see here, they start

02:14:44.000 --> 02:14:48.000
with two underscores, we refer to these as magic methods, they're more of an advanced

02:14:48.000 --> 02:14:52.000
topic, so they go beyond the scope of this tutorial. If you're interested

02:14:52.000 --> 02:14:56.000
to learn bout them. You can get my python course, I've covered them in detail.

02:14:56.000 --> 02:15:00.000
So similar to lists you can address individual items using

02:15:00.000 --> 02:15:04.000
squre bracketts,s o we can get the first item like this and then

02:15:04.000 --> 02:15:08.000
print another terminal, there you go, the first item is 1, 

02:15:08.000 --> 02:15:12.000
but if you try to change the first item we'll get an error, so, 

02:15:12.000 --> 02:15:16.000
numbers of 0, we set it to 10 and run our program 

02:15:16.000 --> 02:15:20.000
there you go. We get this type error, because the tuple object

02:15:20.000 --> 02:15:24.000
does not support item assignment. So we cannot 

02:15:24.000 --> 02:15:28.000
mutate or change tuples, they are immutable. Now practically 

02:15:28.000 --> 02:15:32.000
speaking, most of the time you'll be using lists, but tuples are also

02:15:32.000 --> 02:15:36.000
useful. If you want to create a list of items and make sure 

02:15:36.000 --> 02:15:40.000
no where in your program you accidentally modify that list, then it's better to

02:15:40.000 --> 02:15:44.000
use a tuple, 

02:15:44.000 --> 02:15:48.000
In this tutorial I'm going to show you a powerful

02:15:48.000 --> 02:15:52.000
feature we have in python called unpacking.

02:15:52.000 --> 02:15:56.000
 So lets find a tuple called coordinates

02:15:56.000 --> 02:16:00.000
and here we pass 3 values, 1, 2, 3. So you imagine these are

02:16:00.000 --> 02:16:04.000
the coordinates for x y and z. Now let's say

02:16:04.000 --> 02:16:08.000
we want to get these values and use them in a few expressions, a few complex

02:16:08.000 --> 02:16:12.000
expressions in our program. Maybe we want to include them as part of a large

02:16:12.000 --> 02:16:16.000
complex formula. So together we'll have to write code like this,

02:16:16.000 --> 02:16:20.000
coordinates of 0, then let's say we want to multiply this

02:16:20.000 --> 02:16:24.000
by coordinates of 1, and then multiply it by coordinates 

02:16:24.000 --> 02:16:28.000
of 2, our code is getting a little bit too long, this is just

02:16:28.000 --> 02:16:32.000
a very simple example. But let's say we want to use these values in quite a few places 

02:16:32.000 --> 02:16:36.000
in our program, a better approach is to get these values

02:16:36.000 --> 02:16:40.000
and store them in separate variables like we can get

02:16:40.000 --> 02:16:44.000
coordinates of 0, and store it in x, then you can

02:16:44.000 --> 02:16:48.000
get coordinates of 1 and store it in y. 

02:16:48.000 --> 02:16:52.000
And similarly we get coordinates of 2, 

02:16:52.000 --> 02:16:56.000
and then store it in z. Now we started repeating coordinates of

02:16:56.000 --> 02:17:00.000
2 or coordinates of 0 multiple times, we can simply work with these

02:17:00.000 --> 02:17:04.000
variables, x times y times z, that is better. 

02:17:04.000 --> 02:17:08.000
Right? So nothing new so far. But in Python we have a powerful

02:17:08.000 --> 02:17:12.000
feature called unpacking and with that we can achieve 

02:17:12.000 --> 02:17:16.000
the same result with far less code. So we can define our variables 

02:17:16.000 --> 02:17:20.000
x, y, and z. And set them to our

02:17:20.000 --> 02:17:24.000
tuple. What we have on line 6 is exactly

02:17:24.000 --> 02:17:28.000
identical to what we have on lines 2-4.

02:17:28.000 --> 02:17:32.000
So this is a shorthand to achieve the same result.

02:17:32.000 --> 02:17:36.000
So let me delete this and explain how this code works.

02:17:36.000 --> 02:17:40.000
When Python interpreter sees this statement, it will get the

02:17:40.000 --> 02:17:44.000
first item in this tuple and assign it to the

02:17:44.000 --> 02:17:48.000
variable. Then it will get the second item in this tuple, then

02:17:48.000 --> 02:17:52.000
similarly we get the third item in this tuple and assign it to

02:17:52.000 --> 02:17:56.000
the third variable we have here, so we are unpacking

02:17:56.000 --> 02:18:00.000
this tuple into 3 variables. Now if we

02:18:00.000 --> 02:18:04.000
print x you can see x 

02:18:04.000 --> 02:18:08.000
is 1, similarly y is 2, there you go. 

02:18:08.000 --> 02:18:12.000
So this is unpacking. And by the way this is not

02:18:12.000 --> 02:18:16.000
limited to tuples, we can use this feature for lists as well. So,

02:18:16.000 --> 02:18:20.000
if I change parenthesis to square brackets, now 

02:18:20.000 --> 02:18:24.000
coordinates is a list, so we can unpack our list into 3 variables 

02:18:24.000 --> 02:18:28.000
now we run our program we can see y is 2.

02:18:32.000 --> 02:18:36.000
In this tutorial I'm going to talk to you about dictionary 

02:18:36.000 --> 02:18:40.000
in python. We use dictionaries in situations where we want to

02:18:40.000 --> 02:18:44.000
store information that comes as key value pairs. Here's

02:18:44.000 --> 02:18:48.000
an example. Think of a customer. A customer has a bunch of attributes

02:18:48.000 --> 02:18:52.000
like name, email, phone number, address

02:18:52.000 --> 02:18:56.000
and so on. Now each of these attributes has a value. 

02:18:56.000 --> 02:19:00.000
For example the name can be jon smith the email can be

02:19:00.000 --> 02:19:04.000
jon@ gmail.com the phone can be whatevr

02:19:04.000 --> 02:19:08.000
so what we have ere is a bunch of key value pairs. So in this

02:19:08.000 --> 02:19:12.000
example, our keys are name, email, and phone, 

02:19:12.000 --> 02:19:16.000
and each key is associated with a value. So this is where we use 

02:19:16.000 --> 02:19:20.000
a dictionary. With a dictionary, we can store a bunch of key value pairs. 

02:19:20.000 --> 02:19:24.000
So let me show you how to define a dictionary in python. 

02:19:24.000 --> 02:19:28.000
Back to our program, I'm going to define a variable, customer, 

02:19:28.000 --> 02:19:32.000
and here we set it to curly braces. With these curly braces we can

02:19:32.000 --> 02:19:36.000
define dictionary. In this example we have an empty dictionary that doesn't have

02:19:36.000 --> 02:19:40.000
any key value pairs. Now we can add one or more key

02:19:40.000 --> 02:19:44.000
value pairs in between the braces. So let's

02:19:44.000 --> 02:19:48.000
add a key value pair here, I'm going to set the key to a  name, and 

02:19:48.000 --> 02:19:52.000
the value to John Smith, then we add a comma,

02:19:52.000 --> 02:19:56.000
to add another key value pair. So let's set age to 

02:19:56.000 --> 02:20:00.000
30 let's add another key value pair is 

02:20:00.000 --> 02:20:04.000
underline verified and we set this to a boolean.

02:20:04.000 --> 02:20:08.000
Now what matters here is that these keys should be

02:20:08.000 --> 02:20:12.000
unique. So if I add another key value pair here, 

02:20:12.000 --> 02:20:16.000
set age to 40, now look pycharm

02:20:16.000 --> 02:20:20.000
has highlighted the age key, because we have duplicated that and

02:20:20.000 --> 02:20:24.000
that's not allowed. So each key should be unique in a dictionary, just like, 

02:20:24.000 --> 02:20:28.000
the dictionaries we have in the real world, in a real dictionary we have a bunch of words 

02:20:28.000 --> 02:20:32.000
and they're definition each word is only listed once in a dictionary.

02:20:32.000 --> 02:20:36.000
We don't have the word book twice. So let's delete the second

02:20:36.000 --> 02:20:40.000
duplicate key value pair, so the keys should be unique,

02:20:40.000 --> 02:20:44.000
and in this example, I'm using strings, but they can also be

02:20:44.000 --> 02:20:48.000
numbers, we're going to look at that later, but the value can be anything, it can be

02:20:48.000 --> 02:20:52.000
a string, a  number, a boolean, a list, literally anything.

02:20:52.000 --> 02:20:56.000
Now we can access each item in this dictionary 

02:20:56.000 --> 02:21:00.000
using square brackets. So, we type customer, 

02:21:00.000 --> 02:21:04.000
square brackets and then specify key like name

02:21:04.000 --> 02:21:08.000
and this will return the value associated with

02:21:08.000 --> 02:21:12.000
the name key. Let's print it on the terminal, have a look,

02:21:12.000 --> 02:21:16.000
there you go, so, the name is John Smith, now

02:21:16.000 --> 02:21:20.000
what if we pass a key that doesn't exist, lets say first date.

02:21:20.000 --> 02:21:24.000
You run the program, you get a key error because we don't have

02:21:24.000 --> 02:21:28.000
a key called birth date. Also, if we spell

02:21:28.000 --> 02:21:32.000
name with let's say a capital N, we get the same

02:21:32.000 --> 02:21:36.000
error because we don't have a key with the exact same sequence of

02:21:36.000 --> 02:21:40.000
characters in this dictionary. Now to get around this we can

02:21:40.000 --> 02:21:44.000
use the get method, so instead of using the square brackets 

02:21:44.000 --> 02:21:48.000
we call the get method and specify the key

02:21:48.000 --> 02:21:52.000
Now if you use a key that doesn't exist here, it doesn't yell at us. For example, 

02:21:52.000 --> 02:21:56.000
if you pass birth date

02:21:56.000 --> 02:22:00.000
it simply returns the non value. Earlier I told you that none is an object

02:22:00.000 --> 02:22:04.000
that represents the absence of a value. So

02:22:04.000 --> 02:22:08.000
instead of getting a key error we get none and we can also option

02:22:08.000 --> 02:22:12.000
supply a default value, for example, if this dictionary doesn't have this

02:22:12.000 --> 02:22:16.000
key, we can supply the default value, let's say

02:22:16.000 --> 02:22:20.000
January 1st 1980. Let's run the program 

02:22:20.000 --> 02:22:24.000
now instead of getting none we get this default value. 

02:22:24.000 --> 02:22:28.000
So, this is how we can access the value associated with the key

02:22:28.000 --> 02:22:32.000
in a dictionary. We can also update these values for example 

02:22:32.000 --> 02:22:36.000
before a print statement we can write code like this, customer of

02:22:36.000 --> 02:22:40.000
name, let's update the name to jack 

02:22:40.000 --> 02:22:44.000
smith, now this little warning is telling us here we can put jac

02:22:44.000 --> 02:22:48.000
smith here instead of defining it once, and then update

02:22:48.000 --> 02:22:52.000
it. Don't worry about them, it doesn't really matter. Now with this line if 

02:22:52.000 --> 02:22:56.000
we print the name of this customer, we should see jack smith, let me show you.

02:22:56.000 --> 02:23:00.000
So, I'm going to use the square bracket notation again, let's print

02:23:00.000 --> 02:23:04.000
the name of the customer you can see that is updated here, 

02:23:04.000 --> 02:23:08.000
we can also add a new key here, let's set the

02:23:08.000 --> 02:23:12.000
birthdate to some value like january first

02:23:12.000 --> 02:23:16.000
1980. And then we can print it here, 

02:23:16.000 --> 02:23:20.000
so as you see we can easily add new key value pairs

02:23:20.000 --> 02:23:24.000
to a dictionary. So this is the basics of using dictionaries

02:23:24.000 --> 02:23:28.000
in python. They're extremely important and they have a lot of applications in the real

02:23:28.000 --> 02:23:32.000
world. Okay, here's an exercise for you. So here we have

02:23:32.000 --> 02:23:36.000
this program that asks our phone number. Let's type 1

02:23:36.000 --> 02:23:40.000
234. We type it in digits and then this will translate

02:23:40.000 --> 02:23:44.000
it, to words, take a look. Enter, it prints, 1, 2, 3, 

02:23:44.000 --> 02:23:48.000
4. That's a pretty cool program, so go ahead and

02:23:48.000 --> 02:23:52.000
spend a few minutes on this exercise, it's pretty easy, I will see you

02:23:52.000 --> 02:23:56.000
next. 

02:23:56.000 --> 02:24:00.000
Alright, so first we need to get the users phone number, we call the input function 

02:24:00.000 --> 02:24:04.000
with the label phone, we get the result and store it

02:24:04.000 --> 02:24:08.000
in this variable, now let's say the user enters 123

02:24:08.000 --> 02:24:12.000
4. So we need to look through this string, get each character and 

02:24:12.000 --> 02:24:16.000
translate it to a world, so what we need to implement this scenario.

02:24:16.000 --> 02:24:20.000
is a dictionary, because a dictionary is a structure that allows us to

02:24:20.000 --> 02:24:24.000
a key to a value. So we can have a dictionary with keys

02:24:24.000 --> 02:24:28.000
like 1234. And we map each of these keys

02:24:28.000 --> 02:24:32.000
to a word. So we cannot put digit 1 to

02:24:32.000 --> 02:24:36.000
the word 1 we can map 2 

02:24:36.000 --> 02:24:40.000
to two you get the point. So let's define 

02:24:40.000 --> 02:24:44.000
a dictionary, you can call it digits, underline mapping

02:24:44.000 --> 02:24:48.000
now this dictionary I'm going to add a few key value pairs. 

02:24:48.000 --> 02:24:52.000
One, we map it to 1, 2, we 

02:24:52.000 --> 02:24:56.000
to 2, 3, to 3, 

02:24:56.000 --> 02:25:00.000
and finally, 4 to 4. Now technically we should

02:25:00.000 --> 02:25:04.000
add all the digits from 0 to 9, but I don't want to waste all your time 

02:25:04.000 --> 02:25:08.000
typing repetitive things here, you got the point. So lets move on,

02:25:08.000 --> 02:25:12.000
now we need to look through the phone string. So 

02:25:12.000 --> 02:25:16.000
4 character in phone, we get each

02:25:16.000 --> 02:25:20.000
character and then use it to access a key value pair in

02:25:20.000 --> 02:25:24.000
dictionary. So, digits underline mapping

02:25:24.000 --> 02:25:28.000
we can use square brackets or call the get method, 

02:25:28.000 --> 02:25:32.000
I would prefer to use the get method, so in case the user enters some character

02:25:32.000 --> 02:25:36.000
that is not part of our dictionary, our program is not going to yell at them.

02:25:36.000 --> 02:25:40.000
So, we call the gt method and pass this character

02:25:40.000 --> 02:25:44.000
a the key, and if we don't have this key, we can supply

02:25:44.000 --> 02:25:48.000
a default value like exclamation mark, so with this we get a word

02:25:48.000 --> 02:25:52.000
now we need to add this word to an output string, so we can define

02:25:52.000 --> 02:25:56.000
an output string, initially we set it to an empty string, 

02:25:56.000 --> 02:26:00.000
in each iteration we get this and add it to our output string. 

02:26:00.000 --> 02:26:04.000
So, we type output, plus equals. 

02:26:04.000 --> 02:26:08.000
This and we should also add a 

02:26:08.000 --> 02:26:12.000
space at get. So the words are not close to each other, okay?

02:26:12.000 --> 02:26:16.000
That's all we have to do. Now finally let's print

02:26:16.000 --> 02:26:20.000
this output, run our program, so I want to

02:26:20.000 --> 02:26:24.000
type 1, 3,4, 5, lets 

02:26:24.000 --> 02:26:28.000
see what we get. We get 1, 3, 4 with an exlamantion

02:26:28.000 --> 02:26:32.000
mark. 

02:26:32.000 --> 02:26:36.000
In this tutorial I'm going to show you something really cool

02:26:36.000 --> 02:26:40.000
that you can do with dictionaries, so here in this program you can type

02:26:40.000 --> 02:26:44.000
a message like good morning followed by a smiley face,

02:26:44.000 --> 02:26:48.000
when we press enter, we get this beautiful smiley face, or

02:26:48.000 --> 02:26:52.000
we can type i am sad, with a  sad smiley face

02:26:52.000 --> 02:26:56.000
and it gets translated to this beautiful emoji. 

02:26:56.000 --> 02:27:00.000
So this is another application if using dictionaries, we have a dictionary 

02:27:00.000 --> 02:27:04.000
that maps these characters into smiley faces. 

02:27:04.000 --> 02:27:08.000
So lets go ahead and build this program together, we start by

02:27:08.000 --> 02:27:12.000
calling the input function, here we pass a greater than symbol

02:27:12.000 --> 02:27:16.000
as an indicator for the user to type a message, we give that message, store

02:27:16.000 --> 02:27:20.000
it here, as you know that is a string, now we need to

02:27:20.000 --> 02:27:24.000
split this string by a space, so if the user types

02:27:24.000 --> 02:27:28.000
good morning with a smiley face, we want to break this down into

02:27:28.000 --> 02:27:32.000
3 words, good morning, and smiley face. 

02:27:32.000 --> 02:27:36.000
To do that we can call the split method. So we call

02:27:36.000 --> 02:27:40.000
message.split and pass 

02:27:40.000 --> 02:27:44.000
a string with one space as a separator. What this method

02:27:44.000 --> 02:27:48.000
does is basically it goes through this string and anywhere it finds this

02:27:48.000 --> 02:27:52.000
character, in this case a space, it uses it as a boundary to

02:27:52.000 --> 02:27:56.000
separate this string into multiple words. And then it will return

02:27:56.000 --> 02:28:00.000
a list. Let me show you. So let's store that here, words, and then

02:28:00.000 --> 02:28:04.000
Then print it on the terminal, 

02:28:04.000 --> 02:28:08.000
let's go ahead and run our program. So if you type good morning 

02:28:08.000 --> 02:28:12.000
sunshine, enter, we get a list with three items 

02:28:12.000 --> 02:28:16.000
each item is a string, okay? Now, 

02:28:16.000 --> 02:28:20.000
back to our program, we need to define a dictionary for mapping special characters

02:28:20.000 --> 02:28:24.000
like these 2 into a smiley face, so, 

02:28:24.000 --> 02:28:28.000
we can call that emojis 

02:28:28.000 --> 02:28:32.000
set it to curly braces, here we add a key value pair, 

02:28:32.000 --> 02:28:36.000
a smiley face, and we map that to a string, 

02:28:36.000 --> 02:28:40.000
in this string we want to add an emoji, if you're on a mac keyboard you can press 

02:28:40.000 --> 02:28:44.000
control command and space and this should bring up

02:28:44.000 --> 02:28:48.000
this emoji box, if you're on Windows honestly I

02:28:48.000 --> 02:28:52.000
really don't know how you can do this, but there must be applications who do this for you. So lets go

02:28:52.000 --> 02:28:56.000
ahead and pick this happy smiley face, good, 

02:28:56.000 --> 02:29:00.000
now lets add another key value pair, or sad face

02:29:00.000 --> 02:29:04.000
we map this to, 

02:29:04.000 --> 02:29:08.000
this face here, good. So, we 

02:29:08.000 --> 02:29:12.000
have a list of words now we need to look through this list, get

02:29:12.000 --> 02:29:16.000
each word and potentially map it to an emoji.

02:29:16.000 --> 02:29:20.000
So we can write a for loop for word in words, 

02:29:20.000 --> 02:29:24.000
now we want to go to our dictionary, and see if you have an item with this

02:29:24.000 --> 02:29:28.000
word as the key. If you have an item with that key, we get

02:29:28.000 --> 02:29:32.000
it's value, otherwise we want to use the same word. So if a user types

02:29:32.000 --> 02:29:36.000
good morning, we don't want to translate those words, we just want to return those. So that is the case, 

02:29:36.000 --> 02:29:40.000
where we use the get method to supply a  default 

02:29:40.000 --> 02:29:44.000
value, so we wan to get an item with a key word, and

02:29:44.000 --> 02:29:48.000
if we don't have an item with that key, we simply use that word as 

02:29:48.000 --> 02:29:52.000
the default value. Now similar to the exercise that we did in the last tutorial 

02:29:52.000 --> 02:29:56.000
we need an output variable. So let's define that here, 

02:29:56.000 --> 02:30:00.000
output set it to an empty string, now back to line

02:30:00.000 --> 02:30:04.000
9, we get the return value of the get method, 

02:30:04.000 --> 02:30:08.000
and add it to our output variable. So output 

02:30:08.000 --> 02:30:12.000
plus equals whatever we get from the get method, and finally 

02:30:12.000 --> 02:30:16.000
we need to append a space at the end. 

02:30:16.000 --> 02:30:20.000
That's it, we're done. So let's print the output 

02:30:20.000 --> 02:30:24.000
and run our program and I'm going to type good morning

02:30:24.000 --> 02:30:28.000
sunshine with a smiley face, we get that 

02:30:28.000 --> 02:30:32.000
beautiful, let's try the sad face as well, I am sad. 

02:30:32.000 --> 02:30:36.000
Too bad. Beautiful! So as you can see

02:30:36.000 --> 02:30:40.000
dictionaries have a lot of use cases in real applications.

02:30:44.000 --> 02:30:48.000
Here's a solution from the last tutorial where we created an emoji 

02:30:48.000 --> 02:30:52.000
converter. Now so far we have been writing all our code right here,

02:30:52.000 --> 02:30:56.000
in app,py, but as our programs grow we need a better way to organize our code. 

02:30:56.000 --> 02:31:00.000
We need to break up our code into smaller, more manageable 

02:31:00.000 --> 02:31:04.000
and more maintainable chunks which we call functions. So function 

02:31:04.000 --> 02:31:08.000
is a container for a few lines of code that perform a specific 

02:31:08.000 --> 02:31:12.000
task for example you have learned about a few of the built in functions in

02:31:12.000 --> 02:31:16.000
python like print, and input, each of these functions 

02:31:16.000 --> 02:31:20.000
have a purpose, they know how to perform a specific task. So when we 

02:31:20.000 --> 02:31:24.000
build large complex programs, we should break up our code into smaller 

02:31:24.000 --> 02:31:28.000
reusable chunks which we call functions to better organize our code.

02:31:28.000 --> 02:31:32.000
And that's what I'm going to show you in this tutorial. So let's write this simple 

02:31:32.000 --> 02:31:36.000
program, for printing a greeting message. So we're going to do a print, 

02:31:36.000 --> 02:31:40.000
hi there, and lets add another message 

02:31:40.000 --> 02:31:44.000
welcome aboard. So here we have a simple 

02:31:44.000 --> 02:31:48.000
program with only two lines of code. Now let's say these two lines 

02:31:48.000 --> 02:31:52.000
potentially we're going to need them in other programs so we can put them in a function that

02:31:52.000 --> 02:31:56.000
we can reuse. Let me show you how to do that, so, 

02:31:56.000 --> 02:32:00.000
we start typing out death, that is a reserve keyword in

02:32:00.000 --> 02:32:04.000
 Python, and it's short for define. When Python interpreter sees this it

02:32:04.000 --> 02:32:08.000
knows that we're defining a function, next we need to give our function 

02:32:08.000 --> 02:32:12.000
a name, lets say greet_user.

02:32:12.000 --> 02:32:16.000
So all the best practices you learned about naming your variables also apply here, 

02:32:16.000 --> 02:32:20.000
which means we should name our functions with lower case characters 

02:32:20.000 --> 02:32:24.000
if there are multiple words, we need to separate them using an underscore 

02:32:24.000 --> 02:32:28.000
and you should always, always, always use meaningful

02:32:28.000 --> 02:32:32.000
descriptive names for your functions. So, here we define a function

02:32:32.000 --> 02:32:36.000
called greet user, after that we'll need to add parenthesis 

02:32:36.000 --> 02:32:40.000
followed by a colon. Now you know that whenever we add a colon at the end of a line

02:32:40.000 --> 02:32:44.000
we're telling python that we're defining a block of code. So when we 

02:32:44.000 --> 02:32:48.000
press enter, the next line is indented. Now any code that we write here

02:32:48.000 --> 02:32:52.000
will belong to this function. So I'm going to move these two lines

02:32:52.000 --> 02:32:56.000
these two print statements inside of our function. You can simply 

02:32:56.000 --> 02:33:00.000
press tab to indent them, beautiful, also lets remove

02:33:00.000 --> 02:33:04.000
this extra line break, that is better, so these two lines

02:33:04.000 --> 02:33:08.000
now are part of our greet user function, so whenever we 

02:33:08.000 --> 02:33:12.000
call this function, these two lines will be executed. Okay? Now, 

02:33:12.000 --> 02:33:16.000
let's remove indentation so here we are outside of our function, 

02:33:16.000 --> 02:33:20.000
let's do a print statement and print start

02:33:20.000 --> 02:33:24.000
after that let's call our function, so greet user.

02:33:24.000 --> 02:33:28.000
And finally let's do another create statement and print

02:33:28.000 --> 02:33:32.000
finish. Now we have this little warning here, this

02:33:32.000 --> 02:33:36.000
underline, if you hover your mouse over this line, this tool was telling you

02:33:36.000 --> 02:33:40.000
that we should add two blank lines after a function definition. This is coming from

02:33:40.000 --> 02:33:44.000
pep8 which is a document that defines the best practices for

02:33:44.000 --> 02:33:48.000
formatting our code. We'll look at that in the future. So for now to make pycharm

02:33:48.000 --> 02:33:52.000
happy, lets add an extra line break to this function

02:33:52.000 --> 02:33:56.000
so whenever we define a function we need to add two lines breaks after.

02:33:56.000 --> 02:34:00.000
Okay? so, now let's run our program and see what happens.

02:34:00.000 --> 02:34:04.000
Alright, so we have 4 messages on the terminal 

02:34:04.000 --> 02:34:08.000
first we get the start message then we get the messages

02:34:08.000 --> 02:34:12.000
 coming from our create function, so either and welcome aboard, and finally we see

02:34:12.000 --> 02:34:16.000
the finished message. So let me explain the flow of our program 

02:34:16.000 --> 02:34:20.000
when python runs this code it doesn't actually print these

02:34:20.000 --> 02:34:24.000
two messages on the terminal because these two lines of code are inside

02:34:24.000 --> 02:34:28.000
of this function, so they would only get executed if we call

02:34:28.000 --> 02:34:32.000
this function. If we don't call this function, these lines don't get executed. 

02:34:32.000 --> 02:34:36.000
Okay? So the execution of our program actually starts here,

02:34:36.000 --> 02:34:40.000
the first message that we see on the terminal is the start message. After

02:34:40.000 --> 02:34:44.000
that, Python sees that we are calling the greet function, so

02:34:44.000 --> 02:34:48.000
it will jump over here and then execute these two lines.

02:34:48.000 --> 02:34:52.000
Then, it will jump out of this function and continue the normal

02:34:52.000 --> 02:34:56.000
execution of our program so it will print the finish message on the terminal.

02:34:56.000 --> 02:35:00.000
So this is how functions work. Also note that the order of this

02:35:00.000 --> 02:35:04.000
code matters, so here we're calling the greet function after

02:35:04.000 --> 02:35:08.000
after we have defined it. If you try and call it before you define it you will see an error.

02:35:08.000 --> 02:35:12.000
For example, if we call the greet

02:35:12.000 --> 02:35:16.000
user function right here, see we immediately get this red underline

02:35:16.000 --> 02:35:20.000
which says unresolved reference, greet user which basically

02:35:20.000 --> 02:35:24.000
 means python doesn't know what is this greet user, it's not defined anywhere. 

02:35:24.000 --> 02:35:28.000
So we always define our functions first, and then 

02:35:28.000 --> 02:35:32.000
call them. 

02:35:32.000 --> 02:35:36.000
Here's a function we created in the last tutorial

02:35:36.000 --> 02:35:40.000
now I got a question for you, what is the difference between

02:35:40.000 --> 02:35:44.000
calling this functions nd the print function of python? The difference 

02:35:44.000 --> 02:35:48.000
is that the print function takes some information, in this case 

02:35:48.000 --> 02:35:52.000
the message that we want to print, but our greet function doesn't take 

02:35:52.000 --> 02:35:56.000
any information. Wouldn't it be nicer if you could pass the name of the user here and then

02:35:56.000 --> 02:36:00.000
instead of saying hi there, you could print the name of the user. So, 

02:36:00.000 --> 02:36:04.000
in this tutorial, I'm going to show you how to pass information to your functions, and 

02:36:04.000 --> 02:36:08.000
that is pretty easy, so back to the definition of our greet

02:36:08.000 --> 02:36:12.000
user function, inside of these parenthesis, we can add parameters

02:36:12.000 --> 02:36:16.000
these parameters are pale holders for receiving information. 

02:36:16.000 --> 02:36:20.000
For example, you can add a name parameter, and we can pass the

02:36:20.000 --> 02:36:24.000
name of the user when calling this function. So let's pass Jon

02:36:24.000 --> 02:36:28.000
here, now when we call this function and pass this value

02:36:28.000 --> 02:36:32.000
this name parameter will be set to Jon. So it

02:36:32.000 --> 02:36:36.000
will act like a local variable that we defined inside of this function. 

02:36:36.000 --> 02:36:40.000
Just imagine, we didn't have this parameter, and instead we had 

02:36:40.000 --> 02:36:44.000
a variable like name that was set to jump. Now here we could simply 

02:36:44.000 --> 02:36:48.000
print the name of this user, so we could use a formatted string, 

02:36:48.000 --> 02:36:52.000
and print the value of the name variable, right? Now, 

02:36:52.000 --> 02:36:56.000
we don't really have this local variable defined in this function

02:36:56.000 --> 02:37:00.000
we have a parameter, it's exactly the same thing. So 

02:37:00.000 --> 02:37:04.000
with these parameters we can receive information in our functions. Now let's go ahead and

02:37:04.000 --> 02:37:08.000
run this program, so take a look. 

02:37:08.000 --> 02:37:12.000
We get Hi John welcome aboard, we can take this to the next 

02:37:12.000 --> 02:37:16.000
level. Now we can call this function one more time. So 

02:37:16.000 --> 02:37:20.000
greet user, and this time supply a different name. Let's say Mary. 

02:37:20.000 --> 02:37:24.000
So we are reusing our greet function and passing it a different

02:37:24.000 --> 02:37:28.000
value. Imagine if we didn't have this function you would have to 

02:37:28.000 --> 02:37:32.000
repeat this line twice , once for hi jon and another time for hi mary. 

02:37:32.000 --> 02:37:36.000
So this is the benefit of defining functions, we can take a few

02:37:36.000 --> 02:37:40.000
lines of code that have a specific purpose and put them inside of a 

02:37:40.000 --> 02:37:44.000
function, so now let's run our program one more time

02:37:44.000 --> 02:37:48.000
there you go. So you get hi job, welcome aboard, then you get hi mary

02:37:48.000 --> 02:37:52.000
welcome aboard. Now note that when a function has a parameter 

02:37:52.000 --> 02:37:56.000
we are obligated to pass a value for that parameter. 

02:37:56.000 --> 02:38:00.000
So if you remove jon from here and run 

02:38:00.000 --> 02:38:04.000
our program, we get this type error, greet user, 

02:38:04.000 --> 02:38:08.000
missing one required positional argument. 

02:38:08.000 --> 02:38:12.000
Argument in programming is the value that we supply to a function, so

02:38:12.000 --> 02:38:16.000
back to this example, marrying this case is an

02:38:16.000 --> 02:38:20.000
argument that we pass to the name parameter. And lot of

02:38:20.000 --> 02:38:24.000
programmers don't know the difference between parameters and arguments and think they are the same. 

02:38:24.000 --> 02:38:28.000
But they are not, parameters are the holes or placeholders

02:38:28.000 --> 02:38:32.000
that we define in our function for receiving information, 

02:38:32.000 --> 02:38:36.000
arguments are the actual pieces of information that we supply to these functions. 

02:38:36.000 --> 02:38:40.000
Okay? So, let's bring back 

02:38:40.000 --> 02:38:44.000
this jon string, now we can also define multiple 

02:38:44.000 --> 02:38:48.000
parameters, for example, let's rename this parameter to first name as I told 

02:38:48.000 --> 02:38:52.000
you before, you can right click here, go to refactor and then 

02:38:52.000 --> 02:38:56.000
rename, or preferably you can use a short cut. So the shortcut for

02:38:56.000 --> 02:39:00.000
this on Mac is shift and f6. 

02:39:00.000 --> 02:39:04.000
And this brings up the renamed dial up box, here we can change this to first 

02:39:04.000 --> 02:39:08.000
underline name. Now we can add a second parameter 

02:39:08.000 --> 02:39:12.000
so comma followed by last underline name 

02:39:12.000 --> 02:39:16.000
so back to our formatted string, let's also print 

02:39:16.000 --> 02:39:20.000
the last name, beautiful, so here when calling this function, 

02:39:20.000 --> 02:39:24.000
then we can supply another argument so jon

02:39:24.000 --> 02:39:28.000
smith and lets delete this line we don't really need it anymore 

02:39:28.000 --> 02:39:32.000
run our program, take a look, hi jon smith, 

02:39:36.000 --> 02:39:40.000
so in the last tutorial you learned that whenever 

02:39:40.000 --> 02:39:44.000
we define parameters for our functions we should always supply 

02:39:44.000 --> 02:39:48.000
values otherwise we'll get an error. Let's look at that error one more time.

02:39:48.000 --> 02:39:52.000
So In going to delete this second argument and only pass jon. 

02:39:52.000 --> 02:39:56.000
Run our program, we get this message, 

02:39:56.000 --> 02:40:00.000
greet user missing one required, position 

02:40:00.000 --> 02:40:04.000
argument. So these arguments that you have here like jon 

02:40:04.000 --> 02:40:08.000
and smith you refer to these as positional arguments. 

02:40:08.000 --> 02:40:12.000
Which means their position or argument matters. In other

02:40:12.000 --> 02:40:16.000
words, the first argument we add here is the value or the first parameter 

02:40:16.000 --> 02:40:20.000
and the second argument is the value for the second parameter. 

02:40:20.000 --> 02:40:24.000
So if you change their position or order, we'll get different results. 

02:40:24.000 --> 02:40:28.000
Let's take a look. Let's pass smith first and then

02:40:28.000 --> 02:40:32.000
jon. Okay, good, delete, now let's

02:40:32.000 --> 02:40:36.000
go with this, so instead of getting Hi Jon Smith, 

02:40:36.000 --> 02:40:40.000
we get hi smith jon. So that is the reason we refer

02:40:40.000 --> 02:40:44.000
to these arguments as positional arguments, they're positioned or

02:40:44.000 --> 02:40:48.000
order matters. But in python we also have keyword arguments, and 

02:40:48.000 --> 02:40:52.000
with those the position doesn't matter. Let me show you how they work. So, 

02:40:52.000 --> 02:40:56.000
let's say here you want to pass Jon as the value for the first 

02:40:56.000 --> 02:41:00.000
name parameter. We can simply specify that here. So first name 

02:41:00.000 --> 02:41:04.000
equals jon. Now what we have here is a keyword argument. 

02:41:04.000 --> 02:41:08.000
the key word argument. So this combination of having the parameter name,

02:41:08.000 --> 02:41:12.000
followed by it's value is what we call a keyword argument, and what we get with this keyword

02:41:12.000 --> 02:41:16.000
argument the position doesn't really matter. So here we're supplying

02:41:16.000 --> 02:41:20.000
Jon as an argument fort he first parameter. Now similarly, 

02:41:20.000 --> 02:41:24.000
we can use a keyword argument for smith, so last

02:41:24.000 --> 02:41:28.000
name equals smith, so that we have 2 

02:41:28.000 --> 02:41:32.000
keyword arguments. So with these keyword arguments we don't have to worry about

02:41:32.000 --> 02:41:36.000
the order of the parameters. Now that doesn't mean we should always use keyword arguments. 

02:41:36.000 --> 02:41:40.000
Not really. Most of the time we use positional arguments, but

02:41:40.000 --> 02:41:44.000
in certain situations these keyword arguments helming us improve 

02:41:44.000 --> 02:41:48.000
the readability of our code. So on line 7 it's quite clear

02:41:48.000 --> 02:41:52.000
that we are supplying smith as the last name and jon

02:41:52.000 --> 02:41:56.000
as the first name. Now in this particular example, even if we didn't have

02:41:56.000 --> 02:42:00.000
the keyword arguments, just passing two positional arguments like jon 

02:42:00.000 --> 02:42:04.000
and smith, would be sufficient, because it's easy to guess

02:42:04.000 --> 02:42:08.000
what is the purpose of these arguments. But sometimes you're dealing with functions

02:42:08.000 --> 02:42:12.000
and you're passing numerical values to them, in those situations

02:42:12.000 --> 02:42:16.000
it may not be quite clear what those values represent. Let me show you an example.

02:42:16.000 --> 02:42:20.000
Let's say we have a function for calculating the total cost of an order, 

02:42:20.000 --> 02:42:24.000
so we still call that calculate, underline cost, 

02:42:24.000 --> 02:42:28.000
so when calling this function, you need to supply three pieces of information.

02:42:28.000 --> 02:42:32.000
One is the total cost of all the order items lets say 50

02:42:32.000 --> 02:42:36.000
dollars. The other is the shipping cost, let's say 

02:42:36.000 --> 02:42:40.000
5 dollars, and the last piece is discount, let's say 0, 

02:42:40.000 --> 02:42:44.000
.1. Someone reading this code, may not be sure 

02:42:44.000 --> 02:42:48.000
what these three values represent, in this case, we can improve

02:42:48.000 --> 02:42:52.000
the readability of this code, by using keyword arguments. So we can

02:42:52.000 --> 02:42:56.000
prefix each value with the name of parameter they target, for example, 

02:42:56.000 --> 02:43:00.000
we can set total to 50 and then

02:43:00.000 --> 02:43:04.000
shipping to 5, and then discount to 0.1. 

02:43:04.000 --> 02:43:08.000
Now if you give this code to someone else, they

02:43:08.000 --> 02:43:12.000
can immediately tell what these values represent. So that is the power 

02:43:12.000 --> 02:43:16.000
of keyword arguments. So here's what I want you to take away.

02:43:16.000 --> 02:43:20.000
For the most part, use positional arguments, but if you're dealing with

02:43:20.000 --> 02:43:24.000
functions that take numerical values, see if you can improve the

02:43:24.000 --> 02:43:28.000
readability of your code by using keyword arguments. You simply 

02:43:28.000 --> 02:43:32.000
prefix the arguments that you pass with the name of their parameters and this will 

02:43:32.000 --> 02:43:36.000
increase the readability of your code. Now there is one more thing you need to know about

02:43:36.000 --> 02:43:40.000
keyword arguments. These keyword arguments should always come after

02:43:40.000 --> 02:43:44.000
positional arguments. Let me show you what I mean. So, 

02:43:44.000 --> 02:43:48.000
back to our simple greet user function, let's use a keyword argument 

02:43:48.000 --> 02:43:52.000
for the first thing. So, let's set 

02:43:52.000 --> 02:43:56.000
first name to jon and see what happens. So we immediately get this error and 

02:43:56.000 --> 02:44:00.000
positional argument after keyword argument. 

02:44:00.000 --> 02:44:04.000
So when calling this function we're supplying one keyword argument 

02:44:04.000 --> 02:44:08.000
and one positional argument, and python doesn't like this. So, 

02:44:08.000 --> 02:44:12.000
if you're mixing positional and keyword arguments, you should always use

02:44:12.000 --> 02:44:16.000
and then the keyword arguments. 

02:44:16.000 --> 02:44:20.000
In other words, lets remove this keyword argument here, 

02:44:20.000 --> 02:44:24.000
so jon is now a positional argument, is targeting the first

02:44:24.000 --> 02:44:28.000
parameter. Now after this positional argument we can

02:44:28.000 --> 02:44:32.000
supply any number of keyword arguments, so if you set last name to smith

02:44:32.000 --> 02:44:36.000
look, python doesn't have any problem with this because we are adding 

02:44:36.000 --> 02:44:40.000
a keyword argument after a positional argument.

02:44:40.000 --> 02:44:44.000
So let's quickly recap, for the most part use positional arguments 

02:44:44.000 --> 02:44:48.000
if you're dealing with functions that take multiple numerical values 

02:44:48.000 --> 02:44:52.000
and it's not quite clear what those values represent, use keyword arguments 

02:44:52.000 --> 02:44:56.000
to improve the readability of your code, and finally if

02:44:56.000 --> 02:45:00.000
your passing both positional and keyword arguments, use the

02:45:00.000 --> 02:45:04.000
keyword arguments after the positional arguments. 

02:45:08.000 --> 02:45:12.000
So far you have learned how to create functions and send them information using

02:45:12.000 --> 02:45:16.000
their parameters in this tutorial I'm going to show you how to create functions that return 

02:45:16.000 --> 02:45:20.000
values, this is particularly useful if you're doing some kind of

02:45:20.000 --> 02:45:24.000
calculation your function and you want to return the result to whoever is using your

02:45:24.000 --> 02:45:28.000
function. let me show you. So let's start by defining a 

02:45:28.000 --> 02:45:32.000
function, called square, this function simply calculates

02:45:32.000 --> 02:45:36.000
the square of a number. So we need to add one parameter here, 

02:45:36.000 --> 02:45:40.000
that is is our number, now here we want to calculate number 

02:45:40.000 --> 02:45:44.000
times number, that is the square of a number. 

02:45:44.000 --> 02:45:48.000
Now to return this color outside of this function we simply 

02:45:48.000 --> 02:45:52.000
use the return statement. So return. Now, 

02:45:52.000 --> 02:45:56.000
our square function is very simple, it only had one line of code. 

02:45:56.000 --> 02:46:00.000
But in a real program, you might have a function that has ten lines of code to calculate

02:46:00.000 --> 02:46:04.000
something. So, this return statement is very

02:46:04.000 --> 02:46:08.000
valuable. So now we can return values to the caller of our function. 

02:46:08.000 --> 02:46:12.000
So, with this, when we call the square function, 

02:46:12.000 --> 02:46:16.000
let's say we give it 3, now this function returns a value, 

02:46:16.000 --> 02:46:20.000
just like an input function of python, this input function 

02:46:20.000 --> 02:46:24.000
waits for the user to type something and press enter and then it will

02:46:24.000 --> 02:46:28.000
return the user's input as a string so we can get it

02:46:28.000 --> 02:46:32.000
and store it in a variable like this, right? We have the same story with our

02:46:32.000 --> 02:46:36.000
story, with our square function. So our square function returns the value

02:46:36.000 --> 02:46:40.000
we can simply get it and store it in a variable. Let's call that

02:46:40.000 --> 02:46:44.000
result. Now, we can print 

02:46:44.000 --> 02:46:48.000
result on the terminal, there you go, so result is 9, 

02:46:48.000 --> 02:46:52.000
we could also pass this function called

02:46:52.000 --> 02:46:56.000
directly inside of the print function without defining a separate variable.

02:46:56.000 --> 02:47:00.000
Sometimes this is useful for writing shorter code, so in this case. 

02:47:00.000 --> 02:47:04.000
So, in this case, we don't really need this result variable. We simply want to print 

02:47:04.000 --> 02:47:08.000
the square of 3. So, we could simply pass this function 

02:47:08.000 --> 02:47:12.000
call right here, as an argument for the print 

02:47:12.000 --> 02:47:16.000
function. So let's delete this variable now our code is

02:47:16.000 --> 02:47:20.000
shorter so with this we're calling the square function, this returns a 

02:47:20.000 --> 02:47:24.000
value and we'll pass that value as an argument to the print function. 

02:47:24.000 --> 02:47:28.000
Okay? When we run this program, we get the exact same 

02:47:28.000 --> 02:47:32.000
result. There you go. Now what happens if we don't 

02:47:32.000 --> 02:47:36.000
use a return statement in our function. So in the last example we simply used

02:47:36.000 --> 02:47:40.000
a print statement. Let's temporarily remove 

02:47:40.000 --> 02:47:44.000
this return statement and print the result

02:47:44.000 --> 02:47:48.000
on the terminal. Like this. So let's run our program 

02:47:48.000 --> 02:47:52.000
one more time and see what we get. We see two things, the number

02:47:52.000 --> 02:47:56.000
9, and none. What is happening here? Well

02:47:56.000 --> 02:48:00.000
when Python interpreter executes this code, first it will call

02:48:00.000 --> 02:48:04.000
the square function. So the control moves to the square function 

02:48:04.000 --> 02:48:08.000
here we calculate the square of this given number and then print it

02:48:08.000 --> 02:48:12.000
on the terminal. That is the reason we see 9 right here, 

02:48:12.000 --> 02:48:16.000
now, by default, all functions return the value 

02:48:16.000 --> 02:48:20.000
none. So if we don't have a return statement 

02:48:20.000 --> 02:48:24.000
here, by default python returns none. None

02:48:24.000 --> 02:48:28.000
is an object that represents the absence of a value, it's like nothing 

02:48:28.000 --> 02:48:32.000
or null i c, c++ java and Javascript. 

02:48:32.000 --> 02:48:36.000
So, in this example, we didn't have a return statement, and 

02:48:36.000 --> 02:48:40.000
by default python returned none from this function. 

02:48:40.000 --> 02:48:44.000
So, after this square function is executed, the value none 

02:48:44.000 --> 02:48:48.000
is returned and passed as an argument to the print function, that is the reason 

02:48:48.000 --> 02:48:52.000
we see none on the second line. So here are the two things

02:48:52.000 --> 02:48:56.000
you need to take away from this tutorial. By default all functions in Python 

02:48:56.000 --> 02:49:00.000
return none. You can change that, so if you have a function that 

02:49:00.000 --> 02:49:04.000
calculates something, you can return the result using the return statement. 

02:49:08.000 --> 02:49:12.000
Here's the code for our emoji converter program that we wrote earlier. 

02:49:12.000 --> 02:49:16.000
If you missed that tutorial, make sure to go back and watch it, as 

02:49:16.000 --> 02:49:20.000
I told you before, there is a table of content right below this video in the

02:49:20.000 --> 02:49:24.000
description. So we can simply click on the emoji converter tutorial to watch it. 

02:49:24.000 --> 02:49:28.000
Now, your exercise is to reorganize this code using a function. 

02:49:28.000 --> 02:49:32.000
So I want you to extract a function in this code, because this algorithm

02:49:32.000 --> 02:49:36.000
for converting these smiley faces into emoji's is something that

02:49:36.000 --> 02:49:40.000
we probably want to use in a couple different applications. We can use it in a chat

02:49:40.000 --> 02:49:44.000
application in an email application and so on. We don't want to write all this code every time 

02:49:44.000 --> 02:49:48.000
we want to convert these characters into smiley faces. 

02:49:48.000 --> 02:49:52.000
So, out of all these lines of code that we have from line 1 to 

02:49:52.000 --> 02:49:56.000
line 10, the lines 10-2 belong to our

02:49:56.000 --> 02:50:00.000
algorithm, all these lines together implement this feature. 

02:50:00.000 --> 02:50:04.000
So, you should put these lines in a separate function, 

02:50:04.000 --> 02:50:08.000
Now, why don't we have the input in this function? Because

02:50:08.000 --> 02:50:12.000
the input will can come in different forms, currently we're using the import function 

02:50:12.000 --> 02:50:16.000
to receive the input from the terminal, but in other applications 

02:50:16.000 --> 02:50:20.000
we might receive the input from a graphical user interface, so the input can come in

02:50:20.000 --> 02:50:24.000
different forms. We don't want to put that in our function, because this line will not be reuseable. 

02:50:24.000 --> 02:50:28.000
You want to give our function the actual message, 

02:50:28.000 --> 02:50:32.000
as a string. We don't care how we got that message. In one 

02:50:32.000 --> 02:50:36.000
program you might get it from the terminal, in another program you might get it from 

02:50:36.000 --> 02:50:40.000
a graphical user interface. So that is the reason this line up code should not

02:50:40.000 --> 02:50:44.000
be in that function. By the same function, you shouldn't include

02:50:44.000 --> 02:50:48.000
the last line in that function because what we do with the output is different from 

02:50:48.000 --> 02:50:52.000
one program to another. In this program, we are printing the output 

02:50:52.000 --> 02:50:56.000
in another program, you might send an output as an email, or as a response in 

02:50:56.000 --> 02:51:00.000
a chat application, so as a general rule of thumb you're function should

02:51:00.000 --> 02:51:04.000
not worry about receiving input and 

02:51:04.000 --> 02:51:08.000
printing it. These lines of code should not belong to your functions. So go 

02:51:08.000 --> 02:51:12.000
ahead and reorganize this code by extracting a function. 

02:51:16.000 --> 02:51:20.000
Alright, on the top, first we need to define our function. So first we type 

02:51:20.000 --> 02:51:24.000
def, give our function a name like emoji_

02:51:24.000 --> 02:51:28.000
converter, so the name of this function clearly tells me what

02:51:28.000 --> 02:51:32.000
it does. Each function should be responsible for one and only one task, 

02:51:32.000 --> 02:51:36.000
and that task should be clearly explained in the name of the function. 

02:51:36.000 --> 02:51:40.000
So, our emoji converter function should take 

02:51:40.000 --> 02:51:44.000
a parameter, we call that message, that is a string, right? Colon

02:51:44.000 --> 02:51:48.000
now we need to move the lines 

02:51:48.000 --> 02:51:52.000
5 all the way to the end of our for block 

02:51:52.000 --> 02:51:56.000
into the function, so let's select all these lines, you can

02:51:56.000 --> 02:52:00.000
cut them from here, by pressing command and x on Mac, or

02:52:00.000 --> 02:52:04.000
control and x on Windows, then we paste it here, 

02:52:04.000 --> 02:52:08.000
as you can see these lines are automatically indented 

02:52:08.000 --> 02:52:12.000
so, they are part of the emoji converter function, if this didn't happen on your

02:52:12.000 --> 02:52:16.000
computer, make sure to select these lines and use the 

02:52:16.000 --> 02:52:20.000
tab to indent them. Alright, so here's our emoji converter function 

02:52:20.000 --> 02:52:24.000
beautiful. Now after that 

02:52:24.000 --> 02:52:28.000
in the main flow of our program, first we get the input from the user 

02:52:28.000 --> 02:52:32.000
we store it in this variable message and then we call

02:52:32.000 --> 02:52:36.000
emoji converter and pass this message, 

02:52:36.000 --> 02:52:40.000
this function should return a value, that is what we use to calculate

02:52:40.000 --> 02:52:44.000
the end of this function, so right after this for block we need to add 

02:52:44.000 --> 02:52:48.000
a return statement, return output, 

02:52:48.000 --> 02:52:52.000
now that our function returns a value, we can get it and store it

02:52:52.000 --> 02:52:56.000
in a separate variable, let's call that result 

02:52:56.000 --> 02:53:00.000
and then we can simply print that here, or

02:53:00.000 --> 02:53:04.000
we can make this code shorter, we don't really need this code here so we can simply 

02:53:04.000 --> 02:53:08.000
call the emoji converter, and print the result.

02:53:08.000 --> 02:53:12.000
Like this. Now here we have an underline because

02:53:12.000 --> 02:53:16.000
as I told you before we need to blank lines after

02:53:16.000 --> 02:53:20.000
our function definitions. So currently we have only one blank line 

02:53:20.000 --> 02:53:24.000
we need to add another black line, good, let's go ahead, 

02:53:24.000 --> 02:53:28.000
and run this program, and make sure everything works as before 

02:53:28.000 --> 02:53:32.000
so I'm going to type a message like good morning with a smiley face 

02:53:32.000 --> 02:53:36.000
good, let's run it one more time, times that, 

02:53:36.000 --> 02:53:40.000
to add okay beautiful, so, here's the

02:53:40.000 --> 02:53:44.000
final result, we defined this function called

02:53:44.000 --> 02:53:48.000
emoji converter, this function takes a parameter called message.

02:53:48.000 --> 02:53:52.000
And finally returns the output. 

02:53:56.000 --> 02:54:00.000
In this tutorial I'm going to teach you how to handle errors in your 

02:54:00.000 --> 02:54:04.000
python programs, so let's start by writing  a small program 

02:54:04.000 --> 02:54:08.000
to get the user age from the terminal. So we call the input variable 

02:54:08.000 --> 02:54:12.000
input, and a label here, 

02:54:12.000 --> 02:54:16.000
like age, this returns a string, so we need to pass it to

02:54:16.000 --> 02:54:20.000
the end funciton and store the result in

02:54:20.000 --> 02:54:24.000
a variable called age, now let's print age to make sure you have

02:54:24.000 --> 02:54:28.000
implemented everything properly we run our program, we type 

02:54:28.000 --> 02:54:32.000
20, 20 is printed here, beautiful, now look at 

02:54:32.000 --> 02:54:36.000
the exit code of this program, exit code 0 means

02:54:36.000 --> 02:54:40.000
our program terminated successfully, there were no errors, but what if

02:54:40.000 --> 02:54:44.000
we run this program one more time and instead of entering 

02:54:44.000 --> 02:54:48.000
a numerical value, we enter something like asd. 

02:54:48.000 --> 02:54:52.000
We get a value error with his message invalid literal 

02:54:52.000 --> 02:54:56.000
for int with base 10. Basically what this message is telling 

02:54:56.000 --> 02:55:00.000
us is that this string asd does not contain 

02:55:00.000 --> 02:55:04.000
a valid home number that can be converted to an integer. Now look at the exit

02:55:04.000 --> 02:55:08.000
code of this program, exit code 1 means our exit code crashed, 

02:55:08.000 --> 02:55:12.000
so 0 always means success and anything but 0 means crash 

02:55:12.000 --> 02:55:16.000
now as a good python programmer you should anticipate this situation. 

02:55:16.000 --> 02:55:20.000
You don't want to let your entire program crash just because the user entered 

02:55:20.000 --> 02:55:24.000
an invalid value. So instead of letting the program 

02:55:24.000 --> 02:55:28.000
crash you should handle the situation and print a proper error message, and 

02:55:28.000 --> 02:55:32.000
that's what I'm going to show you in this tutorial, now before we get any further 

02:55:32.000 --> 02:55:36.000
look at the type of error we get here, value error, 

02:55:36.000 --> 02:55:40.000
so remember this, we're going to get back to this shortly 

02:55:40.000 --> 02:55:44.000
now how can we handle these errors, in python we have a construct called 

02:55:44.000 --> 02:55:48.000
try accept we use that to handle errors. 

02:55:48.000 --> 02:55:52.000
Let me show you how it works. So on the top

02:55:52.000 --> 02:55:56.000
we type try: now as you know we are defining 

02:55:56.000 --> 02:56:00.000
a code block so, I'm going to move these two lines, 

02:56:00.000 --> 02:56:04.000
inside of our try block so press tab here. 

02:56:04.000 --> 02:56:08.000
And remove this black line, now these two lines are part of our

02:56:08.000 --> 02:56:12.000
try block, right? So after try we type 

02:56:12.000 --> 02:56:16.000
accept, and then we add the type of the error 

02:56:16.000 --> 02:56:20.000
that our program may encounter, that is value error

02:56:20.000 --> 02:56:24.000
okay? Then, we add a colon and in this block we can

02:56:24.000 --> 02:56:28.000
define what should happen if our program encounters 

02:56:28.000 --> 02:56:32.000
an error of type value error. In this case we want to print 

02:56:32.000 --> 02:56:36.000
a proper error message, so print, 

02:56:36.000 --> 02:56:40.000
invalid value. So with this try and accept we are telling python

02:56:40.000 --> 02:56:44.000
hey, go ahead and try running one or these two lines of code, 

02:56:44.000 --> 02:56:48.000
if you encounter, an error of type. Value error 

02:56:48.000 --> 02:56:52.000
then instead of crashing the program, try this error message on the terminal

02:56:52.000 --> 02:56:56.000
so this is how this works. Now more accurately in programming

02:56:56.000 --> 02:57:00.000
we reefer to this kind of error as an exception. So an exception 

02:57:00.000 --> 02:57:04.000
is a kind of error that crashes our program. So our

02:57:04.000 --> 02:57:08.000
user enters an invalid value, this line of code 

02:57:08.000 --> 02:57:12.000
in line 2 will raise an exception, and on line 4 will catch it

02:57:12.000 --> 02:57:16.000
and print this error message, so our program will no longer 

02:57:16.000 --> 02:57:20.000
crash. Let me show you. So let's go ahead and run this

02:57:20.000 --> 02:57:24.000
age 20, everything 

02:57:24.000 --> 02:57:28.000
works just like before and the exit code is 0, let's 

02:57:28.000 --> 02:57:32.000
rerun this program, and enter asd, 

02:57:32.000 --> 02:57:36.000
so we get this proper error message invalid error menu and once again 

02:57:36.000 --> 02:57:40.000
the exit code is 0, so that means our program completed successfully.

02:57:40.000 --> 02:57:44.000
Didn't crash, now, we can also handle different kinds of 

02:57:44.000 --> 02:57:48.000
errors or exceptions, for example right when we get the age

02:57:48.000 --> 02:57:52.000
let's define a variable income and set it to 20,000.

02:57:52.000 --> 02:57:56.000
And then define another variable called risk and set it 

02:57:56.000 --> 02:58:00.000
to income divided by age. 

02:58:00.000 --> 02:58:04.000
Let's run this program and enter 0 as the game to see what happened. 

02:58:04.000 --> 02:58:08.000
So 0 is obviously a numerical value 

02:58:08.000 --> 02:58:12.000
so when we enter this value, technically we shouldn't get any exceptions. 

02:58:12.000 --> 02:58:16.000
Take a look. Our program crashed, we 

02:58:16.000 --> 02:58:20.000
did a 0 division error, because we cannot divide a number by 0. 

02:58:20.000 --> 02:58:24.000
Once again look at the exit code, so we couldn't catch this kind of error or

02:58:24.000 --> 02:58:28.000
this kind of exception with this accept block. 

02:58:28.000 --> 02:58:32.000
Accept block is only cashing exceptions of type value

02:58:32.000 --> 02:58:36.000
error. And this happens when we try to convert a nonnumerical value, 

02:58:36.000 --> 02:58:40.000
to an integer. So in a situation like this. We should handle 

02:58:40.000 --> 02:58:44.000
different kinds of exceptions, we can add another 

02:58:44.000 --> 02:58:48.000
except statement for an exception of type 0

02:58:48.000 --> 02:58:52.000
division error. Now in this block we can print a 

02:58:52.000 --> 02:58:56.000
different kind of message, like age cannot be

02:58:56.000 --> 02:59:00.000
0. Let's run our program one more time. Now, 

02:59:00.000 --> 02:59:04.000
I'm going to enter 0 as the age so we get this

02:59:04.000 --> 02:59:08.000
error message age cannot be 0 and look at the exit code.

02:59:08.000 --> 02:59:12.000
It's 0, so our program didn't crash, so to recap, we 

02:59:12.000 --> 02:59:16.000
`used try accept blocks to handle exceptions that are

02:59:16.000 --> 02:59:20.000
raised in our programs, as a good programmer you should always anticipate

02:59:20.000 --> 02:59:24.000
these kind of exceptions and handle them properly. 

02:59:28.000 --> 02:59:32.000
In this tutorial I'm going to talk to you guys about comments in python. 

02:59:32.000 --> 02:59:36.000
We use comments to add notes or comments to our programs. 

02:59:36.000 --> 02:59:40.000
For example, here I'm going to make a print statement, 

02:59:40.000 --> 02:59:44.000
sky is blue. Now, before that, I 

02:59:44.000 --> 02:59:48.000
can add a comment using a hi sign and then whatever we type here 

02:59:48.000 --> 02:59:52.000
is going to get ignored it's not going to get executed. Let me show you so

02:59:52.000 --> 02:59:56.000
let's run this program, look we only see this

02:59:56.000 --> 03:00:00.000
message. Sky is blue. So with this comment we can explain 

03:00:00.000 --> 03:00:04.000
something about our code, we can use it as reminders to fix things or

03:00:04.000 --> 03:00:08.000
clear things up, or we can use it to communicate things with other developers 

03:00:08.000 --> 03:00:12.000
reading our code, why we have written this code in a certain way.

03:00:12.000 --> 03:00:16.000
These are good use cases for using comments, we can also

03:00:16.000 --> 03:00:20.000
have comments over multiple lines, so we can simply add more

03:00:20.000 --> 03:00:24.000
comments, each line should start with a new hi sign. Now

03:00:24.000 --> 03:00:28.000
one thing you need to avoid when using comments is explaining what the

03:00:28.000 --> 03:00:32.000
code does. So here's an example of a bad comment. 

03:00:32.000 --> 03:00:36.000
Let me just delete these two lines, and with this comment I'm going to

03:00:36.000 --> 03:00:40.000
say print sky is blue. Why

03:00:40.000 --> 03:00:44.000
is this a bad comment, because it's telling me the obvious, it's telling me 

03:00:44.000 --> 03:00:48.000
this slide is going to print sky is blue. Now the problem with this comment is

03:00:48.000 --> 03:00:52.000
that apart from being verbose and repetitive, if you come here, 

03:00:52.000 --> 03:00:56.000
and change sky to ocean, now this comment gets 

03:00:56.000 --> 03:01:00.000
outdated. So overtime we change this code, then we have to come back and 

03:01:00.000 --> 03:01:04.000
modify the corresponding comment. So I've seen some developers 

03:01:04.000 --> 03:01:08.000
add comments in front of their functions, for example, they define 

03:01:08.000 --> 03:01:12.000
a function let's say a square that takes a number 

03:01:12.000 --> 03:01:16.000
and simply returns number times number.

03:01:16.000 --> 03:01:20.000
But it is obvious that this function calculates and returns the

03:01:20.000 --> 03:01:24.000
square of the given number. So there is really no need to add a comment and 

03:01:24.000 --> 03:01:28.000
explain that. Calculates and returns the

03:01:28.000 --> 03:01:32.000
square of a number. This is very repetitive and it creates 

03:01:32.000 --> 03:01:36.000
noiser code. Someone else reading your code they get distracted with all

03:01:36.000 --> 03:01:40.000
these unnecessary comments, so use comments to explain whys and hows.

03:01:40.000 --> 03:01:44.000
Not why's if you have made certain assumptions, we can use

03:01:44.000 --> 03:01:48.000
comments to explain those assumptions. Or we can use them to add notes to remind yourself 

03:01:48.000 --> 03:01:52.000
or other developers to do something in the code. 

03:01:52.000 --> 03:01:56.000
So comments are good, but too much of a good thing is a bad thing. 

03:02:00.000 --> 03:02:04.000
In this tutorial I'm going to talk to you guys about classes in python. 

03:02:04.000 --> 03:02:08.000
Classes are extremely important in programming and they're not

03:02:08.000 --> 03:02:12.000
specific to python, in fact, a lot of other programming languages

03:02:12.000 --> 03:02:16.000
do support the notion of classes. We use classes to define new types.

03:02:16.000 --> 03:02:20.000
For example, so far you have learned about the basic types in Python 

03:02:20.000 --> 03:02:24.000
like numbers, strings, and booleans, 

03:02:24.000 --> 03:02:28.000
these are the basic or simple types in python, you also learn 

03:02:28.000 --> 03:02:32.000
about a couple of complex types like lists and 

03:02:32.000 --> 03:02:36.000
dictionaries. While these types are extremely useful, they cannot 

03:02:36.000 --> 03:02:40.000
always be used to model complex concepts, for example, think about 

03:02:40.000 --> 03:02:44.000
the concept of a point, or a shopping cart. A shopping cart is not

03:02:44.000 --> 03:02:48.000
a boolean, it's not a list, it's not a dictionary, it's a different kind of

03:02:48.000 --> 03:02:52.000
thing. So we can use classes to define new types to 

03:02:52.000 --> 03:02:56.000
model real concepts. Now in this new model I'm going to show you how to

03:02:56.000 --> 03:03:00.000
define a new type called point, and this new type is going to have methods 

03:03:00.000 --> 03:03:04.000
for working with points. For example, back to our main program. Let's 

03:03:04.000 --> 03:03:08.000
create a list, numbers, 1, 2, 3, 

03:03:08.000 --> 03:03:12.000
you know that here, when we type that dot, 

03:03:12.000 --> 03:03:16.000
functions or methods available in list objects, now similar to this, 

03:03:16.000 --> 03:03:20.000
we're going to create a new type called point, this point is

03:03:20.000 --> 03:03:24.000
going to have metas like move, draw, get, 

03:03:24.000 --> 03:03:28.000
distance from another point, these are the operations that we can

03:03:28.000 --> 03:03:32.000
perform on points. So let me show you how to do this.

03:03:32.000 --> 03:03:36.000
We start by defining a class by using the class keyword, 

03:03:36.000 --> 03:03:40.000
and right after that we give our class a name. Now look at the

03:03:40.000 --> 03:03:44.000
naming convention I've used here. I've capitalized the first letter here, this is what we call

03:03:44.000 --> 03:03:48.000
a pascal naming convention. So the naming convention we 

03:03:48.000 --> 03:03:52.000
used for naming our classes is different from the convention we use for naming

03:03:52.000 --> 03:03:56.000
our variables and functions. For variables and functions we always

03:03:56.000 --> 03:04:00.000
use lower case letters and we separate multiple words using

03:04:00.000 --> 03:04:04.000
an underscore. But when naming classes, we don't use an underscore 

03:04:04.000 --> 03:04:08.000
to separate multiple words, instead we capitalize 

03:04:08.000 --> 03:04:12.000
the first letter of every word. So in this case our class has only a single 

03:04:12.000 --> 03:04:16.000
word, if you had multiple words, let's say email client 

03:04:16.000 --> 03:04:20.000
look I've capitalized the first letter

03:04:20.000 --> 03:04:24.000
of every word. Once again, this is called pascal naming convention

03:04:24.000 --> 03:04:28.000
and it comes from the old pascal language that you might have heard of.

03:04:28.000 --> 03:04:32.000
So, back to our point class. Here we add 

03:04:32.000 --> 03:04:36.000
a colon which means we're going to define a block, now

03:04:36.000 --> 03:04:40.000
in this block we can define all the functions or methods that belong 

03:04:40.000 --> 03:04:44.000
to points, for example, we can define a function called 

03:04:44.000 --> 03:04:48.000
move for moving a port, now note that as soon as we

03:04:48.000 --> 03:04:52.000
type open parenthesis, pycharm automatically adds self here, 

03:04:52.000 --> 03:04:56.000
this is a special keyword and we're going to get back to this shortly. 

03:04:56.000 --> 03:05:00.000
So, for now, in this method, let's print 

03:05:00.000 --> 03:05:04.000
move on the terminal, now let's define another 

03:05:04.000 --> 03:05:08.000
method like draw, so define draw 

03:05:08.000 --> 03:05:12.000
and in this method, let's print draw on the terminal, now

03:05:12.000 --> 03:05:16.000
let's remove the indentation, we're done 

03:05:16.000 --> 03:05:20.000
with the definition of our point class, so we need to add two line breaks 

03:05:20.000 --> 03:05:24.000
okay, so with this class we defined a new 

03:05:24.000 --> 03:05:28.000
type with this new type we can create new objects, so

03:05:28.000 --> 03:05:32.000
an object is an instance of a class, a class simply defines 

03:05:32.000 --> 03:05:36.000
the blueprint or the template for creating objects, and 

03:05:36.000 --> 03:05:40.000
objects are the actual instances based on that blue print. 

03:05:40.000 --> 03:05:44.000
So we can have tens of hundreds of points on the screen, these are the

03:05:44.000 --> 03:05:48.000
objects or the instances. So to create an object,

03:05:48.000 --> 03:05:52.000
we type out the name of our class and then call it like a function 

03:05:52.000 --> 03:05:56.000
this creates a new object and then returns it. So then we can store

03:05:56.000 --> 03:06:00.000
that object in a variable, let's call that point 1, 

03:06:00.000 --> 03:06:04.000
there you go, now when we use the dot operator. 

03:06:04.000 --> 03:06:08.000
Look, we have these two methods that we 

03:06:08.000 --> 03:06:12.000
defined, draw and move, we also have a bunch of other methods that we

03:06:12.000 --> 03:06:16.000
start with two underscores, these are called magic methods 

03:06:16.000 --> 03:06:20.000
we'll look at them later in the course. Now, let's call the draw method 

03:06:20.000 --> 03:06:24.000
of our point object, and run our program 

03:06:24.000 --> 03:06:28.000
so you can see draw is printed on the terminal. Now

03:06:28.000 --> 03:06:32.000
apart from methods these objects can also have attributes and these attributes

03:06:32.000 --> 03:06:36.000
are like variables that belong to a particular object. For example, 

03:06:36.000 --> 03:06:40.000
here, after we've defined .1. 

03:06:40.000 --> 03:06:44.000
We can set .1.x to 

03:06:44.000 --> 03:06:48.000
10. And .1.1 to 20. 

03:06:48.000 --> 03:06:52.000
Now we can easily print out these attributes, let's print 

03:06:52.000 --> 03:06:56.000
.1.x and run our program one more time

03:06:56.000 --> 03:07:00.000
take a look, so the x coordinate of .1 is 10.

03:07:00.000 --> 03:07:04.000
Now we can create another object, let's call that.2 

03:07:04.000 --> 03:07:08.000
so .2 once again we type out the name 

03:07:08.000 --> 03:07:12.000
of our class and then call it like a function. Now this object is completely 

03:07:12.000 --> 03:07:16.000
different then the first object. So if you print 

03:07:16.000 --> 03:07:20.000
.2.x 

03:07:20.000 --> 03:07:24.000
look we get this attribute error, because this point object doesn't have an

03:07:24.000 --> 03:07:28.000
attribute called, so each object is a different 

03:07:28.000 --> 03:07:32.000
instance of our points class. Now here

03:07:32.000 --> 03:07:36.000
we can assign a value to .2.x. Let's 

03:07:36.000 --> 03:07:40.000
send that to 1, and then run our program so we can see the 

03:07:40.000 --> 03:07:44.000
x coordinates of .2 is 1. So to recap

03:07:44.000 --> 03:07:48.000
we use classes to define new types, these types can have 

03:07:48.000 --> 03:07:52.000
methods that we define in the body of the class and they can also 

03:07:52.000 --> 03:07:56.000
have attributes that we can set anywhere in our programs.

03:08:00.000 --> 03:08:04.000
You have learned how to create new types using classes 

03:08:04.000 --> 03:08:08.000
now therein a tiny problem in this implementation. 

03:08:08.000 --> 03:08:12.000
We can create a pooint object without an x or y coordinate

03:08:12.000 --> 03:08:16.000
let me show you. So point we create this

03:08:16.000 --> 03:08:20.000
object here, and before we set point.x let's

03:08:20.000 --> 03:08:24.000
print point .x run our program 

03:08:24.000 --> 03:08:28.000
we get this attribute error which you

03:08:28.000 --> 03:08:32.000
saw in the last tutorial, so point object has no attribute called x

03:08:32.000 --> 03:08:36.000
This is the problem we have here, it is possible, 

03:08:36.000 --> 03:08:40.000
to have a point object without an x or y coordinates. 

03:08:40.000 --> 03:08:44.000
And that doesn't really make sense, because whenever we talk about a point, 

03:08:44.000 --> 03:08:48.000
we ned to know where that point is located. To solve this problem, we

03:08:48.000 --> 03:08:52.000
use a constructor. A constructor is a function that gets called

03:08:52.000 --> 03:08:56.000
at the time of creating an object. So here on line 9, when creating this

03:08:56.000 --> 03:09:00.000
point object, we want to pass values for x or y 

03:09:00.000 --> 03:09:04.000
coordinates, let's say 10 and 20, and with this, 

03:09:04.000 --> 03:09:08.000
this point object that we get here, will have it's

03:09:08.000 --> 03:09:12.000
x and y coordinates initialized. So how do we do this?

03:09:12.000 --> 03:09:16.000
We need to add a special method in this class called constructor. 

03:09:16.000 --> 03:09:20.000
So, on the top, I define a new function, 

03:09:20.000 --> 03:09:24.000
look at the name of this function, double underscore init, double under

03:09:24.000 --> 03:09:28.000
score. So init is short for initialized, and this is the

03:09:28.000 --> 03:09:32.000
function or the method that gets called when we create a new point object. 

03:09:32.000 --> 03:09:36.000
Now, press enter, so this automatically adds, 

03:09:36.000 --> 03:09:40.000
self in parenthesis, we're going to come back to this shortly. 

03:09:40.000 --> 03:09:44.000
Now, right after self, we want to add 2 extra parameters, 

03:09:44.000 --> 03:09:48.000
x and y, so let's type out x and y, 

03:09:48.000 --> 03:09:52.000
and then in the body of this method, we should read the values past

03:09:52.000 --> 03:09:56.000
here, and use them to initialize our object, so when we pass

03:09:56.000 --> 03:10:00.000
10 and 20, these arguments will be used for

03:10:00.000 --> 03:10:04.000
x and y parameters. Now to initialize 

03:10:04.000 --> 03:10:08.000
our object, we type our code like this. Self.x equals 

03:10:08.000 --> 03:10:12.000
x. And then self.y equals y. 

03:10:12.000 --> 03:10:16.000
What is going on here, this self that you see here is a reference to the current 

03:10:16.000 --> 03:10:20.000
object. So, back to line 13, 

03:10:20.000 --> 03:10:24.000
when we create a new point object, self references that object in

03:10:24.000 --> 03:10:28.000
memory, the same object, that we're referencing using this cariable.

03:10:28.000 --> 03:10:32.000
So earlier we typed point.x equals 10, 

03:10:32.000 --> 03:10:36.000
with this code we set the x attribute of this point object. 

03:10:36.000 --> 03:10:40.000
Now what we have in the constructor is exactly the same, we use the self 

03:10:40.000 --> 03:10:44.000
to reference the current object and then we set the x attribute 

03:10:44.000 --> 03:10:48.000
to the x argument passed to this function. So, 

03:10:48.000 --> 03:10:52.000
using this init method, we can initialize our objects and 

03:10:52.000 --> 03:10:56.000
we refer to this method as a constructor, this method is used to construct 

03:10:56.000 --> 03:11:00.000
or create an object, okay? so,

03:11:00.000 --> 03:11:04.000
Now, let's remove line 14, so we created

03:11:04.000 --> 03:11:08.000
point object with these values and then print point.x let's run our program 

03:11:08.000 --> 03:11:12.000
there you go, x is 10, we can also change 

03:11:12.000 --> 03:11:16.000
these values later, so just before printing point.x we can set 

03:11:16.000 --> 03:11:20.000
point.x to 11 and then run our program 

03:11:20.000 --> 03:11:24.000
so x is updated, beautiful, alright, here's a 

03:11:24.000 --> 03:11:28.000
exercise for you. I want you to define a new type called person

03:11:28.000 --> 03:11:32.000
these person objects should have a name attribute as well as a talk

03:11:32.000 --> 03:11:36.000
method. This is a very easy exercise so, 

03:11:36.000 --> 03:11:40.000
you can tackle it in probably a couple of minutes. 

03:11:40.000 --> 03:11:44.000
Alright, so

03:11:44.000 --> 03:11:48.000
first we start with a  class keyboard, we define this person class 

03:11:48.000 --> 03:11:52.000
once again look at the naming convention I have used here, the first letter

03:11:52.000 --> 03:11:56.000
of the first word in this case the only word is uppercase. 

03:11:56.000 --> 03:12:00.000
Now, in this class we define all the methods we need, currently we only have

03:12:00.000 --> 03:12:04.000
method that is the talk method, so define talk, 

03:12:04.000 --> 03:12:08.000
pycharm automatically adds self, we come back to this shortly, 

03:12:08.000 --> 03:12:12.000
for now let's just print talk. 

03:12:12.000 --> 03:12:16.000
So this is the body of our person class. We remove the indentation 

03:12:16.000 --> 03:12:20.000
and add two line breaks after defining our 

03:12:20.000 --> 03:12:24.000
classes. Now we can create the personal object, let's call that jon, 

03:12:24.000 --> 03:12:28.000
we set it to person, we can call jon.

03:12:28.000 --> 03:12:32.000
talk, let's run the program so we get this

03:12:32.000 --> 03:12:36.000
message, beautiful, but our person objects should also have

03:12:36.000 --> 03:12:40.000
a name attribute, it doesn't make sense to have a person without the name. 

03:12:40.000 --> 03:12:44.000
So that is when we use the constructor function. So on the top, 

03:12:44.000 --> 03:12:48.000
we add a new method, at the name of this method is double 

03:12:48.000 --> 03:12:52.000
underscore, init double underscore. So we

03:12:52.000 --> 03:12:56.000
call this method a constructor. Now in this method we need to

03:12:56.000 --> 03:13:00.000
add another parameter which is name, so we 

03:13:00.000 --> 03:13:04.000
simply set self.name to name. Once

03:13:04.000 --> 03:13:08.000
again, self references the current object, we're setting the name 

03:13:08.000 --> 03:13:12.000
attribute of the current object, to the name argument passed to this method. 

03:13:12.000 --> 03:13:16.000
With this we can go back to line 9, and 

03:13:16.000 --> 03:13:20.000
when creating a person object we pass the name, let's see jon smith 

03:13:20.000 --> 03:13:24.000
now let's print jon.name and run our program 

03:13:24.000 --> 03:13:28.000
there you go. So jon Smith is printed on the terminal, beautiful, 

03:13:28.000 --> 03:13:32.000
so this is all you had to do as part of this exercise. But

03:13:32.000 --> 03:13:36.000
let's make this program a little more interesting. Instead of printing

03:13:36.000 --> 03:13:40.000
this boring message here, let's print hi, I am Jon Smith. 

03:13:40.000 --> 03:13:44.000
So, we can use a formatted string with a message 

03:13:44.000 --> 03:13:48.000
like Hi, I am, now we want to dynamically

03:13:48.000 --> 03:13:52.000
add the name of this person. How do we do this? Well, look at 

03:13:52.000 --> 03:13:56.000
the parameter of this talk method. As I told you before, 

03:13:56.000 --> 03:14:00.000
every method in our class should have this parameter, self.

03:14:00.000 --> 03:14:04.000
And they should be the very first parameter of each method, okay? So, 

03:14:04.000 --> 03:14:08.000
with this self we can get reference to the current object, so

03:14:08.000 --> 03:14:12.000
we can add curly braces and type out self 

03:14:12.000 --> 03:14:16.000
.name. Thsi returns the name attribute of the current 

03:14:16.000 --> 03:14:20.000
person object. With this we can remove 

03:14:20.000 --> 03:14:24.000
line 10, where we print jon.name and simply call

03:14:24.000 --> 03:14:28.000
jon.talk. Lets run our program.

03:14:28.000 --> 03:14:32.000
Hi, I am Jon Smith. There we go, beautiful.

03:14:32.000 --> 03:14:36.000
Now we can build another person object, let's say Bob, is a new person 

03:14:36.000 --> 03:14:40.000
called Bob Smith, when we say 

03:14:40.000 --> 03:14:44.000
Bob.talk. And run our program 

03:14:44.000 --> 03:14:48.000
we get a different message, hi I'm Bob Smith, so

03:14:48.000 --> 03:14:52.000
each object is a different instance of a person class. 

03:14:56.000 --> 03:15:00.000
In this tutorial Im going to talk to you about inheritance in Python, 

03:15:00.000 --> 03:15:04.000
inheritance is a mechanism for using code and once again 

03:15:04.000 --> 03:15:08.000
it's no limited to python, most languages that support classes

03:15:08.000 --> 03:15:12.000
also support inherence. So let ms how you how this works. Let's say

03:15:12.000 --> 03:15:16.000
we have this dog class with a simple walk method, in this method

03:15:16.000 --> 03:15:20.000
we're simply printing the walk message on the terminal, now let's say

03:15:20.000 --> 03:15:24.000
in real program, instead of just one line of code here we're going to have 10 lines of

03:15:24.000 --> 03:15:28.000
code. Now, what if in the future we want to define a 

03:15:28.000 --> 03:15:32.000
another class let's say cat and we want to add 

03:15:32.000 --> 03:15:36.000
this walk method there as well. Sow e'll have to repeat all that code, 

03:15:36.000 --> 03:15:40.000
in this new class, walk. 

03:15:40.000 --> 03:15:44.000
This is bad. because you have repeated or duplicated our

03:15:44.000 --> 03:15:48.000
code. In programming we have a principle called dry

03:15:48.000 --> 03:15:52.000
which is short for don't repeat yourself. 

03:15:52.000 --> 03:15:56.000
Let's say sometime in the future, we discover a problem with our walk method. If you

03:15:56.000 --> 03:16:00.000
have repeated or duplicated this method in many other places, then we'll 

03:16:00.000 --> 03:16:04.000
have to come back and fix that problem in every single place we have

03:16:04.000 --> 03:16:08.000
duplicated this code. So that's why in programming we should not define something 

03:16:08.000 --> 03:16:12.000
twice. So how can we solve this problem. 

03:16:12.000 --> 03:16:16.000
There are different approaches, one approach that is easier to understand for beginners is inherence 

03:16:16.000 --> 03:16:20.000
Now here's how it works. We define a new class called

03:16:20.000 --> 03:16:24.000
maml and move the walk method right there. Then we'll have

03:16:24.000 --> 03:16:28.000
the dog and cat classes inherit that method

03:16:28.000 --> 03:16:32.000
from their parent just like how humans inherit certain

03:16:32.000 --> 03:16:36.000
attributes or behaviors form their parents. That' exactly the same, so

03:16:36.000 --> 03:16:40.000
on the top, we define a new class, let's call it

03:16:40.000 --> 03:16:44.000
mammal then we need to move the walk method there. So, 

03:16:44.000 --> 03:16:48.000
we select it, cut it, using command and x on Mac, or

03:16:48.000 --> 03:16:52.000
control x on Windows and then paste it here, beautiful, 

03:16:52.000 --> 03:16:56.000
now we want our dog class to inherit this class from the mammal class

03:16:56.000 --> 03:17:00.000
so right after the class name we add parenthesis and 

03:17:00.000 --> 03:17:04.000
then type out the name of the parent class. In this case, mammal.

03:17:04.000 --> 03:17:08.000
That's all we have to do. So with his the dog class

03:17:08.000 --> 03:17:12.000
will inherit all he methods defined in the mammal class. 

03:17:12.000 --> 03:17:16.000
Now there is a tiny problem here, if you look at line 9, there is a 

03:17:16.000 --> 03:17:20.000
red underline here. The reason this is happening is because

03:17:20.000 --> 03:17:24.000
python doesn't like an empty class, so right now our dog

03:17:24.000 --> 03:17:28.000
class is empty, it doesn't have anything, we either need to add methods

03:17:28.000 --> 03:17:32.000
specific to dogs or just to make Python happy, 

03:17:32.000 --> 03:17:36.000
we can use the path statement, and that basically means nothing.

03:17:36.000 --> 03:17:40.000
We're telling python interpreter, hey, pass this line, don't worry about it. But with this, we

03:17:40.000 --> 03:17:44.000
don't have an empty class, okay? Now as I told you before

03:17:44.000 --> 03:17:48.000
after each class I should have two line breaks so right now we 

03:17:48.000 --> 03:17:52.000
only have one line break and that is the reason we have this little warning here, so let's add

03:17:52.000 --> 03:17:56.000
another black line, beautiful, so our dog class is

03:17:56.000 --> 03:18:00.000
inheriting the walk method from the mammal, you need to apply the same change 

03:18:00.000 --> 03:18:04.000
to the cat class. So we'll have cat 

03:18:04.000 --> 03:18:08.000
inherit from mammal, and then, 

03:18:08.000 --> 03:18:12.000
use the path statement here. With these changes, 

03:18:12.000 --> 03:18:16.000
now we can create either a dog or  cat object, let's say dog, 

03:18:16.000 --> 03:18:20.000
one, we set it to a dog object, and 

03:18:20.000 --> 03:18:24.000
when we type dot look we have the walk method that is defined 

03:18:24.000 --> 03:18:28.000
in the mamall class. We can easily call it, let's run our program

03:18:28.000 --> 03:18:32.000
there you go, you see the walk message, 

03:18:32.000 --> 03:18:36.000
so both the dog and cat classes are inheriting all the classes

03:18:36.000 --> 03:18:40.000
methods defined in their parent class. Now here we can add methods

03:18:40.000 --> 03:18:44.000
specific to dogs, for example, we can define a method called 

03:18:44.000 --> 03:18:48.000
bark, and then print bark. 

03:18:48.000 --> 03:18:52.000
Now, we don't need the path statement because we already defined 

03:18:52.000 --> 03:18:56.000
one method in our dog class. So now when we type out 

03:18:56.000 --> 03:19:00.000
dog1. look we have two methods

03:19:00.000 --> 03:19:04.000
one is the walk method that we inherited and the bark method that we just

03:19:04.000 --> 03:19:08.000
defined in the dog class. Similarly, we can add a method 

03:19:08.000 --> 03:19:12.000
specific to a cat, for example, we can define a method called

03:19:12.000 --> 03:19:16.000
be annoying, I hate cats, so let's print

03:19:16.000 --> 03:19:20.000
annoying , now when we create the cat

03:19:20.000 --> 03:19:24.000
object, let's remove that, cat1

03:19:24.000 --> 03:19:28.000
and type out cat1. you have these two methods 

03:19:28.000 --> 03:19:32.000
dog and be annoying. So these are the basics of inheritance in python

03:19:32.000 --> 03:19:36.000
Now there is more to this that really goes beyond the scope of this beginners tutorial. 

03:19:36.000 --> 03:19:40.000
If you're interested to learn more about inheritance and other mechanisms 

03:19:40.000 --> 03:19:44.000
for reusing code, I encourage you to get my complete Python course.

03:19:48.000 --> 03:19:52.000
In this tutorial, I'm going to talk to you about modules in python. 

03:19:52.000 --> 03:19:56.000
A module in python is basically a file with some python code. 

03:19:56.000 --> 03:20:00.000
And we use modules to organize our code into files. 

03:20:00.000 --> 03:20:04.000
Just like sections in a super market. When you go to a super market there are different sections

03:20:04.000 --> 03:20:08.000
for fruits, vegetables, cleaning products, and so on. We don't have 

03:20:08.000 --> 03:20:12.000
one section with all the products in the super market. We have the same concept

03:20:12.000 --> 03:20:16.000
in programming. So instead of writing all our code, instead of writing

03:20:16.000 --> 03:20:20.000
all the functions and classes in app.py we want to break up our code

03:20:20.000 --> 03:20:24.000
into multiple files. We refer to each file as a module. 

03:20:24.000 --> 03:20:28.000
With this, not only is our code better organized and structured, 

03:20:28.000 --> 03:20:32.000
but we'll also have the ability to reuse our code. For example, 

03:20:32.000 --> 03:20:36.000
over here in app.py, I've defined two functions for converting

03:20:36.000 --> 03:20:40.000
weight from pounds to kilograms and vice versa. 

03:20:40.000 --> 03:20:44.000
Now we can take these two functions and put them in a separate module

03:20:44.000 --> 03:20:48.000
called converters, and then we can import that module into any

03:20:48.000 --> 03:20:52.000
program that needs these converter functions. Let me show you how to do this.

03:20:52.000 --> 03:20:56.000
So, let's open up our project panel and right

03:20:56.000 --> 03:21:00.000
click the project, go to new, and add the new file, 

03:21:00.000 --> 03:21:04.000
we're going to call this file, converters.py. 

03:21:04.000 --> 03:21:08.000
Then, we go back to app.py 

03:21:08.000 --> 03:21:12.000
select all this code, cut it and then 

03:21:12.000 --> 03:21:16.000
paste it into our new module. converters.py. 

03:21:16.000 --> 03:21:20.000
With this we have cleaned up our app module it's not bloated with different

03:21:20.000 --> 03:21:24.000
functions, so as we write more functions with classes, we put them in their 

03:21:24.000 --> 03:21:28.000
corresponding modules, a module should contain all the related

03:21:28.000 --> 03:21:32.000
functions and classes, okay? Now you want to

03:21:32.000 --> 03:21:36.000
import the converters module into our app module, and that is really easy, on the

03:21:36.000 --> 03:21:40.000
top we write import converters 

03:21:40.000 --> 03:21:44.000
without extension, so we don't add .py we only type out the name of

03:21:44.000 --> 03:21:48.000
the file. Let me close that project panel. Now, 

03:21:48.000 --> 03:21:52.000
this converter is an object so we can use the dot operator

03:21:52.000 --> 03:21:56.000
to access it's members. So currently we have defined 

03:21:56.000 --> 03:22:00.000
these two functions inside of our module, kilogram to pound, 

03:22:00.000 --> 03:22:04.000
and pounds to kilograms. So we can easily call one of these functions 

03:22:04.000 --> 03:22:08.000
let's pass 70 kilos get the result and print it out. 

03:22:08.000 --> 03:22:12.000
Run our program, so, 

03:22:12.000 --> 03:22:16.000
that is under 55 pounds. Now there is also another

03:22:16.000 --> 03:22:20.000
syntax for importing modules, let me show you, so

03:22:20.000 --> 03:22:24.000
instead of importing the entire module we can import specific functions from that 

03:22:24.000 --> 03:22:28.000
module. Here's how it works. We type out from 

03:22:28.000 --> 03:22:32.000
then we add the name of our module, so converters 

03:22:32.000 --> 03:22:36.000
import, now here if you press control and space

03:22:36.000 --> 03:22:40.000
we can see the list of all the functions defined in this module. 

03:22:40.000 --> 03:22:44.000
So here we can grab one of these functions let's say kilogram to pound, and 

03:22:44.000 --> 03:22:48.000
with this we can directly call this function just like

03:22:48.000 --> 03:22:52.000
the function defined in this file. App.py. Compare

03:22:52.000 --> 03:22:56.000
what we have on line 4 to what we have on line 6. On line 6

03:22:56.000 --> 03:23:00.000
we'll have to prefix this function with the name of an object 

03:23:00.000 --> 03:23:04.000
converters. So we have to type converters. and then we'll be able to

03:23:04.000 --> 03:23:08.000
access this function. In contrast. When we import 

03:23:08.000 --> 03:23:12.000
a specific function from our module, then we can easily call that function

03:23:12.000 --> 03:23:16.000
without prefixing it with the module name. So here's what

03:23:16.000 --> 03:23:20.000
you need to take away.  We use modules to better organize our code. Instead of

03:23:20.000 --> 03:23:24.000
writing all the code, instead of writing all the functions in one file, you break up

03:23:24.000 --> 03:23:28.000
our code across multiple files. Each file is called 

03:23:28.000 --> 03:23:32.000
a module and it should contain all the related functions and classes 

03:23:32.000 --> 03:23:36.000
then we can import a module into another module, in this case, we are importing 

03:23:36.000 --> 03:23:40.000
the converters module into our app module. And as you saw, 

03:23:40.000 --> 03:23:44.000
there are two ways to import this module, we can import the entire module, and then

03:23:44.000 --> 03:23:48.000
we'll get an object with the same name as the module so we can

03:23:48.000 --> 03:23:52.000
type converters . and then we'll be able to access all the

03:23:52.000 --> 03:23:56.000
functions and classes defined in this module. The other appraoch

03:23:56.000 --> 03:24:00.000
is to impot a specific function or class from a module using the

03:24:00.000 --> 03:24:04.000
from import statement. Now here

03:24:04.000 --> 03:24:08.000
is your exercise. Earlier in the course you had an exercise for finding the

03:24:08.000 --> 03:24:12.000
largest number in the list. So here on the top we have

03:24:12.000 --> 03:24:16.000
a list of numbers, initially we set max to the first number in this list

03:24:16.000 --> 03:24:20.000
then, we look through this list, get each number, 

03:24:20.000 --> 03:24:24.000
if the current number is grater than max, then we reset max. 

03:24:24.000 --> 03:24:28.000
And finally when we are done with our loop we print max on the terminal. 

03:24:28.000 --> 03:24:32.000
Now here's what I want you to do. This code currently 

03:24:32.000 --> 03:24:36.000
has no organization. We don't have any functions, we don't have any modules, we wrote all 

03:24:36.000 --> 03:24:40.000
the code in app.py, that is okay for small programs, 

03:24:40.000 --> 03:24:44.000
but as your programs grow, you need to properly organize your code into

03:24:44.000 --> 03:24:48.000
classes and modules. So, as part of this exercise, I want 

03:24:48.000 --> 03:24:52.000
you to write a function, call it find max. 

03:24:52.000 --> 03:24:56.000
This function should take a list, and return the largest number in that list. 

03:24:56.000 --> 03:25:00.000
Now after you do this, go ahead and put this function 

03:25:00.000 --> 03:25:04.000
in a separate module. So extract it from here, and put it in a module, 

03:25:04.000 --> 03:25:08.000
called utils. So in this module we're going to have a bunch of 

03:25:08.000 --> 03:25:12.000
utility functions, oaky? Then import the utility 

03:25:12.000 --> 03:25:16.000
module into the current module and call this function. 

03:25:16.000 --> 03:25:20.000
Finally, get the result and print it on the terminal, this is a 

03:25:20.000 --> 03:25:24.000
fantastic exercise to teach you how to properly organize your code. So, 

03:25:24.000 --> 03:25:28.000
go ahead and spend a couple minutes on this exercise. 

03:25:28.000 --> 03:25:32.000
So the first

03:25:32.000 --> 03:25:36.000
step is to define a function called find max. So on the

03:25:36.000 --> 03:25:40.000
top, I'm going to define function, find max

03:25:40.000 --> 03:25:44.000
this function should take a list of numbers, so we

03:25:44.000 --> 03:25:48.000
add a parameter called numbers. Now inside of this function you

03:25:48.000 --> 03:25:52.000
want to have these few lines, this is the algorithm for finding the 

03:25:52.000 --> 03:25:56.000
largest number in a list, we don't want to bring the first line, because this

03:25:56.000 --> 03:26:00.000
is where we create a list. So somewhere in our program we're going to create this list, 

03:26:00.000 --> 03:26:04.000
and tehen pass it as an argument to pass max 

03:26:04.000 --> 03:26:08.000
function. Okay? So, let's go ahead and grab

03:26:08.000 --> 03:26:12.000
these few lines, cut them, and put them inside

03:26:12.000 --> 03:26:16.000
of find max function. Alright, so we find the

03:26:16.000 --> 03:26:20.000
largest number in this list, finally we need to return it, so, 

03:26:20.000 --> 03:26:24.000
return max. So here's our function. Now we

03:26:24.000 --> 03:26:28.000
need to move this into a separate module. So let's go to the panel 

03:26:28.000 --> 03:26:32.000
right click the project and add a new 

03:26:32.000 --> 03:26:36.000
file, we can also add a new python file that's the same, let's call that

03:26:36.000 --> 03:26:40.000
utils so if you add a new python file 

03:26:40.000 --> 03:26:44.000
pycharm automatically adds .py extension, but if you go to

03:26:44.000 --> 03:26:48.000
new file we'll have to explicitly type out 

03:26:48.000 --> 03:26:52.000
.py. So make sure to get the extension right. 

03:26:52.000 --> 03:26:56.000
Now, back to app.py, let's cut this code and 

03:26:56.000 --> 03:27:00.000
paste it into this new module, okay beautiful. 

03:27:00.000 --> 03:27:04.000
Now I'm going o go back to app.py and import our new module. 

03:27:04.000 --> 03:27:08.000
We can either import the entire module, so import utils 

03:27:08.000 --> 03:27:12.000
and then access individual functions so we can call utils 

03:27:12.000 --> 03:27:16.000
.find max or we can explicitly 

03:27:16.000 --> 03:27:20.000
import this function from the utils module. It doesn't really make a difference. 

03:27:20.000 --> 03:27:24.000
So, we could type from utils

03:27:24.000 --> 03:27:28.000
import find max. And then we

03:27:28.000 --> 03:27:32.000
don't need to prefix this with the name of it's object, so we simply call

03:27:32.000 --> 03:27:36.000
find max. Now we need to call this after we initialize our list.

03:27:36.000 --> 03:27:40.000
So first we need to define the list of numbers. 

03:27:40.000 --> 03:27:44.000
Then, we pass that list as an argument to find max

03:27:44.000 --> 03:27:48.000
we get the result which is max and finally we print it

03:27:48.000 --> 03:27:52.000
on the terminal. let's go ahead and run our program, so the

03:27:52.000 --> 03:27:56.000
largest number is 10, beautiful, 

03:27:56.000 --> 03:28:00.000
now one last thing before we finish this tutorial, here we have this little warning 

03:28:00.000 --> 03:28:04.000
under max and the tool tip says shadows built in name 

03:28:04.000 --> 03:28:08.000
max. The reason we see this is because we actually have a function called 

03:28:08.000 --> 03:28:12.000
max. And it does the exact same job 

03:28:12.000 --> 03:28:16.000
as our find max function. So this is actually built into python. 

03:28:16.000 --> 03:28:20.000
But I ask you to do it as an exercise because it's a great exercise for beginners. 

03:28:20.000 --> 03:28:24.000
Now, back to the warning, this warning is basically telling us that we are

03:28:24.000 --> 03:28:28.000
overwriting the built in max function in python 

03:28:28.000 --> 03:28:32.000
so we are changing the meaning of this function, and this is considered a bad practice, 

03:28:32.000 --> 03:28:36.000
let me show you what I mean. So let's comment out what we have on line 4, 

03:28:36.000 --> 03:28:40.000
by putting a hash sign here, we can also use, 

03:28:40.000 --> 03:28:44.000
a short cut command and slash on Mac, or control on slash

03:28:44.000 --> 03:28:48.000
on Windows. So now this line is commented out. Look at the

03:28:48.000 --> 03:28:52.000
color of max here, it's purple, it's the same color as print. And this is the color

03:28:52.000 --> 03:28:56.000
used to identify the built in functions. So now we can call

03:28:56.000 --> 03:29:00.000
this function and give it a list of numbers 

03:29:00.000 --> 03:29:04.000
run our program we get the same exact result however, 

03:29:04.000 --> 03:29:08.000
if we bring this line back, once again we can use the same 

03:29:08.000 --> 03:29:12.000
shortcut that is command and slash on Mac or control slash on Windows. 

03:29:12.000 --> 03:29:16.000
Now, we are redefining max, so up to

03:29:16.000 --> 03:29:20.000
this line, max used to be a function, but after line 4 is executed 

03:29:20.000 --> 03:29:24.000
max is set to an integer, that is the largest number in this list. 

03:29:24.000 --> 03:29:28.000
So, we'll no longer be able to call it on line 5, 

03:29:28.000 --> 03:29:32.000
let's run our program and see what happens. So there you go, 

03:29:32.000 --> 03:29:36.000
we get this type error, int object is not 

03:29:36.000 --> 03:29:40.000
callable, because max is now an integer, it's not a function, 

03:29:40.000 --> 03:29:44.000
so we cannot call it. So to solve this problem, we can rename 

03:29:44.000 --> 03:29:48.000
this variable to something else. So right click here. 

03:29:48.000 --> 03:29:52.000
Go to refactor and rename, 

03:29:52.000 --> 03:29:56.000
and rename this to maximum.

03:29:56.000 --> 03:30:00.000
So you can see the warning is gone. As you can see we have the same warning 

03:30:00.000 --> 03:30:04.000
in our utils module. So here we're redefining max 

03:30:04.000 --> 03:30:08.000
and as I told you before this is a bad practice. We're changing the 

03:30:08.000 --> 03:30:12.000
meaning of built in functions in python. So, 

03:30:12.000 --> 03:30:16.000
let's rename these as well, I'm going to use the short cut that is shift and 

03:30:16.000 --> 03:30:20.000
f6 there you go and here we can change this to 

03:30:20.000 --> 03:30:24.000
maximum. Enter, done. 

03:30:28.000 --> 03:30:32.000
In this tutorial we're going to talk about packages in python, 

03:30:32.000 --> 03:30:36.000
packages are basically another way to organize our code, so currently

03:30:36.000 --> 03:30:40.000
we have only 3 files for modules in our project but a real project 

03:30:40.000 --> 03:30:44.000
can contain hundreds or even thousands of modules. 

03:30:44.000 --> 03:30:48.000
We don't want to add all those modules here, because over time this directory will get 

03:30:48.000 --> 03:30:52.000
bloated with so many files, so a better approach is to organize related 

03:30:52.000 --> 03:30:56.000
modules, inside of a package, so a package is a container 

03:30:56.000 --> 03:31:00.000
for multiple modules In file system terms a package is 

03:31:00.000 --> 03:31:04.000
a directory or folder. So in our project we can add a new directory 

03:31:04.000 --> 03:31:08.000
and in that directory we can add all the directed modules, as a metaphor think

03:31:08.000 --> 03:31:12.000
of a mall. When you go to a  mall or a shopping center there are different 

03:31:12.000 --> 03:31:16.000
sections for mens women and kids clothing, so that is

03:31:16.000 --> 03:31:20.000
ilke a package, now when you go to the mens section, there are different areas

03:31:20.000 --> 03:31:24.000
fior different kinds of products, we have a section for shoes, t shirts, 

03:31:24.000 --> 03:31:28.000
jackets, and so on, so each of these is like a module, so, 

03:31:28.000 --> 03:31:32.000
in this tutorial, I'm going to show you how to create and use packages in Python, 

03:31:32.000 --> 03:31:36.000
here in our project panel, right click the panel and

03:31:36.000 --> 03:31:40.000
add a new directory. 

03:31:40.000 --> 03:31:44.000
Let's call this directory e commerce. So we're going to create

03:31:44.000 --> 03:31:48.000
a package called e-commerce and in this package we're going to have

03:31:48.000 --> 03:31:52.000
all the modules related for an ecommerce application. For example, 

03:31:52.000 --> 03:31:56.000
we can have modules for sales, shipping, customer service 

03:31:56.000 --> 03:32:00.000
and so on. So let's go ahead 

03:32:00.000 --> 03:32:04.000
Now here we have an empty directory, in order to convert this to a package 

03:32:04.000 --> 03:32:08.000
we need to add a special file in it. So, right

03:32:08.000 --> 03:32:12.000
click this directory and add a new python file, 

03:32:12.000 --> 03:32:16.000
call that file double underscore in it, double underscore 

03:32:16.000 --> 03:32:20.000
this is a special convention in Python. 

03:32:20.000 --> 03:32:24.000
When Python interpreter sees a file with this name and 

03:32:24.000 --> 03:32:28.000
name in a directory, it treats this directory as a package, we also have a 

03:32:28.000 --> 03:32:32.000
shortcut for that in pycharm so let me delete this directory 

03:32:32.000 --> 03:32:36.000
and start again. So delete, once again right click 

03:32:36.000 --> 03:32:40.000
the project, and go to new but instead of creating a new directory 

03:32:40.000 --> 03:32:44.000
we can create a new python package, let's call

03:32:44.000 --> 03:32:48.000
our package ecommerce as you can see 

03:32:48.000 --> 03:32:52.000
pycharm automatically creates this file for us so we don't have to manually create

03:32:52.000 --> 03:32:56.000
it. Okay? Now, in this package, let's add a new module, 

03:32:56.000 --> 03:33:00.000
so a new python file, let's call it

03:33:00.000 --> 03:33:04.000
shipping okay? Now in this module we want to have 

03:33:04.000 --> 03:33:08.000
a function for calculating the shipping costs. So define 

03:33:08.000 --> 03:33:12.000
calculate, underline, shipping. 

03:33:12.000 --> 03:33:16.000
Now don't worry about parameters or implementation, we simply print 

03:33:16.000 --> 03:33:20.000
calculate underline shipping. 

03:33:20.000 --> 03:33:24.000
Now lets say you want to import this shipping module 

03:33:24.000 --> 03:33:28.000
into our app module, with this new structure this shipping 

03:33:28.000 --> 03:33:32.000
module is now part of the ecommerce package, so we cannot import a direct 

03:33:32.000 --> 03:33:36.000
you have to start from the ecommerce package. So, 

03:33:36.000 --> 03:33:40.000
bak to app,py once again there are two ways to import this module. 

03:33:40.000 --> 03:33:44.000
We can import the entire module or we can 

03:33:44.000 --> 03:33:48.000
import one of it's functions or classes. So let me show you both approaches. 

03:33:48.000 --> 03:33:52.000
First, we're going to import the entire module. Now what is the name of our 

03:33:52.000 --> 03:33:56.000
package? it is ecommerce, right? So ecommerce.

03:33:56.000 --> 03:34:00.000
shipping. So instead of typing import 

03:34:00.000 --> 03:34:04.000
shipping we type import ecommerce 

03:34:04.000 --> 03:34:08.000
.shipping. we have to prefix it with the name of it's package. 

03:34:08.000 --> 03:34:12.000
Now to access any of the functions or classes in this module 

03:34:12.000 --> 03:34:16.000
we'll have to type out ecommerce.shipping.

03:34:16.000 --> 03:34:20.000
and there you go. Now we can access the calculate shipping 

03:34:20.000 --> 03:34:24.000
function. So let's go ahead and run our program, 

03:34:24.000 --> 03:34:28.000
we see this message printed on the terminal, beautiful. However 

03:34:28.000 --> 03:34:32.000
with this approach, every time you want to call one of the functions

03:34:32.000 --> 03:34:36.000
to this module, we'll have to prefix it with ecommerce.

03:34:36.000 --> 03:34:40.000
shipping. that is very verbose. So when working with packages 

03:34:40.000 --> 03:34:44.000
we often use the second approach, using the

03:34:44.000 --> 03:34:48.000
from statement. So we can type from ecommerce 

03:34:48.000 --> 03:34:52.000
.shipping import 

03:34:52.000 --> 03:34:56.000
calculate shipping. Now we don't have to prefix this function

03:34:56.000 --> 03:35:00.000
with ecommerce.shipping, and we can call it multiple times 

03:35:00.000 --> 03:35:04.000
in this module, so our code is a little bit shorter. But what if

03:35:04.000 --> 03:35:08.000
you want to use multiple functions in this shipping module. We can either import them here,

03:35:08.000 --> 03:35:12.000
so calculate shipping, comma, let's say calculate_

03:35:12.000 --> 03:35:16.000
tax. Or we can import the entire module and then 

03:35:16.000 --> 03:35:20.000
access all he functions or classes in that module. So, 

03:35:20.000 --> 03:35:24.000
let me revert this back. To import the entire module 

03:35:24.000 --> 03:35:28.000
we type from ecommerce so we remove.shipping 

03:35:28.000 --> 03:35:32.000
so from this package, import 

03:35:32.000 --> 03:35:36.000
the shipping module. Now the shipping module, 

03:35:36.000 --> 03:35:40.000
is an object so we can access 

03:35:40.000 --> 03:35:44.000
all the functions and classes defined here, using the dot operator, so

03:35:44.000 --> 03:35:48.000
shipping. there you go, calculate shipping. So to 

03:35:48.000 --> 03:35:52.000
recap, when using the from statement we can either start from 

03:35:52.000 --> 03:35:56.000
the package and import a specific module, or we can

03:35:56.000 --> 03:36:00.000
start from package.module 

03:36:00.000 --> 03:36:04.000
and then import a specific function. Like calculate shipping. 

03:36:04.000 --> 03:36:08.000
So, this was the basics of using packages in 

03:36:08.000 --> 03:36:12.000
python. As I told you before, packages are extremely important, especially 

03:36:12.000 --> 03:36:16.000
when you want to work with a framework like django, we use django for building 

03:36:16.000 --> 03:36:20.000
web applications with python, and I'm going to show you that later in this course. 

03:36:20.000 --> 03:36:24.000
So in Django we have quite a few packages and 

03:36:24.000 --> 03:36:28.000
each package contains several modules. So make sure to watch the tutorials, 

03:36:28.000 --> 03:36:32.000
about modules and packages one more time, otherwise you're going to get confused later 

03:36:32.000 --> 03:36:36.000
when we get to Django. 

03:36:36.000 --> 03:36:40.000
In this tutorial I'm going to talk to you 

03:36:40.000 --> 03:36:44.000
guys about the built in modules in python, so python 

03:36:44.000 --> 03:36:48.000
comes with a standard library that contains several modules for common

03:36:48.000 --> 03:36:52.000
tasks such as sending emails, working with date and time, 

03:36:52.000 --> 03:36:56.000
generating random values and passwords and so on. There are so many modules 

03:36:56.000 --> 03:37:00.000
already built into Python and that means there is already lots of functionality 

03:37:00.000 --> 03:37:04.000
that we can reuse. Let me show you where you can find 

03:37:04.000 --> 03:37:08.000
this standard library. So open up this browser

03:37:08.000 --> 03:37:12.000
and search for python 3, module index, 

03:37:12.000 --> 03:37:16.000
make sure to add the version number, because the modules in python 2 are

03:37:16.000 --> 03:37:20.000
different from modules in python3. So here we search for python 3 

03:37:20.000 --> 03:37:24.000
module index, and the first page here, you can see is

03:37:24.000 --> 03:37:28.000
python module index, or python 3, let's go ahead, 

03:37:28.000 --> 03:37:32.000
so these are all the modules built into python, 

03:37:32.000 --> 03:37:36.000
for example we have modules for working with date and time, 

03:37:36.000 --> 03:37:40.000
we have modules for sending emails for encoding values, 

03:37:40.000 --> 03:37:44.000
there are so many modules here. Now the explanation of all these is 

03:37:44.000 --> 03:37:48.000
beyond the scope of this course, that really requires it's own course. 

03:37:48.000 --> 03:37:52.000
Because we have so many modules here, but don't let this list intimidate you. 

03:37:52.000 --> 03:37:56.000
This is not something that you need to learn right now, as you learn python 

03:37:56.000 --> 03:38:00.000
as you build more applications, gradually you will get familiar with more modules

03:38:00.000 --> 03:38:04.000
here, in fact nobody knows all the modules in python

03:38:04.000 --> 03:38:08.000
standard library. Everybody knows some modules based on the applications they have built. 

03:38:08.000 --> 03:38:12.000
So in this tutorial, I'm going to show you how to use one of the built in modules, 

03:38:12.000 --> 03:38:16.000
for generating random values. So on the top,

03:38:16.000 --> 03:38:20.000
we import the random module, now because

03:38:20.000 --> 03:38:24.000
random is a built in module, we don't need to have a file here 

03:38:24.000 --> 03:38:28.000
called random.py. So python interpreter knows that random is a built 

03:38:28.000 --> 03:38:32.000
in module as long as it knows where to find it. 

03:38:32.000 --> 03:38:36.000
Now if you're curious where this random module is stored on the disk, let me show you, so

03:38:36.000 --> 03:38:40.000
here in the project panel, expand external 

03:38:40.000 --> 03:38:44.000
libraries, then expand python 3, 

03:38:44.000 --> 03:38:48.000
and then one more time python 3.7 library 

03:38:48.000 --> 03:38:52.000
route. So this is a folder somewhere on your computer, in this folder, we have 

03:38:52.000 --> 03:38:56.000
all the built in modules in python. So, 

03:38:56.000 --> 03:39:00.000
if you scroll down, you should be able to find. 

03:39:00.000 --> 03:39:04.000
The random module. There you go. It's right here. So random.

03:39:04.000 --> 03:39:08.000
py. You can open this and this shows you the source 

03:39:08.000 --> 03:39:12.000
code of this module. there you go. Now in this tutorial, 

03:39:12.000 --> 03:39:16.000
we don't want to worry about hat, so let's go back to our app.py,

03:39:16.000 --> 03:39:20.000
and use this module to generate random values. So when we import

03:39:20.000 --> 03:39:24.000
this module, now we have this object, random, so we can use the dot

03:39:24.000 --> 03:39:28.000
operator to acces it's methods. One method that is useful

03:39:28.000 --> 03:39:32.000
 here is the random method, and every time we call it it generates

03:39:32.000 --> 03:39:36.000
a random value between 0 and 1. So here we can do a for loop, 

03:39:36.000 --> 03:39:40.000
let's say for I in, 

03:39:40.000 --> 03:39:44.000
range 3. So just to refresh your memory we are using the

03:39:44.000 --> 03:39:48.000
range function to create a range object. We can look through this range object 

03:39:48.000 --> 03:39:52.000
and in each iteration this object will spit out a value. 

03:39:52.000 --> 03:39:56.000
So with this for loop, we can execute this code 3 times. Now, let's 

03:39:56.000 --> 03:40:00.000
indent this. Okay, and finally, let's print the result, 

03:40:00.000 --> 03:40:04.000
There you go. So we can see

03:40:04.000 --> 03:40:08.000
that in each iteration we get a new random value between 0 and 1. 

03:40:08.000 --> 03:40:12.000
Now what if we want a random value for a particular age?

03:40:12.000 --> 03:40:16.000
Let's say random values between 10 and 20, well, 

03:40:16.000 --> 03:40:20.000
there is another method here, rand int, we use 2 arguments here

03:40:20.000 --> 03:40:24.000
to specify our range, let's say 10 and 20. 

03:40:24.000 --> 03:40:28.000
Run our program one more time. Now we have the numbers 20

03:40:28.000 --> 03:40:32.000
13 and 18. If we run our program one more time, 

03:40:32.000 --> 03:40:36.000
We get different values, so 20, 19, 11, one more time. 

03:40:36.000 --> 03:40:40.000
Look, you also have another powerful method for 

03:40:40.000 --> 03:40:44.000
randomly picking an item from a list. Let's say we have a list of team members and you want to

03:40:44.000 --> 03:40:48.000
randomly pick someone as the leader. Let me show you how to do that. 

03:40:48.000 --> 03:40:52.000
So, we define the list of team members, we set it to

03:40:52.000 --> 03:40:56.000
jon, mary, bob, 

03:40:56.000 --> 03:41:00.000
and mosh. Now we can call random 

03:41:00.000 --> 03:41:04.000
.choice and pass our members list 

03:41:04.000 --> 03:41:08.000
this method randomly picks a method from this list and returns it. SO, 

03:41:08.000 --> 03:41:12.000
we can store the result in leader and then 

03:41:12.000 --> 03:41:16.000
print it on the terminal. let's run our program, 

03:41:16.000 --> 03:41:20.000
so now the leader is mary, if you run our program one more time

03:41:20.000 --> 03:41:24.000
this line is mosh now it's mosh again one more time, 

03:41:24.000 --> 03:41:28.000
it really likes mosh, you get the point. So

03:41:28.000 --> 03:41:32.000
the random module is very powerful, and it has a lot of applications. 

03:41:32.000 --> 03:41:36.000
Now here's a very cool exercise. I want you to write this program to 

03:41:36.000 --> 03:41:40.000
roll a dice. So every time we run this program we get a different value. 

03:41:40.000 --> 03:41:44.000
Now we have 3 in 1, next time we get 3 and 6, one more time 

03:41:44.000 --> 03:41:48.000
5 and 6, 4 and 3, double one, that's a very cool exercise. 

03:41:48.000 --> 03:41:52.000
So before we get started, I want you to pay attention to a few things. 

03:41:52.000 --> 03:41:56.000
I want you to define a class called dice 

03:41:56.000 --> 03:42:00.000
in this class we're going to have a method called rope so every time we

03:42:00.000 --> 03:42:04.000
call this method, we get a tuple, a tuple remember is a list of 

03:42:04.000 --> 03:42:08.000
values but values cannot be changed, you cannot add a new item to it, we

03:42:08.000 --> 03:42:12.000
cannot remove it. So it's like a read only list. So every time, 

03:42:12.000 --> 03:42:16.000
we call the row method, we should get the tuple of two random values. 

03:42:16.000 --> 03:42:20.000
So go ahead, and do this exercise, You'll see my solution next. 

03:42:24.000 --> 03:42:28.000
Alright, we start by importing the random module on the top, 

03:42:28.000 --> 03:42:32.000
then we define a class called dice:

03:42:32.000 --> 03:42:36.000
this class we want to have a method called row. So define row 

03:42:36.000 --> 03:42:40.000
parenthesis, this automatically adds self, now in this method, 

03:42:40.000 --> 03:42:44.000
you want to generate two random values between 1 to 6. 

03:42:44.000 --> 03:42:48.000
So we call random.randint. 

03:42:48.000 --> 03:42:52.000
And pass 1 and 6. So this generates the first number, 

03:42:52.000 --> 03:42:56.000
we can ut that here, now let's call this one more time, 

03:42:56.000 --> 03:43:00.000
so I'm going to copy what we have on line 5, put it here, and 

03:43:00.000 --> 03:43:04.000
change this variable to second. So we have two variables first and second.

03:43:04.000 --> 03:43:08.000
With two random values, finally we need to return them, 

03:43:08.000 --> 03:43:12.000
in a tuple, so return parenthesis instead of square brackets, 

03:43:12.000 --> 03:43:16.000
first and second, now 

03:43:16.000 --> 03:43:20.000
in python when you want to return a python from a  function, you don't have to add

03:43:20.000 --> 03:43:24.000
this parenthesis, so you can simplify your code and python will automatically 

03:43:24.000 --> 03:43:28.000
interpret this as a tuple. So we are done 

03:43:28.000 --> 03:43:32.000
with a definition of our class, we remove the indentation and add 

03:43:32.000 --> 03:43:36.000
two line breaks. Now we create an object of this type 

03:43:36.000 --> 03:43:40.000
so you set dice to dice

03:43:40.000 --> 03:43:44.000
next we roll the dice, so dice.roll and 

03:43:44.000 --> 03:43:48.000
print the result on the terminal, that's all you have to do.

03:43:48.000 --> 03:43:52.000
Let's run this program, so now we get 2 and 5, 

03:43:52.000 --> 03:43:56.000
lets run it one more time, 3 and 2, 1 and 1, beautiful. 

03:43:56.000 --> 03:44:00.000
Now we have this little warning here, that says 

03:44:00.000 --> 03:44:04.000
expected 2 black lines found 1. Once again this is

03:44:04.000 --> 03:44:08.000
coming from pep 8, pep is short for python and 

03:44:08.000 --> 03:44:12.000
proposal. We have so many python enhancement proposals or peps.

03:44:12.000 --> 03:44:16.000
Pep 8 is a very famous 1, and in this document we have 

03:44:16.000 --> 03:44:20.000
all the best practices for formatting our code. So pep

03:44:20.000 --> 03:44:24.000
8 says, that after we define our classes we should have 2 lines breaks, we've already done that

03:44:24.000 --> 03:44:28.000
so the reason this is complaining is because we had 1 line break before 

03:44:28.000 --> 03:44:32.000
the class, so let's add one more line break, now pycharm 

03:44:32.000 --> 03:44:36.000
is happy. So basically pycharm is following all the best 

03:44:36.000 --> 03:44:40.000
practices defined in pep8. Now you don't have to memorize 

03:44:40.000 --> 03:44:44.000
any of these best practices, as you code in pycharm, pycharm gives you a little more

03:44:44.000 --> 03:44:48.000
warning, and gradually you will learn how to properly format your code, so it's

03:44:48.000 --> 03:44:52.000
readable by other people. 

03:44:52.000 --> 03:44:56.000
In this tutorial, I'm going to show you

03:44:56.000 --> 03:45:00.000
how to work with directories in python. So here in python3, 

03:45:00.000 --> 03:45:04.000
module index, you can see we have a module called path lib which provides an object 

03:45:04.000 --> 03:45:08.000
oriented file system pact. That basically means it provides

03:45:08.000 --> 03:45:12.000
classes that we can use to create objects to work with directories and 

03:45:12.000 --> 03:45:16.000
files. So, if you click here, you can see how this module

03:45:16.000 --> 03:45:20.000
works, we can see all kinds of examples. For example, here on there basic 

03:45:20.000 --> 03:45:24.000
useage, you can see this is how we import the path

03:45:24.000 --> 03:45:28.000
class from the path lib module. Let me zooming so you can see

03:45:28.000 --> 03:45:32.000
clearly. Okay, so look, from path lib, that's

03:45:32.000 --> 03:45:36.000
our module, import path, note the naming convention. 

03:45:36.000 --> 03:45:40.000
P is capitalized, that means path is a class, so we need to create 

03:45:40.000 --> 03:45:44.000
an instance of this class as you can see, right here, 

03:45:44.000 --> 03:45:48.000
now there's so much documentation here, you can read this on your own, but let me quickly show you

03:45:48.000 --> 03:45:52.000
a few examples to help you get started. So after pycharm 

03:45:52.000 --> 03:45:56.000
on the top, from the path led module, that's

03:45:56.000 --> 03:46:00.000
import the path class. Now we need to create, 

03:46:00.000 --> 03:46:04.000
a path object to reference a file or directory 

03:46:04.000 --> 03:46:08.000
on our computer. So there are basically to ways to do this we can use an absolute

03:46:08.000 --> 03:46:12.000
path, or a relative path which basically 

03:46:12.000 --> 03:46:16.000
means a path starting from the current directory. For example, 

03:46:16.000 --> 03:46:20.000
if you wanna reference this ecommerce directory in our project, we can

03:46:20.000 --> 03:46:24.000
use the relative path. So we start from the current directory and then

03:46:24.000 --> 03:46:28.000
go somewhere else. With absolute paths we start from the root 

03:46:28.000 --> 03:46:32.000
of our hard disk. For example, if you're on Windows you might have 

03:46:32.000 --> 03:46:36.000
an absolute path like this, c drive, backslash, 

03:46:36.000 --> 03:46:40.000
program, files, backslash microsoft, 

03:46:40.000 --> 03:46:44.000
so these are directories in c drive. 

03:46:44.000 --> 03:46:48.000
On Windows we use a backslash to build a path. If you're on

03:46:48.000 --> 03:46:52.000
Mac or Linux, your paths will look a little bit different, so

03:46:52.000 --> 03:46:56.000
instead of backslash we have a forward slash lets say user/local

03:46:56.000 --> 03:47:00.000
/bin. So these are examples of absolute paths. In

03:47:00.000 --> 03:47:04.000
this tutorial we're going to work with he relative path to work with this ecommerce 

03:47:04.000 --> 03:47:08.000
directory that we have in our project. Now if you didn't create this directory 

03:47:08.000 --> 03:47:12.000
earlier, simply right click on the project and then go to new 

03:47:12.000 --> 03:47:16.000
directory. oaky? So, let's close this panel, 

03:47:16.000 --> 03:47:20.000
we create a path object, now, 

03:47:20.000 --> 03:47:24.000
if you don't pas an argument here, this will reference the current directory

03:47:24.000 --> 03:47:28.000
alternatively, we can pass string, in this string we can

03:47:28.000 --> 03:47:32.000
add a file or a directory. let's say the ecommerce 

03:47:32.000 --> 03:47:36.000
directory. Now this runs a path object, so we store it here, 

03:47:36.000 --> 03:47:40.000
now this path object has a few interesting methods 

03:47:40.000 --> 03:47:44.000
for example, we can check to see if a path exists by calling 

03:47:44.000 --> 03:47:48.000
the exist method. This simply returns a boolean so let's print it on the terminal, 

03:47:48.000 --> 03:47:52.000
there you go. So this path exists, 

03:47:52.000 --> 03:47:56.000
what if it changes to ecommerce 1, and 

03:47:56.000 --> 03:48:00.000
run our program and get false, we can also create a new directory 

03:48:00.000 --> 03:48:04.000
for example, let's change our path to email, now when we

03:48:04.000 --> 03:48:08.000
 run this program, obviously we don't have this directory but we can 

03:48:08.000 --> 03:48:12.000
create it by calling the mk dir method 

03:48:12.000 --> 03:48:16.000
so make directory. Let's run our program

03:48:16.000 --> 03:48:20.000
alright, this method returns none which basically means 

03:48:20.000 --> 03:48:24.000
it doesn't return any values. Now if you look at the project panel you can see

03:48:24.000 --> 03:48:28.000
here we have a new directory called emails, we can also delete this directory 

03:48:28.000 --> 03:48:32.000
so, instead of mk dir we call 

03:48:32.000 --> 03:48:36.000
rmdir which is short for remove directory, but 

03:48:36.000 --> 03:48:40.000
let's go ahead, now we can see that directory is gone. We can also see

03:48:40.000 --> 03:48:44.000
all the files and directories in a given path, that is, very useful if you want to

03:48:44.000 --> 03:48:48.000
write a little program to automate something. For example, 

03:48:48.000 --> 03:48:52.000
you can iterate over all the spreadsheets in a directory one them and 

03:48:52.000 --> 03:48:56.000
process them. Let me show you. First we change the path

03:48:56.000 --> 03:49:00.000
to the current directory and then we call the glob 

03:49:00.000 --> 03:49:04.000
method. With his method we cans each for files and 

03:49:04.000 --> 03:49:08.000
directories in the current path. So as the first argument we need to pass a string 

03:49:08.000 --> 03:49:12.000
that defines a search pattern. We can type an asterisk 

03:49:12.000 --> 03:49:16.000
and that means everything, all files and all directories. 

03:49:16.000 --> 03:49:20.000
We can optionally add an extension, so to get all the files, you

03:49:20.000 --> 03:49:24.000
need the files you use star.star. With this 

03:49:24.000 --> 03:49:28.000
pattern, we'll only get the files in the current directory. But not the directories. 

03:49:28.000 --> 03:49:32.000
We can also search for all the py files, or all the excel 

03:49:32.000 --> 03:49:36.000
spreadsheets. Anything. So let's search for all the py files 

03:49:36.000 --> 03:49:40.000
in the current directory, now when we run our program 

03:49:40.000 --> 03:49:44.000
we get this generator object. Generator object 

03:49:44.000 --> 03:49:48.000
are kind of an advanced topic, and they are beyond the scope of this beginners 

03:49:48.000 --> 03:49:52.000
python course. But for now all you need to know is we can iterate 

03:49:52.000 --> 03:49:56.000
or loop through these generator objects. So instead of 

03:49:56.000 --> 03:50:00.000
printing this generator object, let's just iterate over it using 

03:50:00.000 --> 03:50:04.000
a for loop, so, for, file in, 

03:50:04.000 --> 03:50:08.000
the generator object that is returned from the glob method. q

03:50:08.000 --> 03:50:12.000
Let's print file. 

03:50:12.000 --> 03:50:16.000
We run our program, there you go. So these are all the

03:50:16.000 --> 03:50:20.000
py files in my current directory, this could be different on your machine

03:50:20.000 --> 03:50:24.000
if you didn't follow the exercises I gave you earlier. For example, this

03:50:24.000 --> 03:50:28.000
utils.py, we created this as part of one of the exercises earlier in this course. 

03:50:28.000 --> 03:50:32.000
So don't worry if the files you see here are different on your machine. 

03:50:32.000 --> 03:50:36.000
So, you can use the glob method to search for files using 

03:50:36.000 --> 03:50:40.000
a pattern, we can also get all the files and directories in the current 

03:50:40.000 --> 03:50:44.000
path, so, we just use one asterisk, then

03:50:44.000 --> 03:50:48.000
run our program, take a look,  so we have this

03:50:48.000 --> 03:50:52.000
ecommerce directory, we have notes.txt, this is a file I 

03:50:52.000 --> 03:50:56.000
added earlier just to write notes as part of my presentation so you're not going to have

03:50:56.000 --> 03:51:00.000
this file. We also have a bunch of directories and files. 

03:51:04.000 --> 03:51:08.000
Even though python's standard library is comprehensive and has 

03:51:08.000 --> 03:51:12.000
so many modules for common tasks, it's not complete by any means. 

03:51:12.000 --> 03:51:16.000
That's why we have this directory called python package 

03:51:16.000 --> 03:51:20.000
index. Or pypi. And in this directory you can find hundreds 

03:51:20.000 --> 03:51:24.000
of packages for doing awesome things. These are packages that people like you

03:51:24.000 --> 03:51:28.000
and I have built as part of our projects, and then they have published it as part of this directory. 

03:51:28.000 --> 03:51:32.000
For other people to use. So that's why we have a fantastic community in python, 

03:51:32.000 --> 03:51:36.000
there are so many python developers out there and there are so many packages 

03:51:36.000 --> 03:51:40.000
right in front of us to reuse in our programs, let's say

03:51:40.000 --> 03:51:44.000
you want to send text messages in your programs, you don't have to build this functionality from scratch, 

03:51:44.000 --> 03:51:48.000
we can simply come to pypi.org and 

03:51:48.000 --> 03:51:52.000
search for sms aas you can see there are so many 

03:51:52.000 --> 03:51:56.000
projects or apckages that give you this functionality. Of course not every

03:51:56.000 --> 03:52:00.000
package, not every project is complete or bug free, some of them are still 

03:52:00.000 --> 03:52:04.000
in development or they have bugs, but if you look around I'm pretty sure 

03:52:04.000 --> 03:52:08.000
for any kind of function you can imagine there is a good 

03:52:08.000 --> 03:52:12.000
reliable and well documented package for you. In my complete python course, 

03:52:12.000 --> 03:52:16.000
I will show you some of those most useful packages on pypi. For example

03:52:16.000 --> 03:52:20.000
you will learn how to access the information on yelp.com in your

03:52:20.000 --> 03:52:24.000
programs. So you can write a program and search for businesses 

03:52:24.000 --> 03:52:28.000
registered on Yelp. Let's say you want to search for the best barber 

03:52:28.000 --> 03:52:32.000
in New York City. I will show you how to do that. You will also learn how to use a technique called 

03:52:32.000 --> 03:52:36.000
web scraping, which means you can build an engine and have that engine 

03:52:36.000 --> 03:52:40.000
browse a website, and extract information from HDML files.

03:52:40.000 --> 03:52:44.000
This is the same technique that Google does to index various

03:52:44.000 --> 03:52:48.000
websites. So they have several engines, or web crawlers, these web crawlers 

03:52:48.000 --> 03:52:52.000
are continuously looking at various websites and extracting information 

03:52:52.000 --> 03:52:56.000
from their pages. When you publish a blog post Google's web crawler 

03:52:56.000 --> 03:53:00.000
finds the title of your post, its keywords and so on. So, 

03:53:00.000 --> 03:53:04.000
I'm going to show you how to do that with Python, we'll also look at browser automation, and this is extremely 

03:53:04.000 --> 03:53:08.000
powerful, because you can automate testing of your web

03:53:08.000 --> 03:53:12.000
applications. So you might get a job as a test engineer, and 

03:53:12.000 --> 03:53:16.000
your daily job is to browse a website, click here and there, fill out this form, that form, and 

03:53:16.000 --> 03:53:20.000
ensure that this website is functioning properly. You can automate all that 

03:53:20.000 --> 03:53:24.000
with a powerful python package called selenium, as I have shown in my complete, as I show in my complete

03:53:24.000 --> 03:53:28.000
python course. Now in this tutorial, I'm going to show you how to install

03:53:28.000 --> 03:53:32.000
packages, from pypi.org. So, 

03:53:32.000 --> 03:53:36.000
here on pypi.org let's search for open py

03:53:36.000 --> 03:53:40.000
xl. This is a package that we use for working with excel 

03:53:40.000 --> 03:53:44.000
spreadsheets. So let's search for this package, there you go, so currently 

03:53:44.000 --> 03:53:48.000
it's at version 2.5. On the top you can see, 

03:53:48.000 --> 03:53:52.000
this instruction pip install open pyexcel. 

03:53:52.000 --> 03:53:56.000
this is the command that we need to type in the terminal window to

03:53:56.000 --> 03:54:00.000
install this package into our program, so back to pycharm, 

03:54:00.000 --> 03:54:04.000
here on the status bar. You can open up a terminal window for executing 

03:54:04.000 --> 03:54:08.000
various commands. So let's open it, now if you're on Windows 

03:54:08.000 --> 03:54:12.000
you're probably going to see something different instead of this dollar sign, don't worry about that

03:54:12.000 --> 03:54:16.000
just execute this command I'm going to show you. So pip

03:54:16.000 --> 03:54:20.000
install open py xl

03:54:20.000 --> 03:54:24.000
Make sure to spell everything properly. So pip is the tool, 

03:54:24.000 --> 03:54:28.000
that comes with a python installation, and we use it to install or uninstall

03:54:28.000 --> 03:54:32.000
packages registered on pypi.org. So here, 

03:54:32.000 --> 03:54:36.000
we're using pip to install this package. open py 

03:54:36.000 --> 03:54:40.000
xl. Enter, let's go ahead with that, it's going to take a few 

03:54:40.000 --> 03:54:44.000
seconds, oaky done, now we can import this package and it's

03:54:44.000 --> 03:54:48.000
modules just like the built in modules in python, or the modules that we have

03:54:48.000 --> 03:54:52.000
in our project. Now if you're curious where this package

03:54:52.000 --> 03:54:56.000
is stored on disc let me show you. So open up the project panel, 

03:54:56.000 --> 03:55:00.000
and then expand external libraries, next

03:55:00.000 --> 03:55:04.000
expand python 3, and then expand sight packages. 

03:55:04.000 --> 03:55:08.000
This is where all these packages that we installed with pip are stored. 

03:55:08.000 --> 03:55:12.000
So here we have open py xl, you can open this, 

03:55:12.000 --> 03:55:16.000
in this folder we have another folder called cell, now

03:55:16.000 --> 03:55:20.000
Now, look what we have here you have this init

03:55:20.000 --> 03:55:24.000
type, earlier I told you that whenever we add this file to a folder, python treats

03:55:24.000 --> 03:55:28.000
that folder as a package, so sell is a package, and this

03:55:28.000 --> 03:55:32.000
package we have is modules. Sell, interface, read only and text. 

03:55:32.000 --> 03:55:36.000
So as you can see, this package openpyxl has several

03:55:36.000 --> 03:55:40.000
subpackages like cell, start, chart sheet and so on. 

03:55:40.000 --> 03:55:44.000
And in each package we have several modules, in the next tutorial

03:55:44.000 --> 03:55:48.000
I will show you how to work with excel files. 

03:55:48.000 --> 03:55:52.000
So we have covered all the core concepts in Python, I hope you have learned a lot. 

03:55:52.000 --> 03:55:56.000
please support my hard work by liking this video and sharing it with others. 

03:55:56.000 --> 03:56:00.000
And be sure to subscribe to my channel for more tutorials like this. Next we're

03:56:00.000 --> 03:56:04.000
going to work on our first python project that involves automation. 

03:56:04.000 --> 03:56:08.000
You're going to write a python program that can process thousands of spreadsheets

03:56:08.000 --> 03:56:12.000
in under a second. Are you excited? Let's get started.

03:56:16.000 --> 03:56:20.000
In this tutorial I'm going to show you something really awesome you can do with python. You're going to 

03:56:20.000 --> 03:56:24.000
learn how to process spreadsheets, and this is extremely valuable

03:56:24.000 --> 03:56:28.000
in situation where you have hundreds or thousands of spreadsheets that need to

03:56:28.000 --> 03:56:32.000
be updated. If you want to do this by hand it may take hours or days 

03:56:32.000 --> 03:56:36.000
weeks, or even months, you can simply build a python program in less then 

03:56:36.000 --> 03:56:40.000
half an hour. And have that python program, automatically process thousands of spreadsheets

03:56:40.000 --> 03:56:44.000
in under one second. So, here we're going to work on this

03:56:44.000 --> 03:56:48.000
excel spreadsheet. You can download this below this video.

03:56:48.000 --> 03:56:52.000
In this spreadsheet we have three columns, transaction ID,

03:56:52.000 --> 03:56:56.000
product ID, and press. Now don't worry about the fourth column yet. 

03:56:56.000 --> 03:57:00.000
So in this spreadsheet we're going to record all kinds of transactions, but let's say

03:57:00.000 --> 03:57:04.000
due to an error, it could be a human error or a system error. The price that we have

03:57:04.000 --> 03:57:08.000
here is wrong. Let's say we need to decrease this by 10 percent. 

03:57:08.000 --> 03:57:12.000
If you want to do this manually, we'll have to come back here and 

03:57:12.000 --> 03:57:16.000
add a formula, so we typed out equal sign, let's say you want to recalculate

03:57:16.000 --> 03:57:20.000
say you want to recalculate the value of this cell.

03:57:20.000 --> 03:57:24.000
have to get that and then multiply it by 0.9

03:57:24.000 --> 03:57:28.000
and that is like 90% of the original price, we are reducing the original

03:57:28.000 --> 03:57:32.000
reducing the price by 10%. Now when you hit enter you can see the updated price. 

03:57:32.000 --> 03:57:36.000
Next we'll have to come back here, select this cell and

03:57:36.000 --> 03:57:40.000
apply the same formula to all the other rows. Now what if you have thousands of rows

03:57:40.000 --> 03:57:44.000
here? You'll have to scroll up and down, this is going to be very tedious. 

03:57:44.000 --> 03:57:48.000
So we're going to write a python program that will do this for us. It's going to

03:57:48.000 --> 03:57:52.000
auotmate this process and not only that it will also

03:57:52.000 --> 03:57:56.000
add this beautiful chart right here, 

03:57:56.000 --> 03:58:00.000
once again if you want to open up hundreds or thousands of spreadsheets 

03:58:00.000 --> 03:58:04.000
and add a chart to each one, this is going to take at least a week or two

03:58:04.000 --> 03:58:08.000
Our python program is going to do all of this in a matter of seconds.

03:58:08.000 --> 03:58:12.000
So, let's get started. Alright the first thing I want you to do is

03:58:12.000 --> 03:58:16.000
to download this transactions file and add it to your project. 

03:58:16.000 --> 03:58:20.000
I put the link below this video for you to download. So if you're wondering 

03:58:20.000 --> 03:58:24.000
how to put this in this project, you can simply right click the project, 

03:58:24.000 --> 03:58:28.000
and if you're on Mac you have this item where

03:58:28.000 --> 03:58:32.000
reveal in finder, if you're on Windows you should see something like reveal

03:58:32.000 --> 03:58:36.000
in explorer, or file explorer, or whatever it's called

03:58:36.000 --> 03:58:40.000
when you click this, this opens up the direct 

03:58:40.000 --> 03:58:44.000
on your machine where this is stored. So simply copy paste

03:58:44.000 --> 03:58:48.000
the transactions file right here. Now, 

03:58:48.000 --> 03:58:52.000
here on the top, first we need to import the open py excel package. 

03:58:52.000 --> 03:58:56.000
So import open py excel, we can give it a 

03:58:56.000 --> 03:59:00.000
an alias to make our code shorter. So asxl. 

03:59:00.000 --> 03:59:04.000
This is not required but it just makes our code a little bit cleaner. 

03:59:04.000 --> 03:59:08.000
Let me show you. So now instead of typing open pyxl.

03:59:08.000 --> 03:59:12.000
we type xl. okay so that's an alias for

03:59:12.000 --> 03:59:16.000
this package. Now in this package we have a function for loading an xl 

03:59:16.000 --> 03:59:20.000
workbook. So let's call load workbook, 

03:59:20.000 --> 03:59:24.000
and as the argument we pass transactions. 

03:59:24.000 --> 03:59:28.000
.xlsx. So this we load

03:59:28.000 --> 03:59:32.000
our excel workbook and return a workbook object. 

03:59:32.000 --> 03:59:36.000
Okay? Now if you open this workbook, you can see you add only 1

03:59:36.000 --> 03:59:40.000
sheet, and that is called sheet 1, so to access that you use 

03:59:40.000 --> 03:59:44.000
square brackets, and specify the name of the sheet, 

03:59:44.000 --> 03:59:48.000
that is sheet one, make sure to spell this with a capital 

03:59:48.000 --> 03:59:52.000
S. Because this is case sensitive, if you don't spell it properly 

03:59:52.000 --> 03:59:56.000
you're going to get an error, so this returns a sheet, 

03:59:56.000 --> 04:00:00.000
now in this sheet, we have various cells. So

04:00:00.000 --> 04:00:04.000
next you need to learn how to access a particular cell, and that is very easy.

04:00:04.000 --> 04:00:08.000
back to py charm, with this sheet object, you can use 

04:00:08.000 --> 04:00:12.000
square brackets and give the coordinate of a cell. 

04:00:12.000 --> 04:00:16.000
Coordinate is the combination of the column and the row. 

04:00:16.000 --> 04:00:20.000
For example, this cell it's coordinate is a1. 

04:00:20.000 --> 04:00:24.000
So back to pycharm, we can type a1, and this returns 

04:00:24.000 --> 04:00:28.000
our first cell. Also, there is another approach to getting

04:00:28.000 --> 04:00:32.000
a cell, instead of using square brackets with a string, we can

04:00:32.000 --> 04:00:36.000
use the cell method of the sheet object, so, 

04:00:36.000 --> 04:00:40.000
sheet.cell, you pass the row and the column, so row 

04:00:40.000 --> 04:00:44.000
and column 1 these return the exact same 

04:00:44.000 --> 04:00:48.000
cell. Now let's print the value of this cell, cell.value

04:00:48.000 --> 04:00:52.000
and run our program so 

04:00:52.000 --> 04:00:56.000
the value is transaction id, beautiful, 

04:00:56.000 --> 04:01:00.000
so now we need to iterate over all these rows and for each row we need to get the value 

04:01:00.000 --> 04:01:04.000
in the third column. That is the price. We'll get that and then multiply 

04:01:04.000 --> 04:01:08.000
by 0.9. So first we need to know how many rows 

04:01:08.000 --> 04:01:12.000
we have in this spreadsheet. We can get that from the sheet object so sheet

04:01:12.000 --> 04:01:16.000
has an attribute called mx_

04:01:16.000 --> 04:01:20.000
row. Let's print this, so in this sheet, 

04:01:20.000 --> 04:01:24.000
we have 4 row, and you can verify that here. So we have

04:01:24.000 --> 04:01:28.000
a total of 4 rows. So we need to add a for loop.

04:01:28.000 --> 04:01:32.000
that would generate the numbers 1-4. So, 

04:01:32.000 --> 04:01:36.000
let's delete this print statement, nd add a for loop 

04:01:36.000 --> 04:01:40.000
for row in were going to use the range function unction to generate a range of numbers, 

04:01:40.000 --> 04:01:44.000
starting from 1, all the way to sheet 

04:01:44.000 --> 04:01:48.000
.max_grow. Plus 1. The reason we're 

04:01:48.000 --> 04:01:52.000
adding 1 to this, is because as I told you before this range function 

04:01:52.000 --> 04:01:56.000
will generate numbers, starting from this value all the way to this

04:01:56.000 --> 04:02:00.000
value, but it will not include the second value. So currently 

04:02:00.000 --> 04:02:04.000
max row returns 4, if you use range of 1-4 this will generate 

04:02:04.000 --> 04:02:08.000
the numbers 1, 2, and 3, but not 4. 

04:02:08.000 --> 04:02:12.000
So to include 4, we need to add 1 to it. Let's go over here, 

04:02:12.000 --> 04:02:16.000
so we tied sheet.max underline row plus 1. 

04:02:16.000 --> 04:02:20.000
Now before going any further let's just print row and make

04:02:20.000 --> 04:02:24.000
sure our program is working up to this point. So let's run 

04:02:24.000 --> 04:02:28.000
this, we get the numbers 1-4 beautiful. 

04:02:28.000 --> 04:02:32.000
So now we can easily get the cells in the third column. However

04:02:32.000 --> 04:02:36.000
we don't really want this first cell, that's the heading. 

04:02:36.000 --> 04:02:40.000
so technically you want to ignore the first row. Back here, you want to change 

04:02:40.000 --> 04:02:44.000
our range function, and start from 2. Now, 

04:02:44.000 --> 04:02:48.000
we're going to use sheet.cell to get access to the cell

04:02:48.000 --> 04:02:52.000
at this row. And the column should be 3. 

04:02:52.000 --> 04:02:56.000
We get a cell object, let's print it's value

04:02:56.000 --> 04:03:00.000
and make sure you're on the right track, so run the program

04:03:00.000 --> 04:03:04.000
these are the values we get. 5.95

04:03:04.000 --> 04:03:08.000
6.95 and 7.95 these are the

04:03:08.000 --> 04:03:12.000
values of the third column. Next we need to multiply each

04:03:12.000 --> 04:03:16.000
value by 0.9 so instead of printing 

04:03:16.000 --> 04:03:20.000
cell.value we multiplied by 0.9 and this is

04:03:20.000 --> 04:03:24.000
the corrected underline price, 

04:03:24.000 --> 04:03:28.000
so this is the mistake we're going to make with our program, now

04:03:28.000 --> 04:03:32.000
we need to add a new cell to our worksheet, so we want to add all the corrected

04:03:32.000 --> 04:03:36.000
prices, ia  new column, it could also overwrite the values in this column, 

04:03:36.000 --> 04:03:40.000
but in this tutorial I'm going to show you how to add a new column.

04:03:40.000 --> 04:03:44.000
So using the same method, now we need to get a reference to the cell, to the given 

04:03:44.000 --> 04:03:48.000
row, but in the fourth column. So, we call sheet

04:03:48.000 --> 04:03:52.000
.cell, and pass row and four as the arguments. 

04:03:52.000 --> 04:03:56.000
Once again, this returns a cell object, let's store that in a 

04:03:56.000 --> 04:04:00.000
separate variable and call it

04:04:00.000 --> 04:04:04.000
price_cell. So note that my variable names are 

04:04:04.000 --> 04:04:08.000
very descriptive. There is no guess work. You have corrected price which holds

04:04:08.000 --> 04:04:12.000
actual value and we have corrected price, which is a cell

04:04:12.000 --> 04:04:16.000
object in this spreadsheet. Next we have to set the value in this

04:04:16.000 --> 04:04:20.000
cell. So we set corrected price cell.

04:04:20.000 --> 04:04:24.000
value to this corrected price. With these few lines 

04:04:24.000 --> 04:04:28.000
we can easily update our spreadsheet, but first we need to save it. So, 

04:04:28.000 --> 04:04:32.000
after our for loop, we call workbook.

04:04:32.000 --> 04:04:36.000
save. Now let's save this in a new file because we don't want to

04:04:36.000 --> 04:04:40.000
accidentally overwrite the original file in case our program has a bug

04:04:40.000 --> 04:04:44.000
so, I'm going to call that transactions 2.sms 

04:04:44.000 --> 04:04:48.000
ex. And finally let's run our program, 

04:04:48.000 --> 04:04:52.000
so, you can see that happened in a split of a second, now here we have a new file

04:04:52.000 --> 04:04:56.000
tranactions 2. When we open this we get something like this. 

04:04:56.000 --> 04:05:00.000
So you can see we have this 4th column with the updated prices. Beautiful.

04:05:00.000 --> 04:05:04.000
So half of the problem is solved, now we need to add a chart here.

04:05:04.000 --> 04:05:08.000
To add a chart, we need to add a couple classes on the top, so, 

04:05:08.000 --> 04:05:12.000
after this import statement let's type out from 

04:05:12.000 --> 04:05:16.000
open py excel.chart, import, bar chart, 

04:05:16.000 --> 04:05:20.000
comma, reference. 

04:05:20.000 --> 04:05:24.000
So lets see what's going on here. In this package you have a module 

04:05:24.000 --> 04:05:28.000
chart, and from this module we're importing two classes, bar chart, 

04:05:28.000 --> 04:05:32.000
and reference. Again, look at the naming convention used 

04:05:32.000 --> 04:05:36.000
here. The first letter of e very word is capitalized. Also it's better

04:05:36.000 --> 04:05:40.000
to add a line break after our import statements to make our

04:05:40.000 --> 04:05:44.000
code cleaner. So, before we save our workbook, we need to

04:05:44.000 --> 04:05:48.000
add achart to the current sheet. First we need to select a range 

04:05:48.000 --> 04:05:52.000
of values. For this exercise, I'm going to select the values in the fourth column/.

04:05:52.000 --> 04:05:56.000
So all the values in rows 2-4 these are

04:05:56.000 --> 04:06:00.000
the values I'm going to use in our chart. Now in this part 2 example it doesn't really

04:06:00.000 --> 04:06:04.000
make sense to add a chart per transaction, but that doesn't really matter

04:06:04.000 --> 04:06:08.000
we just want a bunch of numbers to create a chart, so after our

04:06:08.000 --> 04:06:12.000
for loop, we're going to use the reference class to select a range of

04:06:12.000 --> 04:06:16.000
values. Now the first argument in the constructor is the

04:06:16.000 --> 04:06:20.000
sheet. So we pass our sheet here, then we add

04:06:20.000 --> 04:06:24.000
4 keyword arguments, the first one is min_row, we set this to

04:06:24.000 --> 04:06:28.000
2. The second one is max_row we set

04:06:28.000 --> 04:06:32.000
this to the maximum row in this sheet. That is sheet, 

04:06:32.000 --> 04:06:36.000
.max_row, so we want to select the cells in row

04:06:36.000 --> 04:06:40.000
2-4. kay? Now to make this code a little bit cleaner 

04:06:40.000 --> 04:06:44.000
I'm going to put this on a new line, so we

04:06:44.000 --> 04:06:48.000
can see clearly, now this is going to select all the cells 

04:06:48.000 --> 04:06:52.000
in all the columns in these rows. That's not what we want. 

04:06:52.000 --> 04:06:56.000
we only want the values in the fourth column, so back here

04:06:56.000 --> 04:07:00.000
we need to set a couple more key word arguments men_call

04:07:00.000 --> 04:07:04.000
or column, we set that to for, and also 

04:07:04.000 --> 04:07:08.000
max underline call, we set that to 4 as well. So we are limiting the range

04:07:08.000 --> 04:07:12.000
of cells we're selecting to the fourth column. 

04:07:12.000 --> 04:07:16.000
Now, we're creating an instance of the reference class, let's store the

04:07:16.000 --> 04:07:20.000
result in a variable called values, so this values object 

04:07:20.000 --> 04:07:24.000
will have all these values in the fourth column, now we are ready to create 

04:07:24.000 --> 04:07:28.000
a chart, so we create an instance of the bar chart class

04:07:28.000 --> 04:07:32.000
and store it in this object. 

04:07:32.000 --> 04:07:36.000
Next, we call chart.add_date and 

04:07:36.000 --> 04:07:40.000
pass our values. That is pretty straight forward finally we need to add this chart 

04:07:40.000 --> 04:07:44.000
to our sheet. So, we call sheet, 

04:07:44.000 --> 04:07:48.000
.add_chart and pass this chart object 

04:07:48.000 --> 04:07:52.000
We should also specify where we want to add this chart.

04:07:52.000 --> 04:07:56.000
let's say we want to add it here, on row 2, after the fourth column. 

04:07:56.000 --> 04:08:00.000
So the coordinate of this cell is e2, and this is going to be, 

04:08:00.000 --> 04:08:04.000
the top left corner of our chart. So as the coordinate I'm going to

04:08:04.000 --> 04:08:08.000
pass e2 that's all we had to do, done. Let's run our

04:08:08.000 --> 04:08:12.000
program one more time, beautiful, let's open up the update

04:08:12.000 --> 04:08:16.000
workbook. And here's the end result, so

04:08:16.000 --> 04:08:20.000
right after the fourth column, we have this beautiful chart. Now we could take this to the next level, 

04:08:20.000 --> 04:08:24.000
we could add a legend here, we could change the color of these bars, we could even use a different 

04:08:24.000 --> 04:08:28.000
kind of chart, it doesn't have to be a bar chart. So to learn more about this we can

04:08:28.000 --> 04:08:32.000
read the documentation for openpyxl. So

04:08:32.000 --> 04:08:36.000
our program is complete, for our code is dirty, it's not clean, it's not 

04:08:36.000 --> 04:08:40.000
organized. We don't have any functions here. We have written all the code in app.py. 

04:08:40.000 --> 04:08:44.000
So let's goo ahead and organize this code like a professional software developer. 

04:08:44.000 --> 04:08:48.000
So, on line 4, we are loading our workbook 

04:08:48.000 --> 04:08:52.000
then we're getting a reference to the first sheet, but we don't really need these two lines here 

04:08:52.000 --> 04:08:56.000
this is purely for demonstration to show you how to access a cell. So, 

04:08:56.000 --> 04:09:00.000
let's delete these unnecessary lines, this is a very important practice

04:09:00.000 --> 04:09:04.000
as you're coding always look at your code, always review it, see if you have some code that is

04:09:04.000 --> 04:09:08.000
not used. Always delete those. Okay, next we are iterating over 

04:09:08.000 --> 04:09:12.000
all the rows, fixing the prices, and then 

04:09:12.000 --> 04:09:16.000
we select the values to add a chart, and finally we save the workbook. 

04:09:16.000 --> 04:09:20.000
Now, if you were going to use this to automate the process of updating

04:09:20.000 --> 04:09:24.000
thousands of spreadsheets, this program wouldn't work, because it's only 

04:09:24.000 --> 04:09:28.000
relying on this file. So we want o reorganize this code, and 

04:09:28.000 --> 04:09:32.000
move it inside of a function. This function should take the name of a function

04:09:32.000 --> 04:09:36.000
So let's define a function. Let's

04:09:36.000 --> 04:09:40.000
call it process_workbook. 

04:09:40.000 --> 04:09:44.000
It gets a file name. Now, we move all the code inside 

04:09:44.000 --> 04:09:48.000
of this function, so let's select everything, and press

04:09:48.000 --> 04:09:52.000
tab, beautiful, now back

04:09:52.000 --> 04:09:56.000
to our function, instead of loading this transactions file we're going to load

04:09:56.000 --> 04:10:00.000
this file name, that's better, 

04:10:00.000 --> 04:10:04.000
Also, now that our program is working properly, there is really no need to store the

04:10:04.000 --> 04:10:08.000
result in a separate file. So here we can

04:10:08.000 --> 04:10:12.000
simply overwrite the same file. So let's pass

04:10:12.000 --> 04:10:16.000
file name, that is the end of our function, so, 

04:10:16.000 --> 04:10:20.000
now, we have this reusable function, we can simply reuse this

04:10:20.000 --> 04:10:24.000
to process thousands of spreadsheets. Earlier in this python course you learned 

04:10:24.000 --> 04:10:28.000
how to find all the files in a  directory, so we can get each file in a directory 

04:10:28.000 --> 04:10:32.000
and pass the name of the file to this function, this function will go

04:10:32.000 --> 04:10:36.000
ahead and update this spreadsheet in just a second or less. 

04:10:36.000 --> 04:10:40.000
So, that was just one example of using python to automate 

04:10:40.000 --> 04:10:44.000
repetitive boring task that waste your time. But automation is not

04:10:44.000 --> 04:10:48.000
just about processing excel spreadsheets, there are so many things we can automate. 

04:10:48.000 --> 04:10:52.000
Here's a question for you, what do you want to automate, how do you want to use python to make your

04:10:52.000 --> 04:10:56.000
life easier? Use the comment box below and let me know. I love to

04:10:56.000 --> 04:11:00.000
hear about your ideas. Next we're going to work on  project which involves machine learning, which is a 

04:11:00.000 --> 04:11:04.000
subset of artificial intelligence. Are you excited? 

04:11:04.000 --> 04:11:08.000
Let's get started. 

04:11:08.000 --> 04:11:12.000
In this section, you're going to learn about machine learning, which is a subset of

04:11:12.000 --> 04:11:16.000
AI or artificial intelligence. It's one of the trending topics in the world, 

04:11:16.000 --> 04:11:20.000
these days, and it's going to have a lot of applications in the future. Here's an example.

04:11:20.000 --> 04:11:24.000
Imagine I ask you to write a program to scan an image, and

04:11:24.000 --> 04:11:28.000
tell if it's a cat or a dog. If you want to build this program using

04:11:28.000 --> 04:11:32.000
traditional programming techniques, your program is going to get overly complex 

04:11:32.000 --> 04:11:36.000
You will have to come up with lots of rules to come up with specific curves

04:11:36.000 --> 04:11:40.000
edges and colors in an image to tell if it's a cat or a dog. 

04:11:40.000 --> 04:11:44.000
But if I give you a black and white photo, your rules may not work, they may break.

04:11:44.000 --> 04:11:48.000
Then you would have to rewrite them. Or I may give you a picture of a cat or a dog from a different

04:11:48.000 --> 04:11:52.000
angle that we did not predict before. So solving this problem 

04:11:52.000 --> 04:11:56.000
using traditional programming techniques is going to get overly complex or

04:11:56.000 --> 04:12:00.000
sometimes impossible. Now to make the matter worse. What if I ask you to extend

04:12:00.000 --> 04:12:04.000
this program such that it supports 3 kinds of animals. 

04:12:04.000 --> 04:12:08.000
Cats, dogs, and horses, once again you will have to rewrite 

04:12:08.000 --> 04:12:12.000
all those rules. That's not going to work. So machine learning is a technique 

04:12:12.000 --> 04:12:16.000
to solve these kinds of problems, and this is how it works. We build

04:12:16.000 --> 04:12:20.000
a model or an engine and give it lots and lots of data. 

04:12:20.000 --> 04:12:24.000
For example, we give it thousands or tens of thousands of pictures of 

04:12:24.000 --> 04:12:28.000
cats and dogs. Our model will then find and learn patterns and the input 

04:12:28.000 --> 04:12:32.000
data, so we can give it a new picture of a cat that we haven't seen before. 

04:12:32.000 --> 04:12:36.000
And ask it, is it a cat or a dog or a horse 

04:12:36.000 --> 04:12:40.000
and it will tell us with a certain level of accuracy, the more input data we give it, the more accurate

04:12:40.000 --> 04:12:44.000
our model is going to be. So that was a very basic example,

04:12:44.000 --> 04:12:48.000
but machine learning has other applications in self driving cars, 

04:12:48.000 --> 04:12:52.000
robotics, language processing, vision processing, 

04:12:52.000 --> 04:12:56.000
forecasting things like stock market trends and the weather, games and so on.

04:12:56.000 --> 04:13:00.000
So that's the basic idea about machine learning. Next we'll look at machine 

04:13:00.000 --> 04:13:04.000
learning in action. 

04:13:04.000 --> 04:13:08.000
A machine learning project involves 

04:13:08.000 --> 04:13:12.000
a number of steps, the first step is to import our data which

04:13:12.000 --> 04:13:16.000
often comes in the form of a csv file. You might have a database with lots of data, 

04:13:16.000 --> 04:13:20.000
we can simply export that data and store it in a csv file for the

04:13:20.000 --> 04:13:24.000
purpose of our machine learning project. So we import our data, next, 

04:13:24.000 --> 04:13:28.000
we need to clean it. And this involves tasks such as duplicated data.

04:13:28.000 --> 04:13:32.000
If you have duplicates in the data, we don't want to feed this to the model, because

04:13:32.000 --> 04:13:36.000
otherwise our model will learn bad patterns in our data and will produce the wrong result, 

04:13:36.000 --> 04:13:40.000
so we should make sure that our input data is in a good, and clean shape.

04:13:40.000 --> 04:13:44.000
If there is data that is irrelevant we should remove them, if there are duplicates

04:13:44.000 --> 04:13:48.000
or incomplete we can remove or modify them, if our data is 

04:13:48.000 --> 04:13:52.000
text based, like the name of countries, or genres of music, 

04:13:52.000 --> 04:13:56.000
or cats and dogs, we need to convert them to numerical values. 

04:13:56.000 --> 04:14:00.000
So this step really depends on the kinds of data we're working with, every project 

04:14:00.000 --> 04:14:04.000
is different. Now that we have a clean data set, we need to split it

04:14:04.000 --> 04:14:08.000
into two segments. One for training our model, and the other for

04:14:08.000 --> 04:14:12.000
testing it, to make sure our model produces the right result.

04:14:12.000 --> 04:14:16.000
For example, if you have 1,000 pictures of cats and dogs, we can reserve

04:14:16.000 --> 04:14:20.000
80% for training, and another 20% for testing. 

04:14:20.000 --> 04:14:24.000
The next step is to create a model, and this involves selecting 

04:14:24.000 --> 04:14:28.000
an algorithm to analyze the data. There are so many machine learning algorithms 

04:14:28.000 --> 04:14:32.000
out there, such as decision trees, neural networks and so on.

04:14:32.000 --> 04:14:36.000
Each algorithm have pros and cons in terms of accuracy and performance 

04:14:36.000 --> 04:14:40.000
so the algorithm you use, depends on the kind of problem

04:14:40.000 --> 04:14:44.000
you're trying to solve and your input data. Now the good news isnthat we don't have to

04:14:44.000 --> 04:14:48.000
explicitly program an algorithm, there are libraries out there that provide these

04:14:48.000 --> 04:14:52.000
algorithms, one of the most popular ones, which we are going to look at 

04:14:52.000 --> 04:14:56.000
in this tutorial, is side kick learn. So we build a model using an algorithm , 

04:14:56.000 --> 04:15:00.000
next we need to train our model. So we feed it our training data. 

04:15:00.000 --> 04:15:04.000
Our model will then look for the patterns in the data, so enxt

04:15:04.000 --> 04:15:08.000
we can ask it to make predictions. Back to our examples of cats and dogs, 

04:15:08.000 --> 04:15:12.000
we can ask our model is this a cat or is this a dog and our model 

04:15:12.000 --> 04:15:16.000
will make a prediction, now the prediction is not always accurate

04:15:16.000 --> 04:15:20.000
in fact when you start out, it's very likely your predictions are inaccurate. 

04:15:20.000 --> 04:15:24.000
So we need to envalue the predictions and measure their accuracy. 

04:15:24.000 --> 04:15:28.000
Then we need to get back to our model and either select a different algorithm 

04:15:28.000 --> 04:15:32.000
that is going to produce a more accurate result for the kind of problem 

04:15:32.000 --> 04:15:36.000
we're trying to solve. Or fine tune the parameters of our model.

04:15:36.000 --> 04:15:40.000
So each algorithm has parameters that we can modify to optimize the

04:15:40.000 --> 04:15:44.000
accuracy. So these are the high level steps that you follow in a machine learning 

04:15:44.000 --> 04:15:48.000
project. Next we'll look at the libraries and tools for machine learning. 

04:15:52.000 --> 04:15:56.000
In this lecture we're going too look at the popular python library

04:15:56.000 --> 04:16:00.000
that we use in machine learning projects. The first one is numpy which

04:16:00.000 --> 04:16:04.000
provides a multidimensional array. A very, very, popular library. 

04:16:04.000 --> 04:16:08.000
The seconnd one is pandas, which is a data analysis library that

04:16:08.000 --> 04:16:12.000
provides a concept called data frame. Data frame is a two dimensional 

04:16:12.000 --> 04:16:16.000
data structure similar to an excel spreadsheet. So we have rows and columns 

04:16:16.000 --> 04:16:20.000
we can select columns in a row or a column or a range of rows and

04:16:20.000 --> 04:16:24.000
columns, again, very very popular in machine learning 

04:16:24.000 --> 04:16:28.000
and data science projects. The third library is mad plot lib which

04:16:28.000 --> 04:16:32.000
is a two dimensional plotting library for creating graphs on plots. 

04:16:32.000 --> 04:16:36.000
The next library is sidekick learn, which is one of the most popular machine learning 

04:16:36.000 --> 04:16:40.000
libraries that provides all these common algorithms like decision trees, 

04:16:40.000 --> 04:16:44.000
neural networks and so on. Now, when working with machine learning 

04:16:44.000 --> 04:16:48.000
projects, we use an environment called jupiter for writing our code, technically we can still

04:16:48.000 --> 04:16:52.000
use vs code or any other code editor, but these editors 

04:16:52.000 --> 04:16:56.000
are not ideal for machine learning projects, because we need to frequently 

04:16:56.000 --> 04:17:00.000
inspect the data, and that is really hard in environments like vs code and 

04:17:00.000 --> 04:17:04.000
terminal. If you're working with a table of 10 or 20 columns 

04:17:04.000 --> 04:17:08.000
visualizing this data in a terminal window is really, really difficult and messy, so thats why we use jupiter.

04:17:08.000 --> 04:17:12.000
So that's why we use jupiter, it makes it really easy to inspect our data. 

04:17:12.000 --> 04:17:16.000
Now to install jupiter, we are going to use  platform called anaconda. 

04:17:16.000 --> 04:17:20.000
So, head over to Anaconda.com/download.

04:17:20.000 --> 04:17:24.000
On this page you can download Anaconda distribution for your operating system, 

04:17:24.000 --> 04:17:28.000
so, we have distributions for Windows Mac and

04:17:28.000 --> 04:17:32.000
Linux. So let's go ahead and install 

04:17:32.000 --> 04:17:36.000
Anaconda for python 3.7. Download, 

04:17:36.000 --> 04:17:40.000
Alright, so

04:17:40.000 --> 04:17:44.000
here's Anaconda, download it on my machine, let's double click this. 

04:17:44.000 --> 04:17:48.000
Alright, first it's going to run a program to determine if the software can be installed. 

04:17:48.000 --> 04:17:52.000
So, let's continue and once again continue, 

04:17:52.000 --> 04:17:56.000
pretty easy, continue one more time, 

04:17:56.000 --> 04:18:00.000
I agree with the license agreement, we can use the default 

04:18:00.000 --> 04:18:04.000
you ca use the default installation location so don't worry about that, just click install,

04:18:04.000 --> 04:18:08.000
give it a few second, now the beautiful thing about Anaconda is it will install

04:18:08.000 --> 04:18:12.000
jupiter, as well as all those data popular science libraries 

04:18:12.000 --> 04:18:16.000
like numpy, Pandas and so on. So we don't have to manually install this

04:18:16.000 --> 04:18:20.000
using pip. Alright now as part of

04:18:20.000 --> 04:18:24.000
the next step Anaconda is suggesting to install Microsoft vs code. We 

04:18:24.000 --> 04:18:28.000
already have this on our machine so we don't have to install it we can go with continue 

04:18:28.000 --> 04:18:32.000
and close the installation, now finally we can move the

04:18:32.000 --> 04:18:36.000
this to trash because we don't need this installer in the future.

04:18:36.000 --> 04:18:40.000
Alright, now open upa  terminal window and type 

04:18:40.000 --> 04:18:44.000
jupiter, with a y, space, notebook. 

04:18:44.000 --> 04:18:48.000
This will start the notebook server on your machine. So enter

04:18:48.000 --> 04:18:52.000
there you go. This will start the notebook server 

04:18:52.000 --> 04:18:56.000
on your machine, we can see these default messages here, don't worry about them, now 

04:18:56.000 --> 04:19:00.000
it automatically opens a browser window, pointing to local host 

04:19:00.000 --> 04:19:04.000
port 888. This is what we call

04:19:04.000 --> 04:19:08.000
jupiter dashboard. On this dashboard we have a few tabs, the first tab

04:19:08.000 --> 04:19:12.000
is the files tab, and by default, this points to your home directory.

04:19:12.000 --> 04:19:16.000
So every user on your machine has a home directory, this its my home directory 

04:19:16.000 --> 04:19:20.000
on Mac, you can see here we have a desktop folder as well as documents, 

04:19:20.000 --> 04:19:24.000
downloads and so on. On your machine you're going to see different folders, so somewhere

04:19:24.000 --> 04:19:28.000
so somewhere on your machine you need to create a jupiter notebook. I'm going to go to desktop

04:19:28.000 --> 04:19:32.000
here's my desktop I don't have anything here, and then

04:19:32.000 --> 04:19:36.000
click new, I want to create a notebook for python 

04:19:36.000 --> 04:19:40.000
3. In this notebook we can write python code, and execute it line by line.

04:19:40.000 --> 04:19:44.000
We can easily visualize our data as you can see over the next few videos. So, 

04:19:44.000 --> 04:19:48.000
let's go ahead with this, 

04:19:48.000 --> 04:19:52.000
alright, here's our first notebook, you can see by default it's called

04:19:52.000 --> 04:19:56.000
untitled, let's change that to Hello World so

04:19:56.000 --> 04:20:00.000
this is going to be the hello world of our machine learning project. Let's

04:20:00.000 --> 04:20:04.000
rename this now if you look at your desktop you can see this file 

04:20:04.000 --> 04:20:08.000
hello world.ipynb. This is a jupiter 

04:20:08.000 --> 04:20:12.000
notebook. It's kind of similar to our py files where we write our

04:20:12.000 --> 04:20:16.000
python code, but it includes additional data that jupiter uses to execute our

04:20:16.000 --> 04:20:20.000
code. So back to our notebook, let's

04:20:20.000 --> 04:20:24.000
do a print hello world. 

04:20:24.000 --> 04:20:28.000
And then, click this run button here

04:20:28.000 --> 04:20:32.000
and here's the result printed in jupiter, so we don't have to

04:20:32.000 --> 04:20:36.000
navigate back and forth between the terminal window we can see all the result

04:20:36.000 --> 04:20:40.000
right here. Next I'm going to show you how to load a data set from a 

04:20:40.000 --> 04:20:44.000
csv file in jupiter. 

04:20:48.000 --> 04:20:52.000
Alright, in this lecture we're going to download a data set from a very popular website called

04:20:52.000 --> 04:20:56.000
caggle.com. Caggle is basically a place to do data science projects. 

04:20:56.000 --> 04:21:00.000
So the first thing you need to do is to create an account, you can sign up with Facebook, 

04:21:00.000 --> 04:21:04.000
Google, or using a custom email and password, once you sign up then come back 

04:21:04.000 --> 04:21:08.000
here, on caggle.com, Here one the search bar 

04:21:08.000 --> 04:21:12.000
search for video game sales. 

04:21:12.000 --> 04:21:16.000
This is the name of a very popular data set that we're going to use in this lecture. So, 

04:21:16.000 --> 04:21:20.000
here in this list you can see the first item with this kind of reddish 

04:21:20.000 --> 04:21:24.000
icon, so, let's go with that, as you can see this data

04:21:24.000 --> 04:21:28.000
set includes the sales data for more then 16,000 videos 

04:21:28.000 --> 04:21:32.000
games. On this page you can see the description of various 

04:21:32.000 --> 04:21:36.000
columns in this data set, we have rank, name, platform, 

04:21:36.000 --> 04:21:40.000
year, and so on, so here's our data source, it's a csv file

04:21:40.000 --> 04:21:44.000
called vg sales.csv, as you can see there are over 16,000

04:21:44.000 --> 04:21:48.000
rows, and 11 columns in this data set. 

04:21:48.000 --> 04:21:52.000
Right below that you can see the first few records of this data set. 

04:21:52.000 --> 04:21:56.000
So, here's our first record, the ranking for this game is 1, it's the wi sport 

04:21:56.000 --> 04:22:00.000
game for wii as the platform and it was released in the year 2006,

04:22:00.000 --> 04:22:04.000
now, what I want you to do is go ahead and 

04:22:04.000 --> 04:22:08.000
download the data set, and as I told you before you need to sign in

04:22:08.000 --> 04:22:12.000
before you can download this. So this will give you a zip file as you can see here, 

04:22:12.000 --> 04:22:16.000
here's our csv file, now I want you to 

04:22:16.000 --> 04:22:20.000
put this right next to your jupiter notebook, on my machine that is on my desktop

04:22:20.000 --> 04:22:24.000
so I'm going to drag and drop this onto the desktop folder. 

04:22:24.000 --> 04:22:28.000
Now, if you look at the desktop you can see here's my 

04:22:28.000 --> 04:22:32.000
jupiter, hello world notebook, and right next to that we have 

04:22:32.000 --> 04:22:36.000
vgsales.csv. With that, we go back 

04:22:36.000 --> 04:22:40.000
to our jupiter notebook, let's remove the first line and instead 

04:22:40.000 --> 04:22:44.000
import pandas 

04:22:44.000 --> 04:22:48.000
as pd. With his we're importing pandas module 

04:22:48.000 --> 04:22:52.000
and renaming it to pd, so we don't have to type pandas. several times in

04:22:52.000 --> 04:22:56.000
this code. Now let's type pd.

04:22:56.000 --> 04:23:00.000
read_csv. And pass the 

04:23:00.000 --> 04:23:04.000
name of our csv file. That is vgsales.

04:23:04.000 --> 04:23:08.000
csv. Now because this csv file, is in the current folder right next to our jupiter notebook, 

04:23:08.000 --> 04:23:12.000
we can easily load it, otherwise we have to supply the full path 

04:23:12.000 --> 04:23:16.000
to this file. So, this returns a 

04:23:16.000 --> 04:23:20.000
data frame object which is like an excel spreadsheet. Let me show you.

04:23:20.000 --> 04:23:24.000
So we store it here, and then we can

04:23:24.000 --> 04:23:28.000
simply type df to inspect it. So one more time let's run this program 

04:23:28.000 --> 04:23:32.000
here's our data frame with these rows and these columns so we have

04:23:32.000 --> 04:23:36.000
frank name platform and so on. Now this data frame object 

04:23:36.000 --> 04:23:40.000
has lots of attributes and methods that we're not going to cover in this tutorial,

04:23:40.000 --> 04:23:44.000
that's really beyond the scope of what we're going to do, so I'm going to leave it up to you to

04:23:44.000 --> 04:23:48.000
read pandas documentation or follow other tutorials to find out about pandas data frames. 

04:23:48.000 --> 04:23:52.000
But in this lecture, I'm going to show you some of the most useful methods and attributes. 

04:23:52.000 --> 04:23:56.000
The first one is shape, so shape 

04:23:56.000 --> 04:24:00.000
let's run this one more time, so here's the shape of this data set, we have over 

04:24:00.000 --> 04:24:04.000
16,000 records and 11 columns. 

04:24:04.000 --> 04:24:08.000
Technically this is a 2 dimensional array of 16,000 

04:24:08.000 --> 04:24:12.000
and 11, okay? Now, we can see here we have another 

04:24:12.000 --> 04:24:16.000
segment for writing code. SO we don't have to write all the code in the first segment 

04:24:16.000 --> 04:24:20.000
so here in the second segment we can call one of the methods of the dataframe,

04:24:20.000 --> 04:24:24.000
that is df.describe. 

04:24:24.000 --> 04:24:28.000
Now when we run this program, we can see the

04:24:28.000 --> 04:24:32.000
output for each segment right next to it. So here's our first

04:24:32.000 --> 04:24:36.000
segment, here we have these three lines, and this is the output of

04:24:36.000 --> 04:24:40.000
the last line. Below that we have our second segment, here we're calling

04:24:40.000 --> 04:24:44.000
the describe method, and right below that we have the output of

04:24:44.000 --> 04:24:48.000
this segment So this is the beauty of jupiter, you can easily visualize 

04:24:48.000 --> 04:24:52.000
our datsa, doing this with vscode in windows is really tedious and

04:24:52.000 --> 04:24:56.000
clunky. So what is the describe method returning? Basically it's

04:24:56.000 --> 04:25:00.000
returning some basic information about each column in this data set, So, 

04:25:00.000 --> 04:25:04.000
as you saw earlier we have columns like rank, year and so 

04:25:04.000 --> 04:25:08.000
on. These are the columns with numerical values. Now for each column we have 

04:25:08.000 --> 04:25:12.000
the count which is the number of records in that column, you can se 

04:25:12.000 --> 04:25:16.000
our rank column has 16,5

04:25:16.000 --> 04:25:20.000
-98 records whereas the year column has 16,3-

04:25:20.000 --> 04:25:24.000
-27 records.. So this shows that some of our records don't 

04:25:24.000 --> 04:25:28.000
have the value for the year column. We have null values.

04:25:28.000 --> 04:25:32.000
So in a real data science or machine learning project we'll have to use some 

04:25:32.000 --> 04:25:36.000
techniques to clean up our data set. One option is to remove the records 

04:25:36.000 --> 04:25:40.000
that don't have a value for the year column. Or we can assign them a default value. 

04:25:40.000 --> 04:25:44.000
That really depends on the project. Now another attribute for each column 

04:25:44.000 --> 04:25:48.000
is mean so this is the average of all the values, now

04:25:48.000 --> 04:25:52.000
in the case of the rank column, this rank doesn't really matter, but look at the year. 

04:25:52.000 --> 04:25:56.000
So the average year year for all these video games in our dataset is

04:25:56.000 --> 04:26:00.000
2006. And this might be  important in the problem we're trying to solve. 

04:26:00.000 --> 04:26:04.000
We also have standard deviation, which is a 

04:26:04.000 --> 04:26:08.000
measure to quanitfy the amount of variation in our set of values, below that we have

04:26:08.000 --> 04:26:12.000
min, as an example the minimum value for the year column 

04:26:12.000 --> 04:26:16.000
is 1980. So quite often when we work with a  new data set, 

04:26:16.000 --> 04:26:20.000
we call the describe method to get some basic statistics about 

04:26:20.000 --> 04:26:24.000
our data. Let me show you another useful attribute. 

04:26:24.000 --> 04:26:28.000
So, in the next segment, let's type df.values. 

04:26:28.000 --> 04:26:32.000
Let's run this, as you can see this returns 

04:26:32.000 --> 04:26:36.000
a two dimensional array, this square bracket indicates the outer array

04:26:36.000 --> 04:26:40.000
and a second one represents an inner array. 

04:26:40.000 --> 04:26:44.000
So the first element inn our outer array, is an 

04:26:44.000 --> 04:26:48.000
array itself, these are the values in this array, which basically 

04:26:48.000 --> 04:26:52.000
represent the first row in our data set. So the video game we ranking 

04:26:52.000 --> 04:26:56.000
1, which is called wii sports. So this was a basic 

04:26:56.000 --> 04:27:00.000
overview of pandas data frames, in the next lecture I'm going to show you

04:27:00.000 --> 04:27:04.000
some of the useful shortcuts of jupiter. 

04:27:08.000 --> 04:27:12.000
In this lecture I'm going to show to you some of the most useful shortcuts in Jupiter, 

04:27:12.000 --> 04:27:16.000
Now the first thing I want you to pay attention to is this green bar on the left. 

04:27:16.000 --> 04:27:20.000
This indicates that this cell is currently in the edit mode, so we can 

04:27:20.000 --> 04:27:24.000
write code here. Now, if we press the 

04:27:24.000 --> 04:27:28.000
escape key, green turns to blue, and that means this cell is

04:27:28.000 --> 04:27:32.000
currently in the command mode. So basically the activated cell can either 

04:27:32.000 --> 04:27:36.000
be in the edit mode or command mode. Depending 

04:27:36.000 --> 04:27:40.000
on the mode, we have different shortcuts, so here we're in the command mode. 

04:27:40.000 --> 04:27:44.000
If we press h, we can see the list of all the 

04:27:44.000 --> 04:27:48.000
keybord shortcuts, right above this list we can 

04:27:48.000 --> 04:27:52.000
see, Mac OS modifier keys, these are the

04:27:52.000 --> 04:27:56.000
 extra keys on a Mac keyboard. If you're a Windows 

04:27:56.000 --> 04:28:00.000
user you're not gong to see these. So as an example, here is the shape of the 

04:28:00.000 --> 04:28:04.000
command key, this is control, this is option, 

04:28:04.000 --> 04:28:08.000
and so on. With this guideline you can easily understand the shortcut associated with 

04:28:08.000 --> 04:28:12.000
each command. Let  me show you. So here we have all 

04:28:12.000 --> 04:28:16.000
the commmands when a cell is in the command mode. For example, we have

04:28:16.000 --> 04:28:20.000
this command, open the command palette. This is exactly like the

04:28:20.000 --> 04:28:24.000
command palette that we have in vs code. Here is a short cut

04:28:24.000 --> 04:28:28.000
to execute this command. That is command shift and F. 

04:28:28.000 --> 04:28:32.000
Okay, so here we have lots of shortcuts, 

04:28:32.000 --> 04:28:36.000
of course you're not going to use all of them all the time, but it's good to have a quick look here to see 

04:28:36.000 --> 04:28:40.000
what is available for you. Tis these shortcuts you can write code much faster. 

04:28:40.000 --> 04:28:44.000
So let me show you somme of the most useful ones. I'm going to close this,

04:28:44.000 --> 04:28:48.000
now with our first cell in the command mode 

04:28:48.000 --> 04:28:52.000
I'm going to press b, and this inserts, a new 

04:28:52.000 --> 04:28:56.000
cell below this cell. We can also go 

04:28:56.000 --> 04:29:00.000
back to our first cell, press escape, now the cell is in the command 

04:29:00.000 --> 04:29:04.000
mode. We can insert an empty cell above this cell by pressing a. 

04:29:04.000 --> 04:29:08.000
So either a or b. A for above or 

04:29:08.000 --> 04:29:12.000
b for below. Now if you don't want this cell, you can press d 

04:29:12.000 --> 04:29:16.000
twice to delete  it. Like this. 

04:29:16.000 --> 04:29:20.000
Now in the cell I'm going to print a hello world message. So print 

04:29:20.000 --> 04:29:24.000
hello world. Now, to

04:29:24.000 --> 04:29:28.000
run the code in this cell, we can click on the run button here, 

04:29:28.000 --> 04:29:32.000
so, here's our print function, and 

04:29:32.000 --> 04:29:36.000
right below that you can see the output of this function. But note that when you run 

04:29:36.000 --> 04:29:40.000
a cell, this will only execute the code in that cell. 

04:29:40.000 --> 04:29:44.000
In other words, the code in other cells will not be executed. 

04:29:44.000 --> 04:29:48.000
Let me show you want I mean, so in the cell below the cell, I'm going to delete the call 

04:29:48.000 --> 04:29:52.000
to a describe method. Instead I'm going to print 

04:29:52.000 --> 04:29:56.000
ocean. Now, I'm going 

04:29:56.000 --> 04:30:00.000
to put the cursor back in this cell where we print this hello world message

04:30:00.000 --> 04:30:04.000
and run this cell. So we can see hello world 

04:30:04.000 --> 04:30:08.000
is displayed here, but the cell below is still displaying 

04:30:08.000 --> 04:30:12.000
the describe table, so we don't see the changes here. Now, 

04:30:12.000 --> 04:30:16.000
to solve this problem, we can go to the cell menu on the top, 

04:30:16.000 --> 04:30:20.000
and run all cells together. This can work for a 

04:30:20.000 --> 04:30:24.000
small project, but sometimes you're working with a large data 

04:30:24.000 --> 04:30:28.000
set, so if you want to run all these cells together it's going to take a lot of time. That is

04:30:28.000 --> 04:30:32.000
the reason jupiter saves the output of each cell, so we don't have to rerun that

04:30:32.000 --> 04:30:36.000
code if it hasn't changed. So this notebook file that we have here, 

04:30:36.000 --> 04:30:40.000
includes our source code organized in cells as 

04:30:40.000 --> 04:30:44.000
well as the output for each cell. That is why it's different 

04:30:44.000 --> 04:30:48.000
from a regular py file where we only have the source code.

04:30:48.000 --> 04:30:52.000
Here we also have autocompletion and intellisence, so in this cell, 

04:30:52.000 --> 04:30:56.000
let's call df data frame 

04:30:56.000 --> 04:31:00.000
. now if you press tab you can see all the attributes

04:31:00.000 --> 04:31:04.000
and methods in this object. So let's call 

04:31:04.000 --> 04:31:08.000
describe, now with the cursor on the name of the method we can

04:31:08.000 --> 04:31:12.000
press shift and tab, to see this tool tip that describes

04:31:12.000 --> 04:31:16.000
what this method does and what parameter it takes. So here in front of 

04:31:16.000 --> 04:31:20.000
so here in front of signature you can see the describe method, these are the paramter

04:31:20.000 --> 04:31:24.000
and their default value, and right below that you can see

04:31:24.000 --> 04:31:28.000
the description of what that method does. In this case, it describes

04:31:28.000 --> 04:31:32.000
generates descriptive statistics, that summarize the central tendency and so on. 

04:31:32.000 --> 04:31:36.000
Similar to vs code, we can also convert a line to comment 

04:31:36.000 --> 04:31:40.000
by pressing command and slash on mac, or

04:31:40.000 --> 04:31:44.000
control slash on windows. Like this. Now that line is a comment, we can 

04:31:44.000 --> 04:31:48.000
press the same shortcut one more time to remove the comment, 

04:31:48.000 --> 04:31:52.000
so these are some of the most useful shortcuts in jupiter. 

04:31:52.000 --> 04:31:56.000
Now over the next few lectures we're going to work on a real machine learning project, but before we get there, 

04:31:56.000 --> 04:32:00.000
let's delete all the cells here, so we start with only a single 

04:32:00.000 --> 04:32:04.000
empty cell, so here, in this cell, first I'm going to press the

04:32:04.000 --> 04:32:08.000
escape button, now the cell is blue, so we're in the command mode, and 

04:32:08.000 --> 04:32:12.000
we can delete the cell by pressing d twice. There you go. 

04:32:12.000 --> 04:32:16.000
Now, the next cell is activated and is in the command mode. 

04:32:16.000 --> 04:32:20.000
So, let's delete this as well, so we have two more cells to delete 

04:32:20.000 --> 04:32:24.000
there you go, and the last one, like this, 

04:32:24.000 --> 04:32:28.000
so now we have an empty notebook with a single cell.

04:32:32.000 --> 04:32:36.000
Over the next few lectures, we're going to work on a  real machine learning project, 

04:32:36.000 --> 04:32:40.000
imagine we have an online music store, when our users sign up, 

04:32:40.000 --> 04:32:44.000
we asked our age and gender, and based on their profile, 

04:32:44.000 --> 04:32:48.000
you recommend various music albums their likely to buy. So in this project, 

04:32:48.000 --> 04:32:52.000
you want to use machine learning to increase sales. 

04:32:52.000 --> 04:32:56.000
So, we want to build a model, we feed this model with some sample data, 

04:32:56.000 --> 04:33:00.000
based on the existing users. Our model will learn the patterns in our data, 

04:33:00.000 --> 04:33:04.000
so we can ask it to make predictions. When a new user signs up, 

04:33:04.000 --> 04:33:08.000
we tell our model, hey, we have a new user with this profile, what 

04:33:08.000 --> 04:33:12.000
is the kind of music, that this user is interested in, our model will say jazz, or hip hop, 

04:33:12.000 --> 04:33:16.000
or whatever, and baed on that we can make suggestions to the user

04:33:16.000 --> 04:33:20.000
so, this is the problem we're going to solve, now back to the list of steps in the machine 

04:33:20.000 --> 04:33:24.000
learning projects, first we need to import our data, then, we should

04:33:24.000 --> 04:33:28.000
prepare or clean it, next we select a machine learning algorithm 

04:33:28.000 --> 04:33:32.000
to build a model, we treat our model and ask it to make predictions. 

04:33:32.000 --> 04:33:36.000
And finally, we evaluate our algorithm to see it's

04:33:36.000 --> 04:33:40.000
accuracy. if it's not accurate we either fine tune our model or 

04:33:40.000 --> 04:33:44.000
select a different algorithm. So let's focus on the first step. 

04:33:44.000 --> 04:33:48.000
Head over to bit.ly/music.csv

04:33:48.000 --> 04:33:52.000
this is a very basic csv that I've created for this project, it's just some random

04:33:52.000 --> 04:33:56.000
made up data it's not real. So we have a table with 3

04:33:56.000 --> 04:34:00.000
columns, age, gender, and genre. Gender 

04:34:00.000 --> 04:34:04.000
can either be one which represents a male, 

04:34:04.000 --> 04:34:08.000
or a 0, which represents a female, here I'm making a few assumptions. 

04:34:08.000 --> 04:34:12.000
I'm assuming that men between 20 and 25 like hip hop men between 

04:34:12.000 --> 04:34:16.000
26 and 30 like jazz, and after the age of 30, 

04:34:16.000 --> 04:34:20.000
they like classical music. For women I'm assuming 

04:34:20.000 --> 04:34:24.000
that if they are between 20 and 25 they like dance music, if

04:34:24.000 --> 04:34:28.000
they are between 26 and 30 they like acoustic music, and just like

04:34:28.000 --> 04:34:32.000
men, after the age of 30 they like classical music. Once again this is

04:34:32.000 --> 04:34:36.000
a made up pattern, it's not the representation of the reality, so, 

04:34:36.000 --> 04:34:40.000
let's go ahead and download this csv. Click on this ... icon here

04:34:40.000 --> 04:34:44.000
and download this file. 

04:34:44.000 --> 04:34:48.000
In my downloads folder, here we have this music.csv. 

04:34:48.000 --> 04:34:52.000
I'm going to drag and drop this onto the desktop because that's where I've

04:34:52.000 --> 04:34:56.000
stored this hello world notebook. So I want you to put this csv file 

04:34:56.000 --> 04:35:00.000
right next to your jupiter notebook. 

04:35:00.000 --> 04:35:04.000
Now, back to our notebook, you need to read the csv file, so just like before 

04:35:04.000 --> 04:35:08.000
first we need to import the pandas module, so import panda 

04:35:08.000 --> 04:35:12.000
as pd. And then we'll call pd, 

04:35:12.000 --> 04:35:16.000
.read_csv and 

04:35:16.000 --> 04:35:20.000
the name of our file is music.csv. As you saw earlier this

04:35:20.000 --> 04:35:24.000
returns a data frame which is a two dimensional array similar to an xl spreadsheet, 

04:35:24.000 --> 04:35:28.000
so let's call that music_

04:35:28.000 --> 04:35:32.000
data. Now let's inspect 

04:35:32.000 --> 04:35:36.000
this music_data to make sure we loaded everything properly so

04:35:36.000 --> 04:35:40.000
run, so here's our data frame, beautiful, next we need

04:35:40.000 --> 04:35:44.000
to prepare or clean the data. And that's the topic for the next lecture. 

04:35:44.000 --> 04:35:48.000
next lecture. 

04:35:48.000 --> 04:35:52.000
The second step in a machine learning project, is cleaning, or 

04:35:52.000 --> 04:35:56.000
preparing the data, and that involves tasks such as removing duplicate 

04:35:56.000 --> 04:36:00.000
null values and so on. Now on this particular data set we don't have to do anything 

04:36:00.000 --> 04:36:04.000
kind of cleaning, because we don't have any duplicates, and as you can see 

04:36:04.000 --> 04:36:08.000
As you can see, all rows have values for all columns, so we don't have null values. 

04:36:08.000 --> 04:36:12.000
But there is one thing we need to do, 

04:36:12.000 --> 04:36:16.000
we should split this data set into two separate data sets, one into the first

04:36:16.000 --> 04:36:20.000
two columns, which we refer to as the input set, and the other 

04:36:20.000 --> 04:36:24.000
with the last column which we refer to as the output set. So when we train a model, 

04:36:24.000 --> 04:36:28.000
so when we train a model we give it two separate data sets. The input set and the output set. 

04:36:28.000 --> 04:36:32.000
The output set which is in this case 

04:36:32.000 --> 04:36:36.000
the genre column contains the predictions so we're telling our model that

04:36:36.000 --> 04:36:40.000
if we have a user who's 20 years old and a male they like 

04:36:40.000 --> 04:36:44.000
hip hop. Once we train our model then we give it a new

04:36:44.000 --> 04:36:48.000
input set. For example, we have a new user who is 

04:36:48.000 --> 04:36:52.000
21 years old and is a male, what is the genre of the music that this

04:36:52.000 --> 04:36:56.000
user probably likes. As you can see in our input set, we don't have 

04:36:56.000 --> 04:37:00.000
a sample for a 21 year old male, so we're going to ask 

04:37:00.000 --> 04:37:04.000
our model to predict that. That is the reason we need to split this data 

04:37:04.000 --> 04:37:08.000
set into two separate sets. Input and output 

04:37:08.000 --> 04:37:12.000
So back to our code, this data frame object has a 

04:37:12.000 --> 04:37:16.000
method called drop. Now

04:37:16.000 --> 04:37:20.000
if you put the cursor on the method name and press shift 

04:37:20.000 --> 04:37:24.000
and tab, you can see this tool tip, so this is the signature of

04:37:24.000 --> 04:37:28.000
this drop method, these are the parameters you can pass here. 

04:37:28.000 --> 04:37:32.000
the parameter we're going to use in this lecture is set to none by default.

04:37:32.000 --> 04:37:36.000
Witht his parter we can specify the columns we want to drop, so

04:37:36.000 --> 04:37:40.000
in this case we set columns 

04:37:40.000 --> 04:37:44.000
to an array with one string, genre 

04:37:44.000 --> 04:37:48.000
now this method doesn't actually modify the original data set. 

04:37:48.000 --> 04:37:52.000
In fact it will create a new data set but without thisq

04:37:52.000 --> 04:37:56.000
call. So by convention we use a capital X to 

04:37:56.000 --> 04:38:00.000
represent that data set, so capital x equals this 

04:38:00.000 --> 04:38:04.000
expression. Now, let's inspect x, 

04:38:04.000 --> 04:38:08.000
so as you can see our input set or x 

04:38:08.000 --> 04:38:12.000
includes these two columns, age and gender, it doesn't have the 

04:38:12.000 --> 04:38:16.000
output or predictions. Next we need to create our output set so, 

04:38:16.000 --> 04:38:20.000
once again we start with our data frame

04:38:20.000 --> 04:38:24.000
using data, using square brackets we can get all the 

04:38:24.000 --> 04:38:28.000
values in a given column. In this case, genre. Once again this returns 

04:38:28.000 --> 04:38:32.000
a new data set. By convention we use a lower case y

04:38:32.000 --> 04:38:36.000
to represent that. So that is our output 

04:38:36.000 --> 04:38:40.000
data. Let's inspect that as well. So, 

04:38:40.000 --> 04:38:44.000
in this data set we only have the predictions or the answers. 

04:38:44.000 --> 04:38:48.000
So we have prepared our data, next we want to create a model using an 

04:38:48.000 --> 04:38:52.000
algorithm. 

04:38:52.000 --> 04:38:56.000
The next step is to build a 

04:38:56.000 --> 04:39:00.000
model using a machine learning algorithm. There are so many algorithms out there, each algorithm 

04:39:00.000 --> 04:39:04.000
has its pros and cons, in terms of the performance and accuracy. 

04:39:04.000 --> 04:39:08.000
In this lecture we're going to use a very simple algorithm called decision tree. 

04:39:08.000 --> 04:39:12.000
Now the good news is we don't have to explicitly 

04:39:12.000 --> 04:39:16.000
program these algorithms, they're already implemented in a  library called side kick

04:39:16.000 --> 04:39:20.000
learn. So, here on the top, 

04:39:20.000 --> 04:39:24.000
from sklearn.tree 

04:39:24.000 --> 04:39:28.000
let's import the decision tree 

04:39:28.000 --> 04:39:32.000
classifier. So sklearn is the package 

04:39:32.000 --> 04:39:36.000
that comes with sidekick learn library, this is the most popular machine learning library 

04:39:36.000 --> 04:39:40.000
in python. In this package, we have a module called tree.

04:39:40.000 --> 04:39:44.000
And in this module we have a class called decision tree classifier. 

04:39:44.000 --> 04:39:48.000
This class implements the decision tree operator, okay?

04:39:48.000 --> 04:39:52.000
So, now we need to create a new instance of this class.

04:39:52.000 --> 04:39:56.000
So, at the end, let's create 

04:39:56.000 --> 04:40:00.000
an object called models nd set it to anew instance of decision, 

04:40:00.000 --> 04:40:04.000
tree classifier. Like this. 

04:40:04.000 --> 04:40:08.000
So now we have a model, next we need to train it so it learns

04:40:08.000 --> 04:40:12.000
patterns in the data, and that is pretty easy. You call model,

04:40:12.000 --> 04:40:16.000
.fit this method takes 

04:40:16.000 --> 04:40:20.000
2 data set. The input set and the output set. 

04:40:20.000 --> 04:40:24.000
So they are capital x, y. 

04:40:24.000 --> 04:40:28.000
Now finally, we need to ask our model to make a prediction, so we can

04:40:28.000 --> 04:40:32.000
ask it, what is the kind of music a 24 year old male likes? Now before

04:40:32.000 --> 04:40:36.000
we do that, let's temporarily inspect our initial data set. That is

04:40:36.000 --> 04:40:40.000
music data. So, look what

04:40:40.000 --> 04:40:44.000
we got here. As I told you earlier, I've assumed 

04:40:44.000 --> 04:40:48.000
that men between 20 and 25 like hip hop music but 

04:40:48.000 --> 04:40:52.000
here we only have 3 samples for men age 

04:40:52.000 --> 04:40:56.000
20, 23,and 25. We don't have a sample for 

04:40:56.000 --> 04:41:00.000
a 21 year old male. So if you ask our model to predict the kind of music 

04:41:00.000 --> 04:41:04.000
that a 21 year old male likes, we expect it to say hip hop. Similarly, 

04:41:04.000 --> 04:41:08.000
I've assumed that women between 20 and 25 like dance music, 

04:41:08.000 --> 04:41:12.000
but we don' have a sample for a 22 year old female. So once again if

04:41:12.000 --> 04:41:16.000
you ask our model to predict the kind of music that a 22 year old woman 

04:41:16.000 --> 04:41:20.000
likes, we expect it to say dance. 

04:41:20.000 --> 04:41:24.000
So, with these assumptions let's go ahead and ask our model 

04:41:24.000 --> 04:41:28.000
to make predictions. So let's remove 

04:41:28.000 --> 04:41:32.000
the last line, and instead we're going to call model 

04:41:32.000 --> 04:41:36.000
.predict. This method takes a 

04:41:36.000 --> 04:41:40.000
2 dimensional array. So here's the outer array. In this array, each element 

04:41:40.000 --> 04:41:44.000
is an array. So I'm going to pass 

04:41:44.000 --> 04:41:48.000
another array here, and in this array I'm going to pass a new input set. 

04:41:48.000 --> 04:41:52.000
a 21 year old male. So 21, 1

04:41:52.000 --> 04:41:56.000
that is like a new record in this table. Okay? So,  

04:41:56.000 --> 04:42:00.000
this is one input set, let's pass another input for a 22 year old 

04:42:00.000 --> 04:42:04.000
female. So here's another array, here, 

04:42:04.000 --> 04:42:08.000
we add 22 comma 0, so we're asking our model to make 2 predictions 

04:42:08.000 --> 04:42:12.000
at the same time. We get the result and store it

04:42:12.000 --> 04:42:16.000
in a variable called predictions, and finally 

04:42:16.000 --> 04:42:20.000
let's inspect that in our notebook. 

04:42:20.000 --> 04:42:24.000
Run, look what we got, our

04:42:24.000 --> 04:42:28.000
model is saying that a 21 year old male likes hip hop, and a  22 year

04:42:28.000 --> 04:42:32.000
old female likes dance music. So our model successfully 

04:42:32.000 --> 04:42:36.000
will make predictions here. But wait a minute, building a model that makes 

04:42:36.000 --> 04:42:40.000
predictions accurately is not always that easy.

04:42:40.000 --> 04:42:44.000
After we build a model we need to measure it's accuracy.

04:42:44.000 --> 04:42:48.000
And if it's not accurate enough, we should either fine tune it or build a model using a different 

04:42:48.000 --> 04:42:52.000
algorithm. So next lecture I'm going to show you how to measure the accuracy of

04:42:52.000 --> 04:42:56.000
a model. 

04:42:56.000 --> 04:43:00.000
In this lecture I'm going to show you

04:43:00.000 --> 04:43:04.000
how to measure the accuracy of your models. Now in order to do so, 

04:43:04.000 --> 04:43:08.000
first we need to split our data set into two sets. One for training and the other 

04:43:08.000 --> 04:43:12.000
for testing, because right now, we are passing the entire data set, 

04:43:12.000 --> 04:43:16.000
for training the model and we're using 2 samples for 

04:43:16.000 --> 04:43:20.000
making predictions. That is not enough to calculate the

04:43:20.000 --> 04:43:24.000
accuracy of a model. A general rule of thumb is to annotate 

04:43:24.000 --> 04:43:28.000
70-80% of our data to training, and another20-30% 

04:43:28.000 --> 04:43:32.000
for testing, then instead of passing only two samples for

04:43:32.000 --> 04:43:36.000
making predictions, we can pass the data set for testing 

04:43:36.000 --> 04:43:40.000
we'll get the predictions and then compare the predictions with the actual values. 

04:43:40.000 --> 04:43:44.000
In the test set. Based on that, we can calculate the 

04:43:44.000 --> 04:43:48.000
accuracy. That's really easy, all we have to do is import a couple functions and 

04:43:48.000 --> 04:43:52.000
call them in this code. Let me show you. So first on this top

04:43:52.000 --> 04:43:56.000
from sklearn.model

04:43:56.000 --> 04:44:00.000
underline selection module we import a function called 

04:44:00.000 --> 04:44:04.000
train test split. With this function we can easily split our

04:44:04.000 --> 04:44:08.000
data set into two sets. So training and testing, 

04:44:08.000 --> 04:44:12.000
now, right here, after we define x and y, 

04:44:12.000 --> 04:44:16.000
sets, we call this funciton, so train 

04:44:16.000 --> 04:44:20.000
test split. We give it 3 

04:44:20.000 --> 04:44:24.000
arguments, x, y, ad a keyword argument that specifies 

04:44:24.000 --> 04:44:28.000
the size of our test dataset. So test

04:44:28.000 --> 04:44:32.000
_size we set it to 0.2 So we're allocating 20%

04:44:32.000 --> 04:44:36.000
of our data for testing. Now this functions returns a 

04:44:36.000 --> 04:44:40.000
tuple, so we can unpack it into 4 variables

04:44:40.000 --> 04:44:44.000
right here. x_train

04:44:44.000 --> 04:44:48.000
x_test y_train and y

04:44:48.000 --> 04:44:52.000
_test. so the first two variables 

04:44:52.000 --> 04:44:56.000
are the input sets for training and testing. 

04:44:56.000 --> 04:45:00.000
And the other are the output sets for training and testing, 

04:45:00.000 --> 04:45:04.000
now, when training our model, 

04:45:04.000 --> 04:45:08.000
instead of passing the entire data set we want to pass only the training data set. 

04:45:08.000 --> 04:45:12.000
So, x_train, 

04:45:12.000 --> 04:45:16.000
and y_train. Also, when making predictions 

04:45:16.000 --> 04:45:20.000
instead of passing these two samples, we pass 

04:45:20.000 --> 04:45:24.000
x_test. So thats the datas set. 

04:45:24.000 --> 04:45:28.000
That contains input values for testing. Now we get 

04:45:28.000 --> 04:45:32.000
the predictions. To calculate the accuracy we simply have to compare these predictions 

04:45:32.000 --> 04:45:36.000
with the actual values we have in the output set 

04:45:36.000 --> 04:45:40.000
for testing. That is very easy. First on the top, 

04:45:40.000 --> 04:45:44.000
we need to import a funciton, so, from sklearn.metric 

04:45:44.000 --> 04:45:48.000
.metrics import accuracy 

04:45:48.000 --> 04:45:52.000
_score. Now at the end. 

04:45:52.000 --> 04:45:56.000
We call this function, so accuracy score and 

04:45:56.000 --> 04:46:00.000
give it two arguments y_test.

04:46:00.000 --> 04:46:04.000
Which contains the expected values and 

04:46:04.000 --> 04:46:08.000
predictions which contains the actual value. 

04:46:08.000 --> 04:46:12.000
Now this functions returns an accuracy score between 0 

04:46:12.000 --> 04:46:16.000
to 1. So we can store it here, 

04:46:16.000 --> 04:46:20.000
and simply display it on the console. So let's go ahead 

04:46:20.000 --> 04:46:24.000
and run this program. So, the accuracy score 

04:46:24.000 --> 04:46:28.000
is 1 or a 100% but if we run this one more time, we're going to see a different result

04:46:28.000 --> 04:46:32.000
because every time we split our data set into 

04:46:32.000 --> 04:46:36.000
training a test sets. We'll have different data sets, because this function 

04:46:36.000 --> 04:46:40.000
randomly picks data for training and testing. Let me show you, so put the cursor 

04:46:40.000 --> 04:46:44.000
in the cell, now we can see this is activated 

04:46:44.000 --> 04:46:48.000
note that if you click this button here, it will run the cell and also insert a new 

04:46:48.000 --> 04:46:52.000
cell below this cell. Let me show you. So if I go to this second cell

04:46:52.000 --> 04:46:56.000
press the skip button, now we are in the command mode, 

04:46:56.000 --> 04:47:00.000
press d twice, okay now it's deleted, if we 

04:47:00.000 --> 04:47:04.000
click the run button, we can see, this code was 

04:47:04.000 --> 04:47:08.000
executed, and now we have a new cell, so if you want to run our cell multiple times 

04:47:08.000 --> 04:47:12.000
every time you have to click this and then run

04:47:12.000 --> 04:47:16.000
it, and then click again, and run it, it's a little bit tedious. So I'll show you a shortcut. 

04:47:16.000 --> 04:47:20.000
Activate the first cell, and press control and enter 

04:47:20.000 --> 04:47:24.000
this runs the current cell without 

04:47:24.000 --> 04:47:28.000
adding a new cell below it. So, back here, lets run it multiple times 

04:47:28.000 --> 04:47:32.000
okay, now look the accuracy dropped to 0.75, it's 

04:47:32.000 --> 04:47:36.000
still good, so the cuuracey scored here, is somewhere 

04:47:36.000 --> 04:47:40.000
between 75% to a hundred %. But let me show you something, if I 

04:47:40.000 --> 04:47:44.000
change the test size, from 0.2 to 0.

04:47:44.000 --> 04:47:48.000
8, so essentially we're using only 20 percent of our data, 

04:47:48.000 --> 04:47:52.000
for training this model. And you're using the other 80% 

04:47:52.000 --> 04:47:56.000
for testing. Now let's see what happens when we run this cell multiple

04:47:56.000 --> 04:48:00.000
times. SO, control and enter, look, the accuracy immediately 

04:48:00.000 --> 04:48:04.000
dropped to 0.4 One more time, now 46% 

04:48:04.000 --> 04:48:08.000
40%, 26%

04:48:08.000 --> 04:48:12.000
it's really, really bad. The reason this is happening is because

04:48:12.000 --> 04:48:16.000
you are using very little data for training this model. This is one of

04:48:16.000 --> 04:48:20.000
 the key concepts in machine learning, the more data we give to our model and the cleaner

04:48:20.000 --> 04:48:24.000
the data is, we get the better result, so if you have duplicates, 

04:48:24.000 --> 04:48:28.000
irrelevant data, or incomplete values, our

04:48:28.000 --> 04:48:32.000
model will learn back patterns in our data. That's why it's really important to clean 

04:48:32.000 --> 04:48:36.000
before training our model. Now let's change this back to 0. 

04:48:36.000 --> 04:48:40.000
2, run this one more time, okay, now 

04:48:40.000 --> 04:48:44.000
the accuracy is 1, 75%, now we drop to 50% 

04:48:44.000 --> 04:48:48.000
again, the reason this is happening, is because we don't have enough data. 

04:48:48.000 --> 04:48:52.000
Some machine learning problems, require, thousands or even millions 

04:48:52.000 --> 04:48:56.000
of samples, to train model, the more complex a problem is, 

04:48:56.000 --> 04:49:00.000
the more data we need. For example, here we're only dealing with a table of three 

04:49:00.000 --> 04:49:04.000
columns, but if you want to build a model to tell if a picture of a cat or a dog or a horse, 

04:49:04.000 --> 04:49:08.000
or a lion, we will need millions of pictures, the more animal 

04:49:08.000 --> 04:49:12.000
it will support the more pictures we need. In the next lecture, we're going to talk about 

04:49:12.000 --> 04:49:16.000
model persistence. 

04:49:16.000 --> 04:49:20.000
So this is a 

04:49:20.000 --> 04:49:24.000
very basic implementation of building a training a model to make a prediction. 

04:49:24.000 --> 04:49:28.000
Now to simplify things I have removed all the code that you wrote in the last lecture for

04:49:28.000 --> 04:49:32.000
calculating the accuracy, because in this lecture, you're going to

04:49:32.000 --> 04:49:36.000
focus on a different topic, So basically we import our data set. 

04:49:36.000 --> 04:49:40.000
Create a  model, train it, and then 

04:49:40.000 --> 04:49:44.000
ask it to make predictions, now this piece of code that you see here, is not what we

04:49:44.000 --> 04:49:48.000
want to run everytime we have a new user or

04:49:48.000 --> 04:49:52.000
every time we want to make recommendations to an existing user

04:49:52.000 --> 04:49:56.000
sometimes it's really time consuming. In this example, we're dealing with a 

04:49:56.000 --> 04:50:00.000
very small data set that only has 20 records. But in a  real application, 

04:50:00.000 --> 04:50:04.000
you might have a data set with thousands or trillions of examples, training for that 

04:50:04.000 --> 04:50:08.000
might take seconds or minutes or even hours. 

04:50:08.000 --> 04:50:12.000
And that is wy model persistence is important, once in a while, 

04:50:12.000 --> 04:50:16.000
you build and train our model and then we save it to a file. 

04:50:16.000 --> 04:50:20.000
Now, next time we want to make predictions, we simply load the model from the file and

04:50:20.000 --> 04:50:24.000
 ask it to make predictions. That model is already trained 

04:50:24.000 --> 04:50:28.000
you don't need to retrain it, it's like an intelligent person. So let me show you

04:50:28.000 --> 04:50:32.000
how to do this. it's very very easy. On the top, 

04:50:32.000 --> 04:50:36.000
from sklearn.externals module

04:50:36.000 --> 04:50:40.000
we import joblib. This

04:50:40.000 --> 04:50:44.000
job lib object has methods for saving and loading modules. So, 

04:50:44.000 --> 04:50:48.000
after we train our model we'll simply call

04:50:48.000 --> 04:50:52.000
job lib .dump and give it 

04:50:52.000 --> 04:50:56.000
two arguments. Our model and the name of the file 

04:50:56.000 --> 04:51:00.000
in which we want to store this model. Let's call this music 

04:51:00.000 --> 04:51:04.000
-recommender.job lib 

04:51:04.000 --> 04:51:08.000
That's all we have to do. Now temporarily I'm going to comment 

04:51:08.000 --> 04:51:12.000
out this line, we don't want to make any predictions, we just want to store

04:51:12.000 --> 04:51:16.000
train model in a file. So let's run this cell with control, 

04:51:16.000 --> 04:51:20.000
and slash, okay, look, in the output 

04:51:20.000 --> 04:51:24.000
we have an array that contains the name of our model file. 

04:51:24.000 --> 04:51:28.000
So this is the return value of the dump method. Now back to our 

04:51:28.000 --> 04:51:32.000
desktop, right next to my notebook we can see our job lib file, this is where our model is stored. 

04:51:32.000 --> 04:51:36.000
It's simply a binary file. Now back to our 

04:51:36.000 --> 04:51:40.000
jupiter notebook. As I told you before in a real application we don't want to

04:51:40.000 --> 04:51:44.000
train model every time. So let's comment out

04:51:44.000 --> 04:51:48.000
these few lines, on Mac, we can press

04:51:48.000 --> 04:51:52.000
command and slash and on windows control slash.

04:51:52.000 --> 04:51:56.000
Okay, these lines are commented out, now this time, instead of dumping 

04:51:56.000 --> 04:52:00.000
our model, we're going to load it, so we call the load method, we don't have the model, we simply 

04:52:00.000 --> 04:52:04.000
pass the name of our model file. This

04:52:04.000 --> 04:52:08.000
returns our trained model. Now with this 

04:52:08.000 --> 04:52:12.000
two lines we can simply make predictions, so, earlier, 

04:52:12.000 --> 04:52:16.000
we assumed that men between 20-25 like hip hop music. 

04:52:16.000 --> 04:52:20.000
let's print predictions and see if our model is behaving 

04:52:20.000 --> 04:52:24.000
so control 

04:52:24.000 --> 04:52:28.000
so this is how we persist and load models. 

04:52:32.000 --> 04:52:36.000
Earlier in this section, I told you that decision trees are the easiest 

04:52:36.000 --> 04:52:40.000
to understand. And that's why we started machine learning with decision trees. In this lecture, we're going to 

04:52:40.000 --> 04:52:44.000
export our model in visual format, so you will see 

04:52:44.000 --> 04:52:48.000
how this model makes predictions, that is really, really cool. 

04:52:48.000 --> 04:52:52.000
Let me show you. So once again I've simplified this code

04:52:52.000 --> 04:52:56.000
so we simply import our data set, create 

04:52:56.000 --> 04:53:00.000
input and output sets, create a model, and 

04:53:00.000 --> 04:53:04.000
train it, that's all we are doing, now I want you to

04:53:04.000 --> 04:53:08.000
follow along with me, type everything exactly as I show you in this lecture. Don't

04:53:08.000 --> 04:53:12.000
worry about what everything means we'll come back to it shortly. So on the top,

04:53:12.000 --> 04:53:16.000
from sklearnimport

04:53:16.000 --> 04:53:20.000
tree, this object has a method for exporting

04:53:20.000 --> 04:53:24.000
our decision tree in a  graphical format. So after we 

04:53:24.000 --> 04:53:28.000
train our model, let's call tree 

04:53:28.000 --> 04:53:32.000
_graph vis. Now here are a few arguments we need

04:53:32.000 --> 04:53:36.000
to pass. The first argument is our model,

04:53:36.000 --> 04:53:40.000
the second is the name oft he output file. So here we're going to use keyword 

04:53:40.000 --> 04:53:44.000
arguments, because this method takes so many parameters, and we want to selectively pass 

04:53:44.000 --> 04:53:48.000
keyword arguments without worrying about their order. So, 

04:53:48.000 --> 04:53:52.000
the parameter we're going to set it out_file 

04:53:52.000 --> 04:53:56.000
let's set this to music-recommend 

04:53:56.000 --> 04:54:00.000
.dot. This is the dot format, which is the 

04:54:00.000 --> 04:54:04.000
graph format, which is a graph description language, you will see that shortly. 

04:54:04.000 --> 04:54:08.000
Now the other parameter you want to set is feature 

04:54:08.000 --> 04:54:12.000
_names. We set this to an array of two strings, 

04:54:12.000 --> 04:54:16.000
age and gender. These are the features 

04:54:16.000 --> 04:54:20.000
or the columns of our data set. So they are properties or features of

04:54:20.000 --> 04:54:24.000
our data. Okay? The other parameter 

04:54:24.000 --> 04:54:28.000
is class names. So class_names 

04:54:28.000 --> 04:54:32.000
we should set this to the list of classes or labels we have

04:54:32.000 --> 04:54:36.000
in our output data set, like hip hop, jazz, classical and so on. 

04:54:36.000 --> 04:54:40.000
So, this y data set includes all the genre

04:54:40.000 --> 04:54:44.000
or all the classes of our data, but they are repeated a few times in this data set. 

04:54:44.000 --> 04:54:48.000
So, here we call y.unit this returns 

04:54:48.000 --> 04:54:52.000
the unique list of classes, now we should sort this alphabetically. 

04:54:52.000 --> 04:54:56.000
So, we call the sorted function, and pass the 

04:54:56.000 --> 04:55:00.000
result a y.unique. 

04:55:00.000 --> 04:55:04.000
The next parameter is labeled, we set 

04:55:04.000 --> 04:55:08.000
this to a string, all, once again don't worry, 

04:55:08.000 --> 04:55:12.000
about the details of these parameters, we're going to come back to these shortly. So, 

04:55:12.000 --> 04:55:16.000
set label to all, then round it, 

04:55:16.000 --> 04:55:20.000
to true, and finally field to true. So, 

04:55:20.000 --> 04:55:24.000
so this is the end result, now let's run this sound 

04:55:24.000 --> 04:55:28.000
using control and enter, okay, 

04:55:28.000 --> 04:55:32.000
here we have a nw file music recommender .. that's a little

04:55:32.000 --> 04:55:36.000
bit funny. So we want to open this file with vs code. 

04:55:36.000 --> 04:55:40.000
So drag and drop this into a vs code window. 

04:55:40.000 --> 04:55:44.000
Okay, here's a dot format, it's

04:55:44.000 --> 04:55:48.000
a textural language for describing graphs 

04:55:48.000 --> 04:55:52.000
Now to visualize this graph we need to install an extension in vs code.

04:55:52.000 --> 04:55:56.000
So on the left side, click extensions panel and search 

04:55:56.000 --> 04:56:00.000
for dot, dot. Look at this second extension here. 

04:56:00.000 --> 04:56:04.000
graphvis or .language

04:56:04.000 --> 04:56:08.000
by stephon vs. Go ahead and install this extension 

04:56:08.000 --> 04:56:12.000
and then reload vs code. Once you do that, you can visualize 

04:56:12.000 --> 04:56:16.000
this dot file. So let me close this tab. 

04:56:16.000 --> 04:56:20.000
Alright, look at this ... on the right side. Click this, 

04:56:20.000 --> 04:56:24.000
you should have a new menu, open preview to the side. So like that

04:56:24.000 --> 04:56:28.000
alright, here's the visualization of our decision tree, 

04:56:28.000 --> 04:56:32.000
let's close the dot file, there you go. This is exactly 

04:56:32.000 --> 04:56:36.000
how our model makes predictions. So we have this

04:56:36.000 --> 04:56:40.000
binary tree, which means every node can have a maximum of two children.

04:56:40.000 --> 04:56:44.000
On top of each note we have a condition 

04:56:44.000 --> 04:56:48.000
if this condition is true we go to the child node on the left side. Otherwise we 

04:56:48.000 --> 04:56:52.000
go to the child node on the right side. So let's see what's happening here, the first condition 

04:56:52.000 --> 04:56:56.000
is age less then or equal to 30 

04:56:56.000 --> 04:57:00.000
.5. If this condition is false, that means that user is 30 years 

04:57:00.000 --> 04:57:04.000
or older, so the genre of the music that their interested in is classical. 

04:57:04.000 --> 04:57:08.000
So here we're classifying people based 

04:57:08.000 --> 04:57:12.000
on their profile. That is the reason we have the word class here, 

04:57:12.000 --> 04:57:16.000
so a user who is 30 years or older, belongs to the class of 

04:57:16.000 --> 04:57:20.000
classical. Or people who like classical music. Now what if this condition 

04:57:20.000 --> 04:57:24.000
is true. That means that user is younger then 

04:57:24.000 --> 04:57:28.000
30, so, now we check the gender, if it's less then 0.5, 

04:57:28.000 --> 04:57:32.000
which basically means it equals to 0, then 

04:57:32.000 --> 04:57:36.000
we're dealing with a female. So we go to the child node here, 

04:57:36.000 --> 04:57:40.000
now once again we have another condition, so we are dealing with a female 

04:57:40.000 --> 04:57:44.000
who is younger than 30. Once again we ned to check their age so 

04:57:44.000 --> 04:57:48.000
is the age less then 25.5? If that's the case 

04:57:48.000 --> 04:57:52.000
then that user likes dance music, otherwise they like acoustic music. 

04:57:52.000 --> 04:57:56.000
So this is a decision tree that our model uses to make predictions 

04:57:56.000 --> 04:58:00.000
Now if you're wondering why we have these floating point numbers

04:58:00.000 --> 04:58:04.000
like 25.5 These are basically the rules 

04:58:04.000 --> 04:58:08.000
that our model generates, based on the patterns in our dataset. 

04:58:08.000 --> 04:58:12.000
As we give our model more data, these rules will change so they are not always the same. 

04:58:12.000 --> 04:58:16.000
So they are not always the same, also the more columns or the more features 

04:58:16.000 --> 04:58:20.000
we have, our decision tree is going to get more complex. 

04:58:20.000 --> 04:58:24.000
We only have two features, age, and gender. Now back to our code 

04:58:24.000 --> 04:58:28.000
let me quickly explain the meaning of all these parameters, we set field to true 

04:58:28.000 --> 04:58:32.000
so each box or each node is filled with a color. We set 

04:58:32.000 --> 04:58:36.000
rounded to true, so they have rounded corners. We set label to all

04:58:36.000 --> 04:58:40.000
so every node has labels that we can read. 

04:58:40.000 --> 04:58:44.000
We set class names to the unique list of genres 

04:58:44.000 --> 04:58:48.000
and that's for displaying the class for each note, right here, and we set

04:58:48.000 --> 04:58:52.000
feature names to age and gender, sow e can see the rules 

04:58:52.000 --> 04:58:56.000
in our notes. So that was a short and 

04:58:56.000 --> 04:59:00.000
sweet introduction to machien learning. Now you can use the materials that you learn in this section 

04:59:00.000 --> 04:59:04.000
and apply them to solve a different set of problems. Now here's a question for you: 

04:59:04.000 --> 04:59:08.000
What ideas do you have for machine learning? What kind of problems do you want to solve 

04:59:08.000 --> 04:59:12.000
with machine learning? Use the comments box below and let me know. I love to

04:59:12.000 --> 04:59:16.000
hear about your ideas! Next we're going to use python and a popular framework called

04:59:16.000 --> 04:59:20.000
django. To build a web application. Are you ready, let's get started

04:59:24.000 --> 04:59:28.000
In this turorial, I'm going to show you how to create your first website with python, and A 

04:59:28.000 --> 04:59:32.000
and a very popular framework called django. So it's spelled with a silent D, 

04:59:32.000 --> 04:59:36.000
and is pronounced django. it's a web framework for

04:59:36.000 --> 04:59:40.000
perfectionists with deadlines. So if you're a perfectionist and you want to quickly put together

04:59:40.000 --> 04:59:44.000
a website that is fast, scaleable and secure, 

04:59:44.000 --> 04:59:48.000
django is your best friend. And here are the popular websites 

04:59:48.000 --> 04:59:52.000
built with Django. Like Instagram, Spotify

04:59:52.000 --> 04:59:56.000
YouTube, Washington Post, and so on. Now you might say

04:59:56.000 --> 05:00:00.000
what is a framework, and why do we need a framework to build a web application or a web site?

05:00:00.000 --> 05:00:04.000
Well, the framework is essentially a library of reusable modules

05:00:04.000 --> 05:00:08.000
these modules provide functionality for common tasks 

05:00:08.000 --> 05:00:12.000
for example, in the case of a web framework like django we have modules to work with http requests 

05:00:12.000 --> 05:00:16.000
url's, sessions, cookies and so on. 

05:00:16.000 --> 05:00:20.000
These are the concerns of pretty much every website or 

05:00:20.000 --> 05:00:24.000
application out there. So all this functionality is baked into django, we don't have to

05:00:24.000 --> 05:00:28.000
code it from scratch, that is why we use a framework like django. Now, 

05:00:28.000 --> 05:00:32.000
django. Now technically a framework is more then a library, 

05:00:32.000 --> 05:00:36.000
apart from providing these modules it also provides a structure for each application 

05:00:36.000 --> 05:00:40.000
It tells us what folders or files we should have in our project. So this

05:00:40.000 --> 05:00:44.000
provides a consistency among various django projects. So as you

05:00:44.000 --> 05:00:48.000
move from one company to another and work on different projects, you can easily transition from one

05:00:48.000 --> 05:00:52.000
project to another, because all these applications follow the same structure

05:00:52.000 --> 05:00:56.000
now, with that interaction, let's create our first 

05:00:56.000 --> 05:01:00.000
django project. So back to pycharm, close the hello world 

05:01:00.000 --> 05:01:04.000
project, and create a new project, create a new project, 

05:01:04.000 --> 05:01:08.000
let's call this new project pyshop

05:01:08.000 --> 05:01:12.000
go ahead, alright, now down at the bottom let's 

05:01:12.000 --> 05:01:16.000
open up a terminal window, in this window we're going to

05:01:16.000 --> 05:01:20.000
install django. So we use pip to install 

05:01:20.000 --> 05:01:24.000
django. But be sure to add two equal signs here followed by

05:01:24.000 --> 05:01:28.000
 2.1 With this we are telling pip that we want to install django version 

05:01:28.000 --> 05:01:32.000
2.1. The reason I'm doing this, is because in the future when you're watching this video, 

05:01:32.000 --> 05:01:36.000
chances are there is a newer version django out there. I 

05:01:36.000 --> 05:01:40.000
want to make sure that you can easily follow these tutorials, even though what I'm going to show you 

05:01:40.000 --> 05:01:44.000
in these tutorials will most likely work with the latest version of django. I just want to

05:01:44.000 --> 05:01:48.000
be on the safe side. So let's go ahead

05:01:48.000 --> 05:01:52.000
alright, django is installed, 

05:01:52.000 --> 05:01:56.000
next we need to create a django project, so here press control and L

05:01:56.000 --> 05:02:00.000
this cleans up our terminal window, you don't have to do it, but it's just

05:02:00.000 --> 05:02:04.000
easier to see. To create a django project, we need to execute this command, django, 

05:02:04.000 --> 05:02:08.000
-admin space 

05:02:08.000 --> 05:02:12.000
start project space, you're going to call this 

05:02:12.000 --> 05:02:16.000
project pyshop space period. 

05:02:16.000 --> 05:02:20.000
So when we install django, django brings a 

05:02:20.000 --> 05:02:24.000
command line utility called django admin so this is a utility or program

05:02:24.000 --> 05:02:28.000
that we can execute form the command line or terminal, right here. 

05:02:28.000 --> 05:02:32.000
Now, this program takes various arguments, in this case 

05:02:32.000 --> 05:02:36.000
we want to use this argument start project, with this we're going to create

05:02:36.000 --> 05:02:40.000
a project called pushup in the current folder. 

05:02:40.000 --> 05:02:44.000
So this period is imported here, that means the current folder, if

05:02:44.000 --> 05:02:48.000
you don't add this period, this utility is going to create an extra folder and that

05:02:48.000 --> 05:02:52.000
looks a little bit repetitive, so let's go ahead with this, 

05:02:52.000 --> 05:02:56.000
alright, now, back to the project panel, if you expand py

05:02:56.000 --> 05:03:00.000
shop we can see that this is our project that we created in pycharm 

05:03:00.000 --> 05:03:04.000
and in this folder we have these files. 

05:03:04.000 --> 05:03:08.000
So, init.py, you have seen this before, that means 

05:03:08.000 --> 05:03:12.000
this folder is package, so we can import various modules, 

05:03:12.000 --> 05:03:16.000
of this package into other modules, and in this module, 

05:03:16.000 --> 05:03:20.000
we define various settings for our application, you're going to see this later in

05:03:20.000 --> 05:03:24.000
this course. You also have this url's module, and with this module 

05:03:24.000 --> 05:03:28.000
we define what should the user see when they see slash

05:03:28.000 --> 05:03:32.000
about/contact/products/shopping cart

05:03:32.000 --> 05:03:36.000
again, we're going to work with this only. And finally we have this module,

05:03:36.000 --> 05:03:40.000
that wsgi, that is short for web server gateway

05:03:40.000 --> 05:03:44.000
interface. The purpose of this module is to provide a standard interface

05:03:44.000 --> 05:03:48.000
between applications built with django and web servers. This is 

05:03:48.000 --> 05:03:52.000
an advanced topic, so for now, don't worry about it. Now, outside of this folder, 

05:03:52.000 --> 05:03:56.000
of this folder you also have this new folder in our project 

05:03:56.000 --> 05:04:00.000
manage.py. As the name implies, we use this to manage 

05:04:00.000 --> 05:04:04.000
this django project. With this we can start our web server,  

05:04:04.000 --> 05:04:08.000
we can work with our data base, again, we're going to work with this soon, 

05:04:08.000 --> 05:04:12.000
let's open up the terminal window one more time, now, 

05:04:12.000 --> 05:04:16.000
type out this command, python if you're on windows or python 

05:04:16.000 --> 05:04:20.000
3 if you're on Mac, because as I told you at the beginning of the course, Mac by 

05:04:20.000 --> 05:04:24.000
default comes with an installation of python, that is python 2. But that is

05:04:24.000 --> 05:04:28.000
this course is python 3. So python 3 space manage 

05:04:28.000 --> 05:04:32.000
.py space run 

05:04:32.000 --> 05:04:36.000
server. What is going on here? So with python interpreter 

05:04:36.000 --> 05:04:40.000
we are running this program manage.py and passing run server 

05:04:40.000 --> 05:04:44.000
as an argument. This manage.py is essentially the same program 

05:04:44.000 --> 05:04:48.000
that we worked with here, django admin. 

05:04:48.000 --> 05:04:52.000
But we use django admin before creating a django project, now we have a django project, so now 

05:04:52.000 --> 05:04:56.000
in this project we work with manage.py this

05:04:56.000 --> 05:05:00.000
is a module that contains some python code, so we use this module to manage 

05:05:00.000 --> 05:05:04.000
our django project. So let's go ahead and 

